// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved.

#pragma one

#define NEEDS_LIGHTMAP_COORDINATE		(HQ_TEXTURE_LIGHTMAP || LQ_TEXTURE_LIGHTMAP)
#ifdef USING_TESSELLATION
#undef USING_TESSELLATION
// Needed for VertexFactoryInterpolate
#define USING_TESSELLATION 1
#endif

// #dxr_todo: Temporarily hacking clip() away to prevent driver crash. Should be integrated into MaterialTemplate.ush in the future.
#define clip(x) (x)
#define ddx(x) 0
#define ddy(x) 0

#include "/Engine/Private/Common.ush"
#include "RayTracingCommon.ush"
#include "RayTracingHitGroupCommon.ush"

#include "/Engine/Generated/Material.ush"
#include "/Engine/Generated/VertexFactory.ush"

#include "/Engine/Private/SHCommon.ush"
#include "/Engine/Private/LightmapCommon.ush"

#if SIMPLE_FORWARD_SHADING
	#define GetEffectiveSkySHDiffuse GetSkySHDiffuseSimple
#else
	#define GetEffectiveSkySHDiffuse GetSkySHDiffuse
#endif

/** Computes sky diffuse lighting, including precomputed shadowing. */
void GetSkyLighting(FMaterialPixelParameters MaterialParameters, float3 WorldNormal, float2 LightmapUV, float3 SkyOcclusionUV3D, out float3 OutDiffuseLighting, out float3 OutSubsurfaceLighting)
{
	OutDiffuseLighting = 0;
	OutSubsurfaceLighting = 0;

#if ENABLE_SKY_LIGHT

	float SkyVisibility = 1;
	float GeometryTerm = 1;
	float3 SkyLightingNormal = WorldNormal;
	
	#if HQ_TEXTURE_LIGHTMAP || CACHED_POINT_INDIRECT_LIGHTING || CACHED_VOLUME_INDIRECT_LIGHTING || PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
		BRANCH
		if (View.SkyLightParameters.x > 0)
		{
			#if PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
			
				float3 SkyBentNormal = GetVolumetricLightmapSkyBentNormal(SkyOcclusionUV3D);
				SkyVisibility = length(SkyBentNormal);
				float3 NormalizedBentNormal = SkyBentNormal / max(SkyVisibility, .0001f);

			#elif HQ_TEXTURE_LIGHTMAP

				// Bent normal from precomputed texture
				float4 WorldSkyBentNormalAndOcclusion = GetSkyBentNormalAndOcclusion(LightmapUV * float2(1, 2), MaterialParameters.SvPosition.xy);
				// Renormalize as vector was quantized and compressed
				float3 NormalizedBentNormal = normalize(WorldSkyBentNormalAndOcclusion.xyz);
				SkyVisibility = WorldSkyBentNormalAndOcclusion.w;

			#elif CACHED_POINT_INDIRECT_LIGHTING || CACHED_VOLUME_INDIRECT_LIGHTING
 
				// Bent normal from the indirect lighting cache - one value for the whole object
				float3 NormalizedBentNormal = IndirectLightingCache.PointSkyBentNormal.xyz;
				SkyVisibility = IndirectLightingCache.PointSkyBentNormal.w;

			#endif

			#if (MATERIALBLENDING_TRANSLUCENT || MATERIALBLENDING_ADDITIVE) && (TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL || TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_NONDIRECTIONAL)
				// NonDirectional lighting can't depend on the normal
				SkyLightingNormal = NormalizedBentNormal;
			#else
				
				// Weight toward the material normal to increase directionality
				float BentNormalWeightFactor = 1 - (1 - SkyVisibility) * (1 - SkyVisibility);

				// We are lerping between the inputs of two lighting scenarios based on occlusion
				// In the mostly unoccluded case, evaluate sky lighting with the material normal, because it has higher detail
				// In the mostly occluded case, evaluate sky lighting with the bent normal, because it is a better representation of the incoming lighting
				// Then treat the lighting evaluated along the bent normal as an area light, so we must apply the lambert term
				SkyLightingNormal = lerp(NormalizedBentNormal, WorldNormal, BentNormalWeightFactor);

				float DotProductFactor = lerp(saturate(dot(NormalizedBentNormal, WorldNormal)), 1, BentNormalWeightFactor);
				// Account for darkening due to the geometry term
				GeometryTerm = DotProductFactor;
			#endif
		}
	#endif
			
	// Compute the preconvolved incoming lighting with the bent normal direction
	float3 DiffuseLookup = GetEffectiveSkySHDiffuse(SkyLightingNormal) * ResolvedView.SkyLightColor.rgb;

	// Apply AO to the sky diffuse
	OutDiffuseLighting += DiffuseLookup * (SkyVisibility * GeometryTerm);

	#if MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE
		float3 BackfaceDiffuseLookup = GetEffectiveSkySHDiffuse(-WorldNormal) * ResolvedView.SkyLightColor.rgb;
		OutSubsurfaceLighting += BackfaceDiffuseLookup * SkyVisibility;
	#endif

#endif
}

/** Calculates indirect lighting contribution on this object from precomputed data. */
void GetPrecomputedIndirectLightingAndSkyLight(
	FMaterialPixelParameters MaterialParameters, 
	FVertexFactoryInterpolantsVSToPS Interpolants,
	float3 DiffuseDir,
	float3 VolumetricLightmapBrickTextureUVs,
	out float3 OutDiffuseLighting,
	out float3 OutSubsurfaceLighting,
	out float OutIndirectIrradiance)
{
	OutIndirectIrradiance = 0;
	OutDiffuseLighting = 0;
	OutSubsurfaceLighting = 0;
	float2 SkyOcclusionUV = 0;

	#if PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
		FThreeBandSHVectorRGB IrradianceSH = GetVolumetricLightmapSH3(VolumetricLightmapBrickTextureUVs);

		// Diffuse convolution
		FThreeBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH3(DiffuseDir, 1);
		OutDiffuseLighting = max(float3(0,0,0), DotSH3(IrradianceSH, DiffuseTransferSH)) / PI;

		#if MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE
			FThreeBandSHVector SubsurfaceTransferSH = CalcDiffuseTransferSH3(-DiffuseDir, 1);
			OutSubsurfaceLighting += max(float3(0,0,0), DotSH3(IrradianceSH, SubsurfaceTransferSH)) / PI;
		#endif

	// High quality texture lightmaps
	#elif HQ_TEXTURE_LIGHTMAP
		float2 LightmapUV0, LightmapUV1;
		uint LightmapDataIndex;
		GetLightMapCoordinates(Interpolants, LightmapUV0, LightmapUV1, LightmapDataIndex);
		SkyOcclusionUV = LightmapUV0;

		uint VTRequest = 0;
		GetLightMapColorHQ(LightmapUV0, LightmapUV1, LightmapDataIndex, DiffuseDir, MaterialParameters.SvPosition.xy, OutDiffuseLighting, OutSubsurfaceLighting, VTRequest);

	// Low quality texture lightmaps
	#elif LQ_TEXTURE_LIGHTMAP

		float2 LightmapUV0, LightmapUV1;
		uint LightmapDataIndex;
		GetLightMapCoordinates(Interpolants, LightmapUV0, LightmapUV1, LightmapDataIndex);
		OutDiffuseLighting = GetLightMapColorLQ(LightmapUV0, LightmapUV1, LightmapDataIndex, DiffuseDir).rgb;

	#endif

	// Apply indirect lighting scale while we have only accumulated lightmaps
	OutDiffuseLighting *= View.IndirectLightingColorScale;
	OutSubsurfaceLighting *= View.IndirectLightingColorScale;

	float3 SkyDiffuseLighting;
	float3 SkySubsurfaceLighting;
	GetSkyLighting(MaterialParameters, DiffuseDir, SkyOcclusionUV, VolumetricLightmapBrickTextureUVs, SkyDiffuseLighting, SkySubsurfaceLighting);

	OutSubsurfaceLighting += SkySubsurfaceLighting;

	// Sky lighting must contribute to IndirectIrradiance for ReflectionEnvironment lightmap mixing
	OutDiffuseLighting += SkyDiffuseLighting;

	#if HQ_TEXTURE_LIGHTMAP || LQ_TEXTURE_LIGHTMAP || CACHED_VOLUME_INDIRECT_LIGHTING || CACHED_POINT_INDIRECT_LIGHTING || PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
		OutIndirectIrradiance = Luminance(OutDiffuseLighting);
	#endif
}

float4 ClipSpacePositionToSvPosition(float4 ClipSpacePosition)
{
	float3 NDCPos = ClipSpacePosition.xyz / ClipSpacePosition.w;

	float4 SvPosition;
	SvPosition.xy = ((NDCPos.xy * float2(0.5, -0.5) + 0.5f) * ResolvedView.ViewSizeAndInvSize.xy) + ResolvedView.ViewRectMin.xy;
	SvPosition.z = NDCPos.z;
	SvPosition.w = ClipSpacePosition.w;

	return SvPosition;
}

void CalcInterpolants(in FDefaultAttributes Attributes, out FVertexFactoryInterpolantsVSToPS Interpolants, out float4 FakeSvPosition)
{
	FVertexFactoryInterpolantsVSToDS PerVertexInterpolants[3];
	float4 PerVertexClipSpacePositions[3]; // Used to fake SvPosition
	
	for (int i = 0; i < 3; i++)
	{
		FVertexFactoryInput Input = LoadVertexFactoryInput(PrimitiveIndex(), i);
	
		FVertexFactoryIntermediates VFIntermediates = GetVertexFactoryIntermediates(Input);
		float3x3 TangentToLocal = VertexFactoryGetTangentToLocal(Input, VFIntermediates);	
		float4 WorldPositionExcludingWPO = VertexFactoryGetWorldPosition(Input, VFIntermediates);
		FMaterialVertexParameters VertexParameters = GetMaterialVertexParameters(Input, VFIntermediates, WorldPositionExcludingWPO, TangentToLocal);
		
		float4 WorldPosition = WorldPositionExcludingWPO + float4(GetMaterialWorldPositionOffset(VertexParameters), 0.0f);
		
		PerVertexInterpolants[i] = VertexFactoryGetInterpolantsVSToDS(Input, VFIntermediates, VertexParameters);
		
		float4 RasterizedWorldPosition = VertexFactoryGetRasterizedWorldPosition(Input, VFIntermediates, WorldPosition);
		PerVertexClipSpacePositions[i] = mul(RasterizedWorldPosition, ResolvedView.TranslatedWorldToClip);

	}
	
	FVertexFactoryInterpolantsVSToDS Interpolated = 
		VertexFactoryInterpolate(
			VertexFactoryInterpolate(
				PerVertexInterpolants[0], 1 - Attributes.Barycentrics.x - Attributes.Barycentrics.y,
				PerVertexInterpolants[1], Attributes.Barycentrics.x),
			1.0f,
			PerVertexInterpolants[2], Attributes.Barycentrics.y);
	
	Interpolants = VertexFactoryAssignInterpolants(Interpolated);
	
	float4 ClipSpacePosition = PerVertexClipSpacePositions[0] * (1 - Attributes.Barycentrics.x - Attributes.Barycentrics.y) + PerVertexClipSpacePositions[1] * Attributes.Barycentrics.x + PerVertexClipSpacePositions[2] * Attributes.Barycentrics.y;
	FakeSvPosition = ClipSpacePosition / ClipSpacePosition.w;
}

[shader("closesthit")]
void MaterialCHS(inout FPackedMaterialClosestHitPayload PackedPayload, in FDefaultAttributes Attributes)
{
	ResolvedView = ResolveView();

	FVertexFactoryInterpolantsVSToPS Interpolants;
	float4 SvPosition;
	
	CalcInterpolants(Attributes, Interpolants, SvPosition);

	FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(Interpolants, SvPosition);
	FPixelMaterialInputs PixelMaterialInputs;

	{
		float4 ScreenPosition = SvPositionToResolvedScreenPosition(SvPosition);
		float3 TranslatedWorldPosition = WorldRayOrigin() + WorldRayDirection() * RayTCurrent() + ResolvedView.PreViewTranslation.xyz;
		
		bool bIsFrontFace = HitKind() == HIT_KIND_TRIANGLE_FRONT_FACE;

		MaterialParameters.CameraVector = -WorldRayDirection();

		// #dxr_todo: support world position offset at some point
		// #if USE_WORLD_POSITION_EXCLUDING_SHADER_OFFSETS
		// CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, SvPosition, ScreenPosition, bIsFrontFace, TranslatedWorldPosition, BasePassInterpolants.PixelPositionExcludingWPO);
		// #else
		CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, SvPosition, ScreenPosition, bIsFrontFace, TranslatedWorldPosition, TranslatedWorldPosition);
		// #endif
	}

	FMaterialClosestHitPayload Payload = (FMaterialClosestHitPayload)0;

	// Store the results in local variables and reuse instead of calling the functions multiple times.
	half3 BaseColor = GetMaterialBaseColor(PixelMaterialInputs);
	half2 Refraction = GetMaterialRefraction(PixelMaterialInputs);
	half  Metallic = GetMaterialMetallic(PixelMaterialInputs);
	half  Specular = GetMaterialSpecular(PixelMaterialInputs);
	half Roughness = GetMaterialRoughness(PixelMaterialInputs);

	Payload.WorldPos = MaterialParameters.AbsoluteWorldPosition;
	Payload.WorldNormal = normalize(MaterialParameters.WorldNormal);
	Payload.Radiance = GetMaterialEmissive(PixelMaterialInputs);
	Payload.BaseColor = BaseColor;
	Payload.Specular = Specular;
	Payload.Roughness = Roughness;
	Payload.Metallic = Metallic;
	Payload.Ior = Refraction.x;
	//Payload.Opacity = Opacity;

// #if MATERIAL_SHADINGMODEL_UNLIT
	// Payload.ShadingModelID = SHADINGMODELID_UNLIT;
// #else
	// Payload.ShadingModelID = SHADINGMODELID_DEFAULT_LIT;
	// // TODO - support other ShadingModelIDs in path tracer
// #endif

	// TODO - support different blending modes in path tracer?
	// uint MaterialBlendingMode = 0;
// #if MATERIALBLENDING_ALPHACOMPOSITE
	// MaterialBlendingMode = RT_MATERIAL_BLEND_MODE_ALPHA_COMPOSITE;
// #elif MATERIALBLENDING_TRANSLUCENT
	// MaterialBlendingMode = RT_MATERIAL_BLEND_MODE_TRANSLUCENT;
// #elif MATERIALBLENDING_ADDITIVE
	// MaterialBlendingMode = RT_MATERIAL_BLEND_MODE_ADDITIVE;
// #elif MATERIALBLENDING_MODULATE
	// MaterialBlendingMode = RT_MATERIAL_BLEND_MODE_MODULATE;
// #endif
	// Payload.BlendingMode = MaterialBlendingMode;

	Payload.HitT = RayTCurrent();
#if !MATERIAL_TWOSIDED
    Payload.HitKind = HitKind();
#else
    Payload.HitKind = HIT_KIND_TRIANGLE_FRONT_FACE;
#endif

	float3 DiffuseIndirectLighting = 0;
	float3 SubsurfaceIndirectLighting;
	float IndirectIrradiance = 0;
	
	float3 VolumetricLightmapBrickTextureUVs;
	
#if PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
	VolumetricLightmapBrickTextureUVs = ComputeVolumetricLightmapBrickTextureUVs(MaterialParameters.AbsoluteWorldPosition);
#endif
	GetPrecomputedIndirectLightingAndSkyLight(MaterialParameters, Interpolants, Payload.WorldNormal, VolumetricLightmapBrickTextureUVs, DiffuseIndirectLighting, SubsurfaceIndirectLighting, IndirectIrradiance);
	
	Payload.DiffuseColor = BaseColor - BaseColor * Metallic;
	Payload.SpecularColor = lerp(0.08 * Specular.xxx, BaseColor, Metallic);

	PackedPayload = PackRayTracingPayload(Payload);
}

[shader("anyhit")] 
void MaterialAHS(inout FPackedMaterialClosestHitPayload PackedPayload, in FDefaultAttributes Attributes)
{
#if MATERIALBLENDING_MASKED
	ResolvedView = ResolveView();

	FVertexFactoryInterpolantsVSToPS Interpolants;
	float4 SvPosition;
	
	CalcInterpolants(Attributes, Interpolants, SvPosition);

	FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(Interpolants, SvPosition);
	FPixelMaterialInputs PixelMaterialInputs;

	{
		float4 ScreenPosition = SvPositionToResolvedScreenPosition(SvPosition);
		float3 TranslatedWorldPosition = WorldRayOrigin() + WorldRayDirection() * RayTCurrent() + ResolvedView.PreViewTranslation.xyz;
		
		bool bIsFrontFace = HitKind() == HIT_KIND_TRIANGLE_FRONT_FACE;

		MaterialParameters.CameraVector = -WorldRayDirection();
		
		// #dxr_todo: support world position offset at some point
		// #if USE_WORLD_POSITION_EXCLUDING_SHADER_OFFSETS
		// CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, SvPosition, ScreenPosition, bIsFrontFace, TranslatedWorldPosition, BasePassInterpolants.PixelPositionExcludingWPO);
		// #else
		CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, SvPosition, ScreenPosition, bIsFrontFace, TranslatedWorldPosition, TranslatedWorldPosition);
		// #endif
	}

	if (GetMaterialMask(PixelMaterialInputs) < 0)
	{
		IgnoreHit();
	}
	else
	{
		// Continue traversal by simply returning from this shader
		return;
	}
#endif
}  
