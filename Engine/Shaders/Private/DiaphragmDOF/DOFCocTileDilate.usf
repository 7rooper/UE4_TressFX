// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	DiaphragmDOF/DOFCocDilate.usf: Dilate the coc tile buffer.
=============================================================================*/

#include "DOFCommon.ush"
#include "DOFCocTileCommon.ush"


//------------------------------------------------------- ENUM VALUES

/** Matches FRCPassDiaphragmDOFDilateCoc::EMode. */
	#define DILATE_MODE_STANDALONE 0
	#define GATHER_MODE_MIN_MAX 1
	#define GATHER_MODE_MIN_ABS 2


//------------------------------------------------------- PASSES.

uint SampleOffsetMultipler = 1;

// Multiplier to compare CocRadius and bucket distance.
float CocRadiusToBucketDistance;


//------------------------------------------------------- OUTPUTS.

RWTexture2D<float4>	Output0;
RWTexture2D<float4>	Output1;


//------------------------------------------------------- ENTRY POINT.

// TODO: could support larger radius with LDS.
[numthreads(DEFAULT_GROUP_BORDER_SIZE, DEFAULT_GROUP_BORDER_SIZE, 1)]
void CocDilateMainCS(uint2 DispatchThreadId : SV_DispatchThreadID) 
{
	const uint CocTileLayout = COC_TILE_LAYOUT_FGD_SEP_BGD;
	const int Radius = DIM_DILATE_RADIUS;

	const uint2 PixelPos = DispatchThreadId;

	// Different buckets of CocRadius per gathering radius.
	FCocTileSample OutSampleBuckets[Radius];

	// Whether OutSampleBuckets[BucketId] has been initialized. Going to be compile
	// out at runtime tahnks to the UNROLL over x and y variables.
	bool OutSampleBucketsisInitialized[Radius];
	UNROLL
	for (int j = 0; j < Radius; j++)
	{
		OutSampleBucketsisInitialized[j] = false;
	}

	// Standalone does not have any radius multiplier since there is only one dilate pass.
	#if DIM_DILATE_MODE == DILATE_MODE_STANDALONE
		const uint RadiusMultiplier = 1;
	#else
		const uint RadiusMultiplier = SampleOffsetMultipler;
	#endif

	// Iterate over all input tiles and assign them into their buckets.
	UNROLL
	for (int x = -Radius; x <= Radius; x++)
	{
		UNROLL
		for (int y = -Radius; y <= Radius; y++)
		{
			// Don't sampling the center as we do this latter on.
			if ( x == 0 && y == 0 )
				continue;
	
			// Id of the bucket to dilate this sample into.
			const uint BucketId = uint(max(abs(x), abs(y)) - 1);
		
			int2 Offset = asint(RadiusMultiplier) * int2(x, y);
			int2 SampleIndex = PixelPos + Offset;
			
			// If sampling outside the tiles, ignore this sample.
			bool2 bInsideViewport = SampleIndex >= 0 && uint2(SampleIndex) < uint2(ViewportRect.zw);
			if (!all(bInsideViewport))
				continue;
			
			// Minimal CoC radius to consider because done at full res.
			const float MinimalCoC = 0.5 * kCocRadiusToFullResFactor;

			// Closest distance from sampling tile to output tile.
			float ClosestDistance = COC_TILE_SIZE * length(max(abs(float2(Offset)) - 1.0, 0.0)) + MinimalCoC;

			// Sample tile.
			const FCocTileSample NeightborSample = LoadCocTile(CocTileLayout, PostprocessInput0, PostprocessInput1, SampleIndex);

			if (OutSampleBucketsisInitialized[BucketId] == false)
			{
				OutSampleBucketsisInitialized[BucketId] = true;
				OutSampleBuckets[BucketId] = NeightborSample;
			}
			else
			{
				OutSampleBuckets[BucketId].FgdMinCoc = min(
					OutSampleBuckets[BucketId].FgdMinCoc,
					NeightborSample.FgdMinCoc);

				OutSampleBuckets[BucketId].FgdMaxCoc = max(
					OutSampleBuckets[BucketId].FgdMaxCoc,
					NeightborSample.FgdMaxCoc);

				OutSampleBuckets[BucketId].BgdMinCoc = min(
					OutSampleBuckets[BucketId].BgdMinCoc,
					NeightborSample.BgdMinCoc);

				OutSampleBuckets[BucketId].BgdMaxCoc = max(
					OutSampleBuckets[BucketId].BgdMaxCoc,
					NeightborSample.BgdMaxCoc);
					
				OutSampleBuckets[BucketId].BgdMinIntersectableCoc = min(
					OutSampleBuckets[BucketId].BgdMinIntersectableCoc,
					NeightborSample.BgdMinIntersectableCoc);
			}
		}
	}
	
	// Sample the center bucket.
	FCocTileSample OutSample = LoadCocTile(CocTileLayout, PostprocessInput0, PostprocessInput1, PixelPos);

	{
		int k;
	
		// Find out what the maximum absolute Coc radii will be for the output sample.
		UNROLL
		for (k = 0; k < Radius; k++)
		{
			float BucketDistance = (float(RadiusMultiplier) * float(k + 1) - 1.0) * 8.0;
			
			FLATTEN
			if (-OutSampleBuckets[k].FgdMinCoc * CocRadiusToBucketDistance > BucketDistance)
			{
				OutSample.FgdMinCoc = min(OutSample.FgdMinCoc, OutSampleBuckets[k].FgdMinCoc);
			}
			
			FLATTEN
			if (OutSampleBuckets[k].BgdMaxCoc * CocRadiusToBucketDistance > BucketDistance)
			{
				OutSample.BgdMaxCoc = max(OutSample.BgdMaxCoc, OutSampleBuckets[k].BgdMaxCoc);
			}
		}
		
		// Fetches the already dilated min foreground and max background COC radius.
		#if DIM_DILATE_MODE == GATHER_MODE_MIN_ABS
		{
			FCocTileSample DilatedMinMaxSample = LoadCocTile(CocTileLayout, PostprocessInput2, PostprocessInput3, PixelPos);

			OutSample.FgdMinCoc = DilatedMinMaxSample.FgdMinCoc;
			OutSample.BgdMaxCoc = DilatedMinMaxSample.BgdMaxCoc;
		}
		#endif

		const float CocRadiusErrorFraction = 0.05;
		float ForegroundCocRadiusError = -OutSample.FgdMinCoc * CocRadiusErrorFraction;
		float BackgroundCocRadiusError = OutSample.BgdMaxCoc * CocRadiusErrorFraction;


		// Then, find out what is minimum absolute Coc radii that will be intersected for these maximum Coc radii.
		UNROLL
		for (k = 0; k < Radius; k++)
		{
			float BucketDistance = (float(RadiusMultiplier) * float(k + 1) - 1.0) * float(COC_TILE_SIZE);
			
			const float MinimalCoC = 0.5 * kCocRadiusToFullResFactor;
			float MaxIntersectableAbsCocRadius = COC_TILE_SIZE * (float(RadiusMultiplier * (k + 1)) - 1) + MinimalCoC;
			
			FLATTEN
			if (-OutSample.FgdMinCoc * CocRadiusToBucketDistance > BucketDistance)
			{
				OutSample.FgdMaxCoc = max(OutSample.FgdMaxCoc, OutSampleBuckets[k].FgdMaxCoc);
			}

			FLATTEN
			if (OutSample.BgdMaxCoc * CocRadiusToBucketDistance > BucketDistance)
			{
				OutSample.BgdMinCoc = min(OutSample.BgdMinCoc, OutSampleBuckets[k].BgdMinCoc);
				OutSample.BgdMinIntersectableCoc = min(OutSample.BgdMinIntersectableCoc, max(OutSampleBuckets[k].BgdMinIntersectableCoc, MaxIntersectableAbsCocRadius));
			}
		}
	}

	// If dilating min foreground and max background coc, zero output other to prune the unecessary ALU.
	#if DIM_DILATE_MODE == GATHER_MODE_MIN_MAX
	{
		OutSample.FgdMaxCoc = 0;
		OutSample.BgdMinCoc = 0;
		OutSample.BgdMinIntersectableCoc = 0;
	}
	#endif

	// Output that.
	if (all(PixelPos < ViewportRect.zw))
	{
		float4 RawOutput[COC_TILE_MAX_BUFFER_COUNT];
		EncodeCocTileSample(OutSample, CocTileLayout, RawOutput);

		Output0[PixelPos] = RawOutput[0];
		if (static_condition(GetBufferCountForCocTileLayour(CocTileLayout) > 1))
		{
			Output1[PixelPos] = RawOutput[1];
		}
	}
}
