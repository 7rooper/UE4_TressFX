// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	PostProcessHistogram.usf: PostProcessing histogram
=============================================================================*/

#include "Common.ush"
#include "PostProcessCommon.ush"
#include "PostProcessHistogramCommon.ush"

// xy:GatherExtent, zw : unused
float4 HistogramParameters;

// Output histogram texture (UAV)
RWTexture2D<uint> RWHistogramTexture;

//
uint2 ThreadGroupCount;
//
uint2 LeftTopOffset;

// One shared histogram for all threads in group
static const uint HistogramPadding = 4;	// AMD/Nvidia = 32 banks, Intel = 16 banks.
static const uint HistogramOffset = HISTOGRAM_SIZE + HistogramPadding;
groupshared uint SharedHistograms[HISTOGRAM_SIZE * 4 + HistogramPadding * 3];



[numthreads(64, 1, 1)]	
void ClearHistogramCS(uint GroupIndex: SV_GroupIndex)
{
	if(GroupIndex < HISTOGRAM_SIZE)
	{
		RWHistogramTexture[uint2(GroupIndex, 0)] = 0;
	}
}

[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]	// dimx,dimy,dimz
void MainCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,	// DispatchThreadId = GroupId * int2(dimx,dimy) + GroupThreadId
    	uint3 GroupThreadId : SV_GroupThreadID,			// 0..THREADGROUP_SIZEX 0..THREADGROUP_SIZEY
	uint GroupIndex: SV_GroupIndex)					// SV_GroupIndex = SV_GroupThreadID.z*dimx*dimy + SV_GroupThreadID.y*dimx + SV_GroupThreadID.x
{
	// Clear the shared histogram in one go. Use all 256 threads to clear 4x 64 bin histograms.
	// IMPORTANT: Group size must be 16x16 = 256
	{
		uint Index = (GroupIndex % 64) + HistogramOffset * (GroupIndex / 64);
		SharedHistograms[Index] = 0;
	}
	 
    GroupMemoryBarrierWithGroupSync();

	uint2 TileSize = uint2(LOOP_SIZEX, LOOP_SIZEY);
	uint2 LeftTop = GroupId.xy * uint2(THREADGROUP_SIZEX * LOOP_SIZEX, THREADGROUP_SIZEY * LOOP_SIZEY) + GroupThreadId.xy + LeftTopOffset;
	uint2 GatherExtentInt = (uint2)HistogramParameters.xy + (uint2)LeftTopOffset.xy;

	{
		UNROLL for(uint y = 0; y < LOOP_SIZEY; ++y)
		{
			UNROLL for(uint x = 0; x < LOOP_SIZEX; ++x)
			{
				uint2 Tile = uint2(x, y) * uint2(THREADGROUP_SIZEX, THREADGROUP_SIZEY);
				uint2 TexelPos = LeftTop + Tile;

				if(TexelPos.x < GatherExtentInt.x && TexelPos.y < GatherExtentInt.y)
				{
					float4 SceneColor = PostprocessInput0.Load(int3(TexelPos, 0));
	#if USE_PREEXPOSURE
					SceneColor.xyz *= View.OneOverPreExposure;
	#endif
					float LuminanceVal = max(SceneColor.r, max(SceneColor.g, SceneColor.b));
					float LogLuminance = ComputeHistogramPositionFromLuminance(LuminanceVal);
			
					float fBucket = saturate(LogLuminance) * (HISTOGRAM_SIZE - 1) * 0.9999f;

					uint Bucket0 = (uint)(fBucket);
					uint Bucket1 = Bucket0 + 1;

					float Weight1 = frac(fBucket);
					float Weight0 = 1.0f - Weight1;
			
					// accumulate the weight to the nearby history buckets
					// NOTE: Pack "overflow" to next bucket to same counter high bits. This halves the number of atomics. 
					uint PackedHistogram = (uint(Weight1 * 64.0) << 16) | uint(Weight0 * 64.0);
                   			uint Offset = HistogramOffset * (GroupIndex % 4);
					InterlockedAdd(SharedHistograms[Bucket0 + Offset], PackedHistogram);
				}
			}
		}
	}

    GroupMemoryBarrierWithGroupSync();

	[branch]
	if(GroupIndex < HISTOGRAM_SIZE)
	{
		uint Sum = 0;

		[flatten]
		if (GroupIndex > 0)	// UE comment: good hack to prevent adapting to extreme darks
		{
			// Sum low+high bit histograms for each 4 histograms.
			Sum = SharedHistograms[GroupIndex     + HistogramOffset * 0] + SharedHistograms[GroupIndex     + HistogramOffset * 1] + SharedHistograms[GroupIndex     + HistogramOffset * 2] + SharedHistograms[GroupIndex     + HistogramOffset * 3] + 
				((SharedHistograms[GroupIndex - 1 + HistogramOffset * 0] + SharedHistograms[GroupIndex - 1 + HistogramOffset * 1] + SharedHistograms[GroupIndex - 1 + HistogramOffset * 2] + SharedHistograms[GroupIndex - 1 + HistogramOffset * 3]) >> 16);

			Sum = Sum & 0x0000ffff;
		}

		// Accumulate groups to shared histogram
		InterlockedAdd(RWHistogramTexture[uint2(GroupIndex, 0)], Sum);
	}
}
