
#include "Common.ush"
#include "TressFXCommon.ush"
#include "/Engine/Generated/Material.ush"
#include "/Engine/Generated/VertexFactory.ush"

struct FTressFXPPLLBuildVSOutput
{
    FVertexFactoryInterpolantsVSToPS FactoryInterpolants;
    float4 Position : SV_Position;
};


void Build_MainVS(
	FVertexFactoryInput Input,
	out FTressFXPPLLBuildVSOutput Output
#if USE_GLOBAL_CLIP_PLANE && !USING_TESSELLATION
	, out float OutGlobalClipPlaneDistance : SV_ClipDistance
#endif
#if INSTANCED_STEREO
	, uint InstanceId : SV_InstanceID
#if !MULTI_VIEW
		, out float OutClipDistance : SV_ClipDistance1
#else
		, out uint ViewportIndex : SV_ViewPortArrayIndex
#endif
#endif
	)
{
#if INSTANCED_STEREO
	uint EyeIndex;
	BRANCH
	if (bIsInstancedStereoEmulated)
	{
		EyeIndex = View.StereoPassIndex;
	}
	else
	{
		EyeIndex = VertexFactoryGetEyeIndex(InstanceId);
	}

	ResolvedView = ResolveView(EyeIndex);
#if !MULTI_VIEW
		OutClipDistance = 0.0;
#else
		ViewportIndex = EyeIndex;
#endif
#else
    ResolvedView = ResolveView();
#endif

    FVertexFactoryIntermediates VFIntermediates = GetVertexFactoryIntermediates(Input);
    float4 WorldPos = VertexFactoryGetWorldPosition(Input, VFIntermediates);

    float3x3 TangentToLocal = VertexFactoryGetTangentToLocal(Input, VFIntermediates);
    FMaterialVertexParameters VertexParameters = GetMaterialVertexParameters(Input, VFIntermediates, WorldPos.xyz, TangentToLocal);

	// Isolate instructions used for world position offset
	// As these cause the optimizer to generate different position calculating instructions in each pass, resulting in self-z-fighting.
	// This is only necessary for shaders used in passes that have depth testing enabled.
    ISOLATE
	{
        WorldPos.xyz += GetMaterialWorldPositionOffset(VertexParameters);
    }

    ISOLATE
	{
        float4 RasterizedWorldPosition = VertexFactoryGetRasterizedWorldPosition(Input, VFIntermediates, WorldPos);
        Output.Position = mul(RasterizedWorldPosition, ResolvedView.TranslatedWorldToClip);
    }

    Output.FactoryInterpolants = VertexFactoryGetInterpolantsVSToPS(Input, VFIntermediates, VertexParameters);
    OutputVertexID(Output);

}


#if ERROR_CHECK
#define ASSERT(x) if(!(x)) RETURN_ERROR
#else
#define ASSERT(x) 
#endif


struct PPLL_STRUCT
{
    uint depth;
    uint data;
    uint color;
    uint Gbuffer;
    uint uNext;
};

#ifndef FRAGMENT_LIST_NULL
#define FRAGMENT_LIST_NULL 0xffffffff
#endif

#define HAS_COLOR 1

RWTexture2D<uint> tRWFragmentListHead : register(u1);

RWStructuredBuffer<PPLL_STRUCT> LinkedListUAV : register(u2);

int nNodePoolSize;

uint PackFloat4IntoUint(float4 vValue)
{
    return (((uint) (vValue.x * 255)) << 24) | (((uint) (vValue.y * 255)) << 16) | (((uint) (vValue.z * 255)) << 8) | (uint) (vValue.w * 255);
}

// Allocate a new fragment location in fragment color, depth, and link buffers
int AllocateFragment(int2 vScreenAddress)
{
    int newAddress = LinkedListUAV.IncrementCounter();
    if (newAddress <= 0 || newAddress > nNodePoolSize)
        newAddress = FRAGMENT_LIST_NULL;
    return newAddress;
}

// Insert a new fragment at the head of the list. The old list head becomes the
// the second fragment in the list and so on. Return the address of the *old* head.
int MakeFragmentLink(int2 vScreenAddress, int nNewHeadAddress)
{
    int nOldHeadAddress;

    InterlockedExchange(tRWFragmentListHead[vScreenAddress], nNewHeadAddress, nOldHeadAddress);

    return nOldHeadAddress;
}


// Write fragment attributes to list location. 
void WriteFragmentAttributes(int nAddress, int nPreviousLink, float4 vData, float3 vColor3, float fDepth, float4 GBufferData)
{
    PPLL_STRUCT element;
    element.data = PackFloat4IntoUint(vData);
    element.color = PackFloat4IntoUint(float4(vColor3, 0));
    element.depth = asuint(saturate(fDepth));
    element.Gbuffer = PackFloat4IntoUint(GBufferData);
    element.uNext = nPreviousLink;
    LinkedListUAV[nAddress] = element;
}

float3 ScreenToNDC(float3 vScreenPos, float4 viewport)
{
    float2 xy = vScreenPos.xy;

	// add viewport offset.
    xy += viewport.xy;

	// scale by viewport to put in 0 to 1
    xy /= viewport.zw;

	// shift and scale to put in -1 to 1. y is also being flipped.
    xy.x = (2 * xy.x) - 1;
    xy.y = 1 - (2 * xy.y);

    return float3(xy, vScreenPos.z);

}

float3 NDCToWorld(float3 vNDC, float4x4 mInvViewProj)
{
    float4 pos = mul(float4(vNDC, 1), mInvViewProj);

    return pos.xyz / pos.w;
}


struct PS_INPUT_HAIR_AA
{
    FVertexFactoryInterpolantsVSToPS FactoryInterpolants;
    float4 Position : SV_POSITION;
};

//--------------------------------------------------------------------------------------
// ComputeCoverage
//
// Calculate the pixel coverage of a hair strand by computing the hair width
//--------------------------------------------------------------------------------------
float ComputeCoverage(float2 p1, float2 p0, float2 pixelLoc, float2 winSize)
{
    // p0, p1, pixelLoc are in d3d clip space (-1 to 1)x(-1 to 1)

    // Scale positions so 1.f = half pixel width
    p0 *= winSize;
    p1 *= winSize;
    pixelLoc *= winSize;

    float p0dist = length(p0 - pixelLoc);
    float p1dist = length(p1 - pixelLoc);
    float hairWidth = length(p0 - p1);

    // will be 1.f if pixel outside hair, 0.f if pixel inside hair
    float outside = any(float2(step(hairWidth, p0dist), step(hairWidth, p1dist)));

    // if outside, set sign to -1, else set sign to 1
    float sign = outside > 0.f ? -1.f : 1.f;

    // signed distance (positive if inside hair, negative if outside hair)
    float relDist = sign * saturate(min(p0dist, p1dist));

    // returns coverage based on the relative distance
    // 0, if completely outside hair edge
    // 1, if completely inside hair edge
    return (relDist + 1.f) * 0.5f;
}

//#include "../DeferredShadingCommon.ush"

#ifndef OPTIONAL_IsFrontFace
#define OPTIONAL_IsFrontFace
#endif

float3 SvPositionToNDCPos(float4 SvPosition)
{
	// todo: is already in .w or needs to be reconstructed like this:
	//	SvPosition.w = ConvertFromDeviceZ(SvPosition.z);

    float2 PixelPos = SvPosition.xy - View.ViewRectMin.xy;

	// NDC (NormalizedDeviceCoordinates, after the perspective divide)
    return float3((PixelPos * View.ViewSizeAndInvSize.zw - 0.5f) * float2(2, -2), SvPosition.z);

}


[earlydepthstencil]
float4 Build_MainPS(PS_INPUT_HAIR_AA input OPTIONAL_IsFrontFace) : SV_Target0
{
    float4 viewport = float4(View.ViewRectMin.xy, View.ViewSizeAndInvSize.xy);
    float3 vNDC = ScreenToNDC(input.Position.xyz, viewport);
    float3 vPositionWS = NDCToWorld(vNDC, View.ClipToTranslatedWorld);


    float coverage = ComputeCoverage(input.FactoryInterpolants.p0p1.xy, input.FactoryInterpolants.p0p1.zw, vNDC.xy, View.ViewSizeAndInvSize.xy);
    float alpha = coverage * g_MatBaseColor.a;


	//return float4(1, coverage, alpha, g_MatBaseColor.a);
	//ASSERT(coverage >= 0)
    if (alpha < 0.02)
        return float4(0, 0, 0, 0);



    FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(input.FactoryInterpolants, input.Position);
    FPixelMaterialInputs PixelMaterialInputs;

#if USE_WORLD_POSITION_EXCLUDING_SHADER_OFFSETS
	{
			float4 ScreenPosition = SvPositionToResolvedScreenPosition(input.Position);
			float3 TranslatedWorldPosition = SvPositionToResolvedTranslatedWorld(input.Position);
			CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, input.Position, ScreenPosition, bIsFrontFace, TranslatedWorldPosition, BasePassInterpolants.PixelPositionExcludingWPO);
	}
#else
	{
        float4 ScreenPosition = SvPositionToResolvedScreenPosition(input.Position);
        float3 TranslatedWorldPosition = SvPositionToResolvedTranslatedWorld(input.Position);
        CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, input.Position, ScreenPosition, bIsFrontFace, TranslatedWorldPosition, TranslatedWorldPosition);
    }
#endif

    half3 BaseColor = GetMaterialBaseColor(PixelMaterialInputs);
    half Spec = GetMaterialSpecular(PixelMaterialInputs);
    half Metallic = GetMaterialMetallic(PixelMaterialInputs);
    half Roughness = GetMaterialRoughness(PixelMaterialInputs);

    float4 GBufferData = float4(Spec, Metallic, Roughness, 0);

    int2 vScreenAddress = int2(input.Position.xy);
	// Allocate a new fragment
    int nNewFragmentAddress = AllocateFragment(vScreenAddress);
	
	ASSERT(nNewFragmentAddress != FRAGMENT_LIST_NULL);
    int nOldFragmentAddress = MakeFragmentLink(vScreenAddress, nNewFragmentAddress);
    WriteFragmentAttributes(nNewFragmentAddress, nOldFragmentAddress, float4(input.FactoryInterpolants.Tangent.xyz * 0.5 + float3(0.5, 0.5, 0.5), alpha), BaseColor, input.Position.z, GBufferData);
	//ShadingModleOut.a = EncodeShadingModelIdAndSelectiveOutputMask(SHADINGMODELID_HAIR,0);
	//GBufferA.rgb = EncodeNormal( input.FactoryInterpolants.Tangent.xyz ); 
	
    return float4(0, 0, 0, 0);

}


