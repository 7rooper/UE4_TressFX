//
// Copyright (c) 2017 Advanced Micro Devices, Inc. All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

//Unreal Engin 4 integration written by Leon Rosengarten 2017
#pragma once
#include "Common.ush"
/*
#include "TressFXRendering.ush"

float fLightScale;

float3 AccumulateHairLight(float3 vTangent, float3 vPositionWS, float3 vViewWS, HairShadeParams params, float fExtraAmbientScale = 1)
{

	// Light update system only counts lights that affect this object.
	int lightCount = nNumLights; 

	float3 color = float3(0,0,0);
	float3 V = normalize(vViewWS);
	float3 T = normalize(vTangent);

	for(int i=0; i < lightCount; ++i)
	{
		// volume lights will be treated as omni-directional.
		if( SuIsVolume( i ) )
		{
			color += SuComputeVolumeAmbient( vPositionWS, i );
		}
		else
		{
			float3 vLightDirWS, cLightColor;
			SuGetLightLocal( vPositionWS, i,  vLightDirWS, cLightColor);

			int nLightID = nLightIndex[i]; // global ID used for shadows.

			// yes, I know this seems weird - but it's basically a way to control
			// spec vs diffuse through the light.
			float lightEmitsDiffuse = vLightParams[i].z;
			float lightEmitsSpecular =  vLightParams[i].w;

			// if we get zero, we can save the BRDF eval, which is costly.
			float fShadowTerm = ComputeLightShadow( nLightID, vPositionWS);

			if(fShadowTerm > 0.00001 )
			{
				float3 L = normalize(vLightDirWS);

				float3  reflection = TressFX_ComputeDiffuseSpecFactors(V, L, T);

				float3 cReflectedLight = reflection.x * cLightColor * lightEmitsDiffuse * params.cColor;
				cReflectedLight += reflection.y * cLightColor * lightEmitsSpecular;
				cReflectedLight += reflection.z * cLightColor * lightEmitsSpecular * params.cColor;
				cReflectedLight *= fShadowTerm * fLightScale;// * 0.16;

				color += max( float3(0,0,0), cReflectedLight);

			}
		}
	}

	return color;

}

float3 ScreenToNDC(float3 vScreenPos, float4 viewport)
{
	float2 xy = vScreenPos.xy;

	// add viewport offset.
	xy += viewport.xy;

	// scale by viewport to put in 0 to 1
	xy /= viewport.zw;

	// shift and scale to put in -1 to 1. y is also being flipped.
	xy.x = (2 * xy.x) - 1;
	xy.y = 1 - (2 * xy.y);

	return float3(xy, vScreenPos.z);

}

float3 NDCToWorld(float3 vNDC, float4x4 mInvViewProj)
{
	float4 pos = mul(mInvViewProj, float4(vNDC, 1));

	return pos.xyz / pos.w;
}


// viewport.xy = offset, viewport.zw = size
float3 GetWorldPos(float4 vScreenPos, float4 viewport, float4x4 invViewProj)
{
	float2 xy = vScreenPos.xy;

	// add viewport offset.
	xy += viewport.xy;

	// scale by viewport to put in 0 to 1
	xy /= viewport.zw;

	// shift and scale to put in -1 to 1. y is also being flipped.
	xy.x = (2 * xy.x) + 1;
	xy.y = 1 - (2 * xy.y);

	float4 pos = mul(invViewProj, float4(xy.x, xy.y, vScreenPos.z, 1));
	//float4 pos = float4(xy.x, xy.y, 1, 1);
	//pos *= sv_pos.w;

	return pos.xyz / pos.w;
}


float4 ComputeSushiRGBA(float2 pixelCoord, float depth, float4 vTangentCoverage, float3 baseColor)
{
	float4 viewport = float4(View.ViewRectMin.xy,View.ViewSizeAndInvSize.xy);
	float3 vTangent = 2.0 * vTangentCoverage.xzy - 1.0;
	float3 vNDC = ScreenToNDC(float3(pixelCoord, depth), viewport);
	float3 vPositionWS = NDCToWorld(vNDC, View.ScreenToWorld);
	float3 vViewWS = View.WorldCameraOrigin.xzy - vPositionWS;

	// TODO remove params, since we are using globals anyways.
	HairShadeParams params;

	params.cColor = baseColor;
	params.fRadius = g_FiberRadius;
	params.fSpacing = g_FiberSpacing;
	params.fAlpha = g_HairShadowAlpha;

	float3 color = AccumulateHairLight(vTangent, vPositionWS, vViewWS, params);
	return float4(color, vTangentCoverage.w);
}

*/
//#define HEAD_SHADING ComputeSushiRGBA
//#define TAIL_SHADING ComputeSushiRGBA
			
#include "TressFXPPLL.ush"


void ResolveLinkedListPS(
	FScreenVertexOutput Input,
	out float4 OutColor : SV_Target0
	)
{
    OutColor = (float4) 0;
    OutColor = GatherLinkedList(Input.Position.xy);
}
