/*

Pass 1:
	Render the hair depth from the point of view of the light.
		- We already have this thanks to per-object shadows, hopefully its high resolution enough in the Atlas.
		- this gives us the depth (z0) at which the hair geometry begins
Pass 2:
	Render the hair geometry again from the POV of the light, and build the opacity map as follows: (jake note, may be able to combine this with the depths-alpha shortcut pass eventually?)
	Starting from the z0 value, we divide the hair into k layers such that each layer lies from z0 + dk−1 to z0 +dk where d0 = 0, dk−1 < dk and 1 ≤ k ≤ K
		- example layer setup:
			layer 1:
				z0 + d1
			layer 2:
				z0 + d1 -> z0 + d2
			layer 3:
				z0 + d2 -> z0 + d3

			d1,d2,d3... are USER defined. dont have to be contant, can be fibonacci or whatevver, can be the same
			so parameter
			float Layer1Thickness; - d1
			float Layer2Thickness; - d2
					etc...

		opacity: will add param later, for now will use "OpacityPerFragment" define from below

		- in this case k=3, we use 4 component texture uav. r = depth, g = layer1, b = layer2, a = layer3 etc...
			- note, dont think i need to store depth in r, we have depth in the per object shadow tex, gives us another layer, 
				we can just calculate what layer we are in using layer thickness and if statements instead
		- by starting at z0, the opacity map layers take the shape of the mesh, unlike opacity shadow mapping
		
		from the paper:
		"The second step renders the opacity map using the depth
		map computed in the previous step. This requires rendering the hair only once and all computation occurs within the
		fragment shader. As each hair is rendered, we read the value
		of z0 from the depth map and find the depth values of the
		layers on the fly. We assign the opacity contribution of the
		fragment to the layer that the fragment falls in and to all the
		other layers behind it. The total opacity of a layer at a pixel
		is the sum of all contributing fragments."


		psuedocode: 

		FragDepth = In.Position.FragDepth
		SampledDepth = some float value, sampled from shadowdepth per object texture
		float4 OutDepth = 0;
		// JAKETODO note this might be backward since u are dyslexic and ue4 uses inverse-FragDepth
		// also i have no idea what good values for thickness will be. will require expermentation
		//
		if (FragDepth - Layer1Thickness < SampledDepth) 
		{
			OutDepth.g = OpacityPerFragment;
			OutDepth.b = OpacityPerFragment;
			OutDepth.a = OpacityPerFragment;
		}
		// layer 2
		else if (FragDepth - Layer1Thickness - Layer2Thickness < SampledDepth) 
		{
			OutDepth.g = 0;
			OutDepth.b = OpacityPerFragment;
			OutDepth.a = OpacityPerFragment;
		}
		// layer 3
		else 
		{
			OutDepth.g = 0;
			OutDepth.b = 0;
			OutDepth.a = OpacityPerFragment;
		}
		
		DeepOpacityMap[ScreenAddress].g += OutDepth.g;
		DeepOpacityMap[ScreenAddress].b += OutDepth.b;
		DeepOpacityMap[ScreenAddress].a += OutDepth.a;
		float oldMin;
		//store depth (z0) from POV of light in the r channel
		//again im dislexic this may be backwards on the first try :).
		InterLockedMin(DeepOpacityMap[ScreenAddress], SampledDepth , oldMin )

Pass 3: render the hair however you want and sample the opacity map for shadow
	https://github.com/ReubenWattenhofer/hair-renderer/blob/master/hair-renderer/Assets/Hair_Renderer/Shaders/basic-hair.shader
	pseudocode for sample, not sure if correct. probably not, came from above. but is definitely backwards since ue4 uses inverse z
	float opacity = 0;
	float3 opacity_rgb = float3(0,0,0);
	float4 OpacityMapValue = sample the opacity map at coords
	float SampledDepth = OpacityMapValue.r; aka z0, 

	if (FragDepth - Layer1Thickness < SampledDepth)
	{
		opacity = lerp(0, OpacityMapValue.g, (FragDepth - SampledDepth) / Layer1Thickness);
		opacity_rgb.r = lerp(0, OpacityMapValue.g, (FragDepth - SampledDepth) / Layer1Thickness);
	}
	else if (FragDepth - Layer1Thickness - Layer2Thickness < SampledDepth) 
	{
		opacity = lerp(OpacityMapValue.g, OpacityMapValue.b, (FragDepth - Layer1Thickness - SampledDepth) / Layer2Thickness);
		float prevMax = OpacityMapValue.g;
		opacity_rgb.g = lerp(0, OpacityMapValue.b, (FragDepth - Layer1Thickness - SampledDepth) / Layer2Thickness);
		opacity_rgb.r = lerp(prevMax, 0, (FragDepth - Layer1Thickness - SampledDepth) / Layer2Thickness);
	}
	else
	{
		opacity = lerp(OpacityMapValue.b, OpacityMapValue.a, (FragDepth - Layer1Thickness - Layer2Thickness - SampledDepth) / Layer3Thickness);
		float prevMax = OpacityMapValue.b;
		opacity_rgb.b = lerp(0, OpacityMapValue.a, (FragDepth - Layer1Thickness - Layer2Thickness - SampledDepth) / Layer3Thickness);
		opacity_rgb.g = lerp(prevMax, 0, (FragDepth - Layer1Thickness - Layer2Thickness - SampledDepth) / Layer3Thickness);
	}

	opacity = max(0, opacity);
	opacity_rgb = lerp(opacity, opacity_rgb, _OpacityRGB);
	//how to use this value now to generate shadow?

*/


#pragma once

#define SceneTexturesStruct TressFXDeepOpacityPass.SceneTextures 

#include "/Engine/Generated/Material.ush"
#include "/Engine/Generated/VertexFactory.ush"

#include "TressFXRendering.ush"
#include "ShadowDepthCommon.ush"
#include "ShadowFilteringCommon.ush"

#define ShadowDepthTexture TressFXDeepOpacityBuffer.ShadowDepthTexture
# define ShadowDepthTextureSampler TressFXDeepOpacityBuffer.ShadowDepthTextureSampler
// xy:unused, z:SoftTransitionScale
#define SoftTransitionScale TressFXDeepOpacityBuffer.SoftTransitionScale.z
// xy:ShadowTexelSize.xy, zw:1/ShadowTexelSize.xy
#define ShadowBufferSize TressFXDeepOpacityBuffer.ShadowBufferSize

#ifndef OPTIONAL_IsFrontFace
	#define OPTIONAL_IsFrontFace
#endif

#define OpacityPerFragment .01f

//i have no idea what good values for thickness will be. will require expermentation
#define Layer1Thickness .01f
#define Layer2Thickness .01f
#define Layer3Thickness .01f
#define Layer4Thickness .01f

//EARLYDEPTHSTENCIL
void Main(FShadowDepthVSToPS Inputs, in float4 SvPosition : SV_Position, out float4 DeepOpacity : SV_Target0)
{
    
	float FragDepth = SvPosition.z;
    int2 ScreenAddress = int2(SvPosition.xy);
    FPCFSamplerSettings Settings;
    Settings.ShadowDepthTexture = ShadowDepthTexture;
    Settings.ShadowDepthTextureSampler = ShadowDepthTextureSampler;
    Settings.ShadowBufferSize = ShadowBufferSize;
    Settings.TransitionScale = SoftTransitionScale.z;
    Settings.SceneDepth = FragDepth;
    Settings.bSubsurface = false;
    Settings.bTreatMaxDepthUnshadowed = false;
    Settings.DensityMulConstant = 0;
    Settings.ProjectionDepthBiasParameters = 0;
    float SampledDepth = ManualPCF(SvPosition.xy, Settings);
	
	float4 OutDepth = 0;

	// JAKETODO note this might be backward since u are dyslexic and ue4 uses inverse-z
	if (FragDepth - Layer1Thickness < SampledDepth) 
	{
		OutDepth.r = OpacityPerFragment;
		OutDepth.g = OpacityPerFragment;
		OutDepth.b = OpacityPerFragment;
        OutDepth.a = OpacityPerFragment;
    }
	// layer 2
	else if (FragDepth - Layer1Thickness - Layer2Thickness < SampledDepth) 
	{
		OutDepth.r = 0;
		OutDepth.g = OpacityPerFragment;
		OutDepth.b = OpacityPerFragment;
        OutDepth.a = OpacityPerFragment;
    }
	// layer 3
    else if (FragDepth - Layer1Thickness - Layer2Thickness - Layer3Thickness < SampledDepth) 
	{
		OutDepth.r = 0;
		OutDepth.g = 0;
		OutDepth.b = OpacityPerFragment;
        OutDepth.a = OpacityPerFragment;
    }
	//layer4
    else
    {
        OutDepth.r = 0;
        OutDepth.g = 0;
        OutDepth.b = 0;
        OutDepth.a = OpacityPerFragment;
    }
	
	//use additive blending
    DeepOpacity = OutDepth;

}