// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

#ifndef DIM_DENOISER_OUTPUT
	#define DIM_DENOISER_OUTPUT 0
#endif

#include "../Common.ush"

float2 SobolIndexToUniformUnitSquare(uint2 SobolRand)
{
	return float2(SobolRand) * rcp(65536.0) + rcp(65536.0 * 2.0);
}

#define SUPPORT_CONTACT_SHADOWS		0
#define USE_SOURCE_TEXTURE			0 //Used in RectLight.ush  //#dxr_todo: enable textures

#include "../DeferredShadingCommon.ush"
#include "../DeferredLightingCommon.ush"
#include "../ReflectionEnvironmentShared.ush"
#include "../Montecarlo.ush"
#include "../PathTracing/Utilities/PathTracingRandomSequence.ush" // #dxr-todo: move to a common folder
#include "../HeightFogCommon.ush"
#include "RayTracingCommon.ush"
#include "RayTracingHitGroupCommon.ush"

uint SamplesPerPixel;
uint MaxRefractionRays;
uint HeightFog;
uint ShouldDoDirectLighting;
uint ShouldDoReflectedShadows;
uint ShouldDoEmissiveAndIndirectLighting;
uint UpscaleFactor;

float TranslucencyMinRayDistance;
float TranslucencyMaxRayDistance;
float TranslucencyMaxRoughness;

RaytracingAccelerationStructure TLAS;

RWTexture2D<float4> ColorOutput;
RWTexture2D<float> RayHitDistanceOutput;

#include "RayTracingLightingCommon.ush"

// #dxr-todo: move to RayTracingCommon.ush
float GetHitT(FMaterialClosestHitPayload HitInfo)
{
	return HitInfo.HitT;
}

bool IsHit(RayDesc Ray, FMaterialClosestHitPayload HitInfo)
{
	float t = HitInfo.HitT;
	return t > Ray.TMin && t < Ray.TMax;
}

float3 ReconstructWorldPositionFromDepth(float2 UV, float Depth)
{
	float2 ScreenPosition = (UV - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;
	float4 HomogeneousWorldPosition = mul(float4(ScreenPosition * Depth, Depth, 1), View.ScreenToWorld);
	float3 WorldPosition = HomogeneousWorldPosition.xyz / HomogeneousWorldPosition.w;

	return WorldPosition;
}

uint2 GetPixelCoord(uint2 DispatchThreadId)
{
	uint UpscaleFactorPow2 = UpscaleFactor * UpscaleFactor;

	// TODO: find a way to not interfer with TAA's jittering.
	uint SubPixelId = View.StateFrameIndex & (UpscaleFactorPow2 - 1);

	return DispatchThreadId * UpscaleFactor + uint2(SubPixelId & (UpscaleFactor - 1), SubPixelId / UpscaleFactor);
}


bool RefractRay(float3 V, float3 N, float IorV, float IorL, out float3 L)
{
	float NoV = dot(V, N);
	float IorRatio = IorV / IorL;
	float d = 1.0 - IorRatio * IorRatio * (1.0 - NoV * NoV);

	if (d > 0.0)
	{
		L = N * (IorRatio*NoV - sqrt(d)) - V * IorRatio;
		return true;
	}

	// TIR, force to reflect
	L = N * (NoV + NoV) - V;
	return false;
}

[shader("raygeneration")]
void RayTracingTranslucencyRGS()
{
	uint2 DispatchThreadId = DispatchRaysIndex().xy;

	uint2 PixelCoord = GetPixelCoord(DispatchThreadId);
	
	uint LinearIndex = PixelCoord.y * View.BufferSizeAndInvSize.x + PixelCoord.x; // TODO: PixelCoord or DispatchThreadId
	
	RandomSequence RandSequence;
	RandomSequence_Initialize(RandSequence, LinearIndex, View.FrameNumber);

	float2 InvBufferSize = View.BufferSizeAndInvSize.zw;
	float2 UV = (float2(PixelCoord) + 0.5) * InvBufferSize;
	FScreenSpaceData ScreenSpaceData = GetScreenSpaceData(UV);
	float Depth = ScreenSpaceData.GBuffer.Depth;
	float3 CameraOrigin = ReconstructWorldPositionFromDepth(UV, 0.0f);
	float3 WorldPosition = ReconstructWorldPositionFromDepth(UV, Depth);
	float3 CameraDirection = normalize(WorldPosition - CameraOrigin);	
	const float GBufferHitT = length(WorldPosition - CameraOrigin);

	float3 TranslucencyColor = 0.0;
	float HitDistance = 0.0f;

	// Trace rays from camera origin to (Gbuffer - epsilon) to only intersect translucent objects
	//#dxr_todo: a potential big optimization would be to include translucent objects in the GBuffer
	// and use the GBuffer shading ID to early return for non translucent objects 
	RayDesc Ray;
	Ray.Origin = CameraOrigin;
	Ray.TMin = 0.0;
	Ray.TMax = GBufferHitT - 0.1;
	Ray.Direction = CameraDirection;

	FRayCone RayCone = (FRayCone)0;
	RayCone.SpreadAngle = View.EyeToPixelSpreadAngle;

	uint RayFlags = RAY_FLAG_CULL_BACK_FACING_TRIANGLES;

	for (uint RefractionRayIndex = 0; RefractionRayIndex < MaxRefractionRays; ++RefractionRayIndex)
	{
		FMaterialClosestHitPayload Payload = TraceRayInternal(
			TLAS,   // AccelerationStructure
			RayFlags,
			0xFF,   // InstanceInclusionMask
			0,      // RayContributionToHitGroupIndex
			1,      // MultiplierForGeometryContributionToShaderIndex #dxr_todo: we currently only support shader binding per mesh instance
			0,      // MissShaderIndex
			Ray,    // RayDesc
			RayCone
		);

		if (!IsHit(Ray, Payload))
		{
			//TranslucencyColor = float3(1, 0, 0);
			break;
		}

		//#dxr_todo: 
		//- set stack of refraction & reflection rays
		//- handle TIR
		//- Handle translucency throughput depending on color and opacity (beerÂ´s law)

		float3 HitPoint = Ray.Origin + Ray.Direction * GetHitT(Payload);

		// Trace reflection ray 
		uint DummyVariable;
		float2 RandSample = RandomSequence_GenerateSample2D(RandSequence, DummyVariable);

		RayDesc ReflectionRay;
		ReflectionRay.Origin = HitPoint;
		ReflectionRay.TMin = 0.01;
		ReflectionRay.TMax = TranslucencyMaxRayDistance;
		ReflectionRay.Direction = GenerateReflectedRayDirection(Ray.Direction, Payload.WorldNormal, Payload.Roughness, RandSample);

		float3 ReflectionRadiance = float3(0, 0, 0);
		FMaterialClosestHitPayload ReflectionPayload = TraceRayAndAccumulateResults(ReflectionRay, RayCone, ReflectionRadiance);
		TranslucencyColor += ReflectionRadiance;

		// Set refraction ray for next iteration
		float IorV = 1.0;
		float IorL = Payload.Ior;
		if (Payload.HitKind != HIT_KIND_TRIANGLE_FRONT_FACE)
		{
			IorV = Payload.Ior;
			IorL = 1.0;
		}

		float3 RefractedDirection;
		if (!RefractRay(Ray.Direction, Payload.WorldNormal, IorV, IorL, RefractedDirection))
		{
			// TIR
			break;
		}

		Ray.Origin = HitPoint;
		Ray.TMin = 0.001;
		Ray.TMax = TranslucencyMaxRayDistance;
		Ray.Direction = RefractedDirection;
		float SurfaceCurvature = 0.0f; /* #todo_dxr assume no curvature */
		RayCone = PropagateRayCone(RayCone, SurfaceCurvature, Depth);
	}

	ColorOutput[DispatchThreadId] = float4(TranslucencyColor, 1.0); //#dxr_todo: set alpha value depending on hit
	RayHitDistanceOutput[DispatchThreadId] = HitDistance;
}


[shader("miss")]
void RayTracingTranslucencyMainMS(inout FPackedMaterialClosestHitPayload PackedPayload)
{
	PackedPayload.Payload.HitT = -1;
}


[shader("closesthit")]
void RayTracingTranslucencyMainCHS(inout FPackedMaterialClosestHitPayload PackedPayload, in FDefaultAttributes Attributes)
{
	FMaterialClosestHitPayload Payload = (FMaterialClosestHitPayload)0;

	Payload.HitT = RayTCurrent();
	Payload.BaseColor = float3(0.2, 0.3, 0.4);

	FTriangleBaseAttributes Triangle = LoadTriangleBaseAttributes(PrimitiveIndex());
	float3 Edge0 = Triangle.LocalPositions[2] - Triangle.LocalPositions[0];
	float3 Edge1 = Triangle.LocalPositions[1] - Triangle.LocalPositions[0];
	float3x3 WorldToLocal = (float3x3)WorldToObject();
	float3x3 LocalToWorldNormal = transpose(WorldToLocal);
	Payload.WorldNormal = normalize(mul(LocalToWorldNormal, cross(Edge0, Edge1)));

	PackedPayload = PackRayTracingPayload(Payload, PackedPayload.RayCone);
}
