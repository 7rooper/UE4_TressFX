// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	SSDCommon.ush: All the code commonly shared between uniform buffers.
=============================================================================*/

#pragma once

#include "SSDCommon.ush"


//------------------------------------------------------- STRUCTURE

/** Generic data structure to manipulate any kind of signal. */
struct FSSFSignalSample
{
	// Number of sample accumulated.
	float AccumulatedSampleCount;

	// Scene color and alpha.
	float4 SceneColor;

	// Shadow denoising specific.
	float LeavingRayCount;
	float PenumbraClosestHit;
	float UncertainRayCount;
};

FSSFSignalSample CreateSignalSampleFromScalarValue(float Scalar)
{
	FSSFSignalSample OutSample;
	OutSample.SceneColor = Scalar;
	OutSample.AccumulatedSampleCount = Scalar;
	OutSample.LeavingRayCount = Scalar;
	OutSample.PenumbraClosestHit = Scalar;
	OutSample.UncertainRayCount = Scalar;
	return OutSample;
}

FSSFSignalSample CreateSignalSample()
{
	return CreateSignalSampleFromScalarValue(0.0);
}


//------------------------------------------------------- INPUT/OUTPUT

/** Decode input signal sample. */
void DecodeMultiplexedSignals(
	const uint SignalBufferLayout,
	float4 RawSample[MAX_RENDER_TARGET_FOR_SIGNAL],
	out FSSFSignalSample OutSample0,
	out FSSFSignalSample OutSample1,
	out FSSFSignalSample OutSample2)
{
	OutSample0 = CreateSignalSample();
	OutSample1 = CreateSignalSample();
	OutSample2 = CreateSignalSample();

	if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_UNINITIALIZED)
	{
		// trash out the output sample to identify quickly a miss configured buffer layout.
		OutSample0 = CreateSignalSampleFromScalarValue(-1.#INF);
		OutSample1 = CreateSignalSampleFromScalarValue(-1.#INF);
		OutSample2 = CreateSignalSampleFromScalarValue(-1.#INF);
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_PENUMBRA_INPUT)
	{
		OutSample0.AccumulatedSampleCount = 1;
		OutSample0.LeavingRayCount = OutSample0.AccumulatedSampleCount * RawSample[0].r;
		OutSample0.PenumbraClosestHit = RawSample[1].r;
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_PENUMBRA_INTERNAL)
	{
		if (DEBUG_STORE_NORMALIZED_COMPONENTS)
		{
			OutSample0.LeavingRayCount = RawSample[0].r * RawSample[0].b;
			OutSample0.UncertainRayCount = RawSample[0].g * RawSample[0].b;
			OutSample0.AccumulatedSampleCount = RawSample[0].b - OutSample0.UncertainRayCount;
		}
		else
		{
			OutSample0.LeavingRayCount = RawSample[0].r;
			OutSample0.AccumulatedSampleCount = RawSample[0].g;
			OutSample0.UncertainRayCount = RawSample[0].b;
		}
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_PENUMBRA_HISTORY_REJECTION)
	{
		//if (Samples[0].r < 1)
		if (RawSample[0].r >= 0)
		{
			OutSample0.AccumulatedSampleCount = 1;
			OutSample0.LeavingRayCount = OutSample0.AccumulatedSampleCount * RawSample[0].r; // *(255.0 / 254.0);
		}
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_REFLECTIONS_INPUT)
	{
		OutSample0.AccumulatedSampleCount = RawSample[1].r == -2 ? 0 : 1;
		OutSample0.LeavingRayCount = OutSample0.AccumulatedSampleCount * (1 - RawSample[0].a);
		OutSample0.SceneColor = RawSample[0];

		// max() because ray hit distance is < 0 when miss / not ray has been shot.
		OutSample0.PenumbraClosestHit = RawSample[1].r * OutSample0.AccumulatedSampleCount;
		OutSample0.PenumbraClosestHit = ((RawSample[1].r == -1.0) ? 1.0e20 : RawSample[1].r) * OutSample0.AccumulatedSampleCount;
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_REFLECTIONS_REJECTION)
	{
		OutSample0.AccumulatedSampleCount = RawSample[1].r;
		OutSample0.LeavingRayCount = OutSample0.AccumulatedSampleCount * (1 - RawSample[0].a);
		OutSample0.SceneColor = OutSample0.AccumulatedSampleCount * RawSample[0];

		OutSample1.AccumulatedSampleCount = RawSample[1].g;
		OutSample1.LeavingRayCount = OutSample0.AccumulatedSampleCount * (1 - RawSample[2].a);
		OutSample1.SceneColor = OutSample0.AccumulatedSampleCount * RawSample[2];
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_REFLECTIONS_HISTORY)
	{
		OutSample0.AccumulatedSampleCount = RawSample[1].r;
		OutSample0.LeavingRayCount = OutSample0.AccumulatedSampleCount * (1 - RawSample[0].a);
		OutSample0.SceneColor = OutSample0.AccumulatedSampleCount * RawSample[0];

		OutSample1.AccumulatedSampleCount = OutSample0.AccumulatedSampleCount;
		OutSample1.SceneColor.x = OutSample1.AccumulatedSampleCount * RawSample[1].g;
		
		OutSample2.AccumulatedSampleCount = OutSample0.AccumulatedSampleCount;
		OutSample2.SceneColor.x = OutSample2.AccumulatedSampleCount * RawSample[1].b;
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_AO_INPUT)
	{
		OutSample0.AccumulatedSampleCount = RawSample[1].r < 0 ? 0 : 1;
		OutSample0.LeavingRayCount = OutSample0.AccumulatedSampleCount * RawSample[0].r;
		OutSample0.PenumbraClosestHit = OutSample0.AccumulatedSampleCount * RawSample[1].r;
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_AO_HISTORY)
	{
		OutSample0.AccumulatedSampleCount = RawSample[0].g;
		OutSample0.LeavingRayCount = OutSample0.AccumulatedSampleCount * RawSample[0].r;
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_GI_AND_AO_INPUT)
	{
		OutSample0.AccumulatedSampleCount = RawSample[1].g;
		OutSample0.LeavingRayCount = OutSample0.AccumulatedSampleCount * (1 - RawSample[0].a);
		OutSample0.SceneColor = OutSample0.AccumulatedSampleCount * RawSample[0];

		// max() because ray hit distance is < 0 when miss / not ray has been shot.
		OutSample0.PenumbraClosestHit = RawSample[1].r * OutSample0.AccumulatedSampleCount;
		OutSample0.PenumbraClosestHit = ((RawSample[1].r == -1.0) ? 1.0e20 : RawSample[1].r) * OutSample0.AccumulatedSampleCount;
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_GI_AND_AO_HISTORY)
	{
		OutSample0.AccumulatedSampleCount = RawSample[1].r;
		OutSample0.LeavingRayCount = OutSample0.AccumulatedSampleCount * (1 - RawSample[0].a);
		OutSample0.SceneColor = OutSample0.AccumulatedSampleCount * RawSample[0];
	}
} // DecodeMultiplexedSignals()

/** Encode output signal sample. */
void EncodeMultiplexedSignals(
	const uint SignalBufferLayout, const uint MultiplexCount,
	FSSFSignalSample Sample[MAX_SIGNAL_MULTIPLEXING],
	out float4 OutRawSample[MAX_RENDER_TARGET_FOR_SIGNAL],
	out uint OutBufferCount)
{
	// Init all raw samples.
	for (uint i = 0; i < MAX_RENDER_TARGET_FOR_SIGNAL; i++)
		OutRawSample[i] = 0;

	// Number of buffer the signal get encoded onto <= MAX_RENDER_TARGET_FOR_SIGNAL.
	OutBufferCount = 1;

	if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_PENUMBRA_INTERNAL)
	{
		if (DEBUG_STORE_NORMALIZED_COMPONENTS)
		{
			OutRawSample[0] = float4(
				Sample[0].UncertainRayCount + Sample[0].AccumulatedSampleCount > 0
					? Sample[0].LeavingRayCount / (Sample[0].UncertainRayCount + Sample[0].AccumulatedSampleCount)
					: -1.0,
				Sample[0].UncertainRayCount + Sample[0].AccumulatedSampleCount > 0
					? Sample[0].UncertainRayCount / (Sample[0].UncertainRayCount + Sample[0].AccumulatedSampleCount)
					: -1.0,
				Sample[0].UncertainRayCount + Sample[0].AccumulatedSampleCount,
				0);
		}
		else
		{
			OutRawSample[0] = float4(
				Sample[0].LeavingRayCount,
				Sample[0].AccumulatedSampleCount,
				Sample[0].UncertainRayCount,
				0);
		}
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_PENUMBRA_HISTORY_REJECTION)
	{
		//if (Sample.AccumulatedSampleCount == 0)
		//{
		//	OutRawSample[0].r = 1.0;
		//}
		//else
		//{
		//	OutRawSample[0].r = (254.0 / 255.0) * (Sample.LeavingRayCount / Sample.AccumulatedSampleCount);
		//}

		OutRawSample[0].r = Sample[0].AccumulatedSampleCount == 0 ? -1 : Sample[0].LeavingRayCount / Sample[0].AccumulatedSampleCount;
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_REFLECTIONS_REJECTION)
	{
		// Outputs scene color to be compatible with a SSR output.
		OutRawSample[0] = Sample[0].SceneColor * (Sample[0].AccumulatedSampleCount > 0 ? rcp(Sample[0].AccumulatedSampleCount) : 0);
		OutRawSample[1].r = Sample[0].AccumulatedSampleCount;
		OutBufferCount = 2;

		if (MultiplexCount == 2)
		{
			OutRawSample[2] = Sample[1].SceneColor * (Sample[1].AccumulatedSampleCount > 0 ? rcp(Sample[1].AccumulatedSampleCount) : 0);
			OutRawSample[1].g = Sample[1].AccumulatedSampleCount;
			OutBufferCount = 3;
		}
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_REFLECTIONS_HISTORY)
	{
		float NormalizationFactor = SafeRcp(Sample[0].AccumulatedSampleCount);

		// Outputs scene color to be compatible with a SSR output.
		OutRawSample[0] = Sample[0].SceneColor * NormalizationFactor;
		OutRawSample[1].r = Sample[0].AccumulatedSampleCount;
		OutBufferCount = 2;

		if (MultiplexCount == 3)
		{
			OutRawSample[1].g = Sample[1].SceneColor.x * NormalizationFactor;
			OutRawSample[1].b = Sample[2].SceneColor.x * NormalizationFactor;
			OutBufferCount = 3;
		}
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_AO_HISTORY)
	{
		// Outputs number of ray miss in red to be compatible as a SSAO output.
		OutRawSample[0].r = Sample[0].AccumulatedSampleCount > 0 ? Sample[0].LeavingRayCount / Sample[0].AccumulatedSampleCount : 1.0;
		OutRawSample[0].g = Sample[0].AccumulatedSampleCount;
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_GI_AND_AO_HISTORY)
	{
		float NormalizationFactor = SafeRcp(Sample[0].AccumulatedSampleCount);

		OutRawSample[0] = Sample[0].SceneColor * NormalizationFactor;
		OutRawSample[1].r = Sample[0].AccumulatedSampleCount;
		OutBufferCount = 2;

		if (MultiplexCount == 3)
		{
			OutRawSample[1].g = Sample[1].SceneColor.x * NormalizationFactor;
			OutRawSample[1].b = Sample[2].SceneColor.x * NormalizationFactor;
		}
	}
} // EncodeMultiplexedSignals()

/** Sample multiple input signals that have been multiplexed. */
FSSFSignalSample SampleMultiplexedSignal(
	Texture2D SignalBuffer0, Texture2D SignalBuffer1, Texture2D SignalBuffer2,
	SamplerState Sampler,
	const uint SignalBufferLayout, const uint MultiplexId,
	float2 UV, float Level = 0)
{
	float4 RawSample[MAX_RENDER_TARGET_FOR_SIGNAL];
	RawSample[0] = SignalBuffer0.SampleLevel(Sampler, UV, Level);
	RawSample[1] = SignalBuffer1.SampleLevel(Sampler, UV, Level);
	RawSample[2] = SignalBuffer2.SampleLevel(Sampler, UV, Level);

	FSSFSignalSample MultiplexedSample0;
	FSSFSignalSample MultiplexedSample1;
	FSSFSignalSample MultiplexedSample2;

	DecodeMultiplexedSignals(
		SignalBufferLayout,
		RawSample,
		/* out */ MultiplexedSample0,
		/* out */ MultiplexedSample1,
		/* out */ MultiplexedSample2);

	// Branch at compile time what multiplexed signal should be returned. Done this way to work arround shader compiler bugs.
	if (MultiplexId == 2)
	{
		return MultiplexedSample2;
	}
	else if (MultiplexId == 1)
	{
		return MultiplexedSample1;
	}
	return MultiplexedSample0;
}

/** Sample a single input signal. */
FSSFSignalSample SampleInputSignal(
	Texture2D SignalBuffer0, Texture2D SignalBuffer1, Texture2D SignalBuffer2,
	SamplerState Sampler,
	const uint SignalBufferLayout,
	float2 UV, float Level = 0)
{
	return SampleMultiplexedSignal(
		SignalBuffer0, SignalBuffer1, SignalBuffer2,
		Sampler,
		SignalBufferLayout, /* MultiplexId = */ 0,
		UV, Level);
}

/** Outputs multiplexed signal. */
void OutputMultiplexedSignal(
	RWTexture2D<float4> OutputSignalBuffer0, RWTexture2D<float4> OutputSignalBuffer1, RWTexture2D<float4> OutputSignalBuffer2,
	const uint SignalBufferLayout, const uint MultiplexCount,
	const uint2 PixelPosition, FSSFSignalSample MultiplexedSamples[MAX_SIGNAL_MULTIPLEXING])
{
	// Encode the output signal.
	float4 RawSample[MAX_RENDER_TARGET_FOR_SIGNAL];
	uint BufferCount;
	EncodeMultiplexedSignals(
		SignalBufferLayout, MultiplexCount,
		MultiplexedSamples,
		/* out */ RawSample, /* out */ BufferCount);

	// Output the raw encoded sample according to number of RT they requires.
	if (BufferCount >= 1)
		OutputSignalBuffer0[PixelPosition] = RawSample[0];
	if (BufferCount >= 2)
		OutputSignalBuffer1[PixelPosition] = RawSample[1];
	if (BufferCount >= 3)
		OutputSignalBuffer2[PixelPosition] = RawSample[2];
}

/** Outputs a single signal. */
void OutputSignal(
	RWTexture2D<float4> OutputSignalBuffer0, RWTexture2D<float4> OutputSignalBuffer1, RWTexture2D<float4> OutputSignalBuffer2,
	const uint SignalBufferLayout,
	const uint2 PixelPosition, FSSFSignalSample Sample)
{
	// Init all raw samples.
	FSSFSignalSample MultiplexedSamples[MAX_SIGNAL_MULTIPLEXING];
	for (uint i = 0; i < MAX_SIGNAL_MULTIPLEXING; i++)
		MultiplexedSamples[i] = CreateSignalSample();
	MultiplexedSamples[0] = Sample;

	OutputMultiplexedSignal(
		OutputSignalBuffer0, OutputSignalBuffer1, OutputSignalBuffer2,
		SignalBufferLayout, /* MultiplexCount = */ 1,
		PixelPosition, MultiplexedSamples);
}


//------------------------------------------------------- SIGNAL OPERATORS

FSSFSignalSample Mul(FSSFSignalSample Sample, float Scalar)
{
	FSSFSignalSample OutSample;
	OutSample.SceneColor             = Sample.SceneColor * Scalar;
	OutSample.AccumulatedSampleCount = Sample.AccumulatedSampleCount * Scalar;
	OutSample.LeavingRayCount        = Sample.LeavingRayCount * Scalar;
	OutSample.PenumbraClosestHit     = Sample.PenumbraClosestHit * Scalar;
	OutSample.UncertainRayCount      = Sample.UncertainRayCount * Scalar;
	return OutSample;
}

FSSFSignalSample Add(FSSFSignalSample SampleA, FSSFSignalSample SampleB)
{
	SampleA.SceneColor             += SampleB.SceneColor;
	SampleA.AccumulatedSampleCount += SampleB.AccumulatedSampleCount;
	SampleA.LeavingRayCount        += SampleB.LeavingRayCount;
	SampleA.PenumbraClosestHit     += SampleB.PenumbraClosestHit;
	SampleA.UncertainRayCount      += SampleB.UncertainRayCount;
	return SampleA;
}

FSSFSignalSample Minus(FSSFSignalSample Sample)
{
	Sample.SceneColor             = -Sample.SceneColor;
	Sample.AccumulatedSampleCount = -Sample.AccumulatedSampleCount;
	Sample.LeavingRayCount        = -Sample.LeavingRayCount;
	Sample.PenumbraClosestHit     = -Sample.PenumbraClosestHit;
	Sample.UncertainRayCount      = -Sample.UncertainRayCount;
	return Sample;
}

FSSFSignalSample Subtract(FSSFSignalSample SampleA, FSSFSignalSample SampleB)
{
	return Add(SampleA, Minus(SampleB));
}

FSSFSignalSample Abs(FSSFSignalSample Sample)
{
	Sample.SceneColor             = abs(Sample.SceneColor);
	Sample.AccumulatedSampleCount = abs(Sample.AccumulatedSampleCount);
	Sample.LeavingRayCount        = abs(Sample.LeavingRayCount);
	Sample.PenumbraClosestHit     = abs(Sample.PenumbraClosestHit);
	Sample.UncertainRayCount      = abs(Sample.UncertainRayCount);
	return Sample;
}

FSSFSignalSample Sqrt(FSSFSignalSample Sample)
{
	Sample.SceneColor             = sqrt(Sample.SceneColor);
	Sample.AccumulatedSampleCount = sqrt(Sample.AccumulatedSampleCount);
	Sample.LeavingRayCount        = sqrt(Sample.LeavingRayCount);
	Sample.PenumbraClosestHit     = sqrt(Sample.PenumbraClosestHit);
	Sample.UncertainRayCount      = sqrt(Sample.UncertainRayCount);
	return Sample;
}

FSSFSignalSample Power(FSSFSignalSample Sample, float Exponent)
{
	Sample.SceneColor.r           = pow(Sample.SceneColor.r, Exponent);
	Sample.SceneColor.g           = pow(Sample.SceneColor.g, Exponent);
	Sample.SceneColor.b           = pow(Sample.SceneColor.b, Exponent);
	Sample.SceneColor.a           = pow(Sample.SceneColor.a, Exponent);
	Sample.AccumulatedSampleCount = pow(Sample.AccumulatedSampleCount, Exponent);
	Sample.LeavingRayCount        = pow(Sample.LeavingRayCount, Exponent);
	Sample.PenumbraClosestHit     = pow(Sample.PenumbraClosestHit, Exponent);
	Sample.UncertainRayCount      = pow(Sample.UncertainRayCount, Exponent);
	return Sample;
}

FSSFSignalSample Min(FSSFSignalSample SampleA, FSSFSignalSample SampleB)
{
	FSSFSignalSample OutSample;
	OutSample.SceneColor = min(SampleA.SceneColor, SampleB.SceneColor);
	OutSample.AccumulatedSampleCount = min(SampleA.AccumulatedSampleCount, SampleB.AccumulatedSampleCount);
	OutSample.LeavingRayCount = min(SampleA.LeavingRayCount, SampleB.LeavingRayCount);
	OutSample.PenumbraClosestHit = min(SampleA.PenumbraClosestHit, SampleB.PenumbraClosestHit);
	OutSample.UncertainRayCount = min(SampleA.UncertainRayCount, SampleB.UncertainRayCount);
	return OutSample;
}

FSSFSignalSample Max(FSSFSignalSample SampleA, FSSFSignalSample SampleB)
{
	FSSFSignalSample OutSample;
	OutSample.SceneColor = max(SampleA.SceneColor, SampleB.SceneColor);
	OutSample.AccumulatedSampleCount = max(SampleA.AccumulatedSampleCount, SampleB.AccumulatedSampleCount);
	OutSample.LeavingRayCount = max(SampleA.LeavingRayCount, SampleB.LeavingRayCount);
	OutSample.PenumbraClosestHit = max(SampleA.PenumbraClosestHit, SampleB.PenumbraClosestHit);
	OutSample.UncertainRayCount = max(SampleA.UncertainRayCount, SampleB.UncertainRayCount);
	return OutSample;
}

FSSFSignalSample Clamp(FSSFSignalSample Sample, FSSFSignalSample SampleMin, FSSFSignalSample SampleMax)
{
	FSSFSignalSample OutSample;
	OutSample.SceneColor = clamp(Sample.SceneColor, SampleMin.SceneColor, SampleMax.SceneColor);
	OutSample.AccumulatedSampleCount = clamp(Sample.AccumulatedSampleCount, SampleMin.AccumulatedSampleCount, SampleMax.AccumulatedSampleCount);
	OutSample.LeavingRayCount = clamp(Sample.LeavingRayCount, SampleMin.LeavingRayCount, SampleMax.LeavingRayCount);
	OutSample.PenumbraClosestHit = clamp(Sample.PenumbraClosestHit, SampleMin.PenumbraClosestHit, SampleMax.PenumbraClosestHit);
	OutSample.UncertainRayCount = clamp(Sample.UncertainRayCount, SampleMin.UncertainRayCount, SampleMax.UncertainRayCount);
	return OutSample;
}

FSSFSignalSample Lerp(FSSFSignalSample Sample0, FSSFSignalSample Sample1, float Interp)
{
	return Add(Sample0, Mul(Subtract(Sample1, Sample0), Interp));
}

/** Normalize the signal sample to one. */
FSSFSignalSample NormalizeToOneSample(FSSFSignalSample Sample)
{
	FSSFSignalSample OutSample = Mul(Sample, Sample.AccumulatedSampleCount > 0 ? rcp(Sample.AccumulatedSampleCount) : 0);
	OutSample.AccumulatedSampleCount = Sample.AccumulatedSampleCount > 0 ? 1 : 0;
	return OutSample;
}
