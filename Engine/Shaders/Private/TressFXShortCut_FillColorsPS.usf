//
// Copyright (c) 2017 Advanced Micro Devices, Inc. All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

//Unreal Engin 4 integration written by Leon Rosengarten 2017

#pragma once
#include "Common.ush"
#include "TressFXShortCutCommon.ush"
#include "TressFXRendering.ush"
#include "ReflectionEnvironmentShared.ush"

struct FMaterialParticleParameters
{
	/** Relative time [0-1]. */
    half RelativeTime;
	/** Fade amount due to motion blur. */
    half MotionBlurFade;
	/** Random value per particle [0-1]. */
    half Random;
	/** XYZ: Direction, W: Speed. */
    half4 Velocity;
	/** Per-particle color. */
    half4 Color;
	/** Particle translated world space position and size(radius). */
    float4 TranslatedWorldPositionAndSize;
	/** Macro UV scale and bias. */
    half4 MacroUV;
	/** Dynamic parameter used by particle systems. */
    half4 DynamicParameter;
	/** mesh particle orientation */
    float4x4 LocalToWorld;

#if USE_PARTICLE_SUBUVS
	/** SubUV texture coordinates*/
	MaterialFloat2 SubUVCoords[2];
	/** SubUV interpolation value*/
	MaterialFloat SubUVLerp;
#endif

	/** The size of the particle. */
    float2 Size;
};

struct FMaterialPixelParameters
{
#if NUM_MATERIAL_TEXCOORDS
	float2 TexCoords[NUM_MATERIAL_TEXCOORDS];
#endif

	/** Interpolated vertex color, in linear color space. */
    half4 VertexColor;

	/** Normalized world space normal. */
    half3 WorldNormal;

	/** Normalized world space reflected camera vector. */
    half3 ReflectionVector;

	/** Normalized world space camera vector, which is the vector from the point being shaded to the camera position. */
    half3 CameraVector;

	/** World space light vector, only valid when rendering a light function. */
    half3 LightVector;

	/**
	 * Like SV_Position (.xy is pixel position at pixel center, z:DeviceZ, .w:SceneDepth)
	 * using shader generated value SV_POSITION
	 * Warning: unlike SV_Position, this is not relative to the current viewport.  SV_Position = MaterialParameters.SvPosition.xy - View.ViewRectMin.xy;
	 */
    float4 SvPosition;
		
	/** Post projection position reconstructed from SvPosition, before the divide by W. left..top -1..1, bottom..top -1..1  within the viewport, W is the SceneDepth */
    float4 ScreenPosition;

    half UnMirrored;

    half TwoSidedSign;

	/**
	 * Orthonormal rotation-only transform from tangent space to world space
	 * The transpose(TangentToWorld) is WorldToTangent, and TangentToWorld[2] is WorldVertexNormal
	 */
    half3x3 TangentToWorld;

	/** 
	 * Interpolated worldspace position of this pixel
	 * todo: Make this TranslatedWorldPosition and also rename the VS/DS/HS WorldPosition to be TranslatedWorldPosition
	 */
    float3 AbsoluteWorldPosition;

	/** 
	 * Interpolated worldspace position of this pixel, centered around the camera
	 */
    float3 WorldPosition_CamRelative;

	/** 
	 * Interpolated worldspace position of this pixel, not including any world position offset or displacement.
	 * Only valid if shader is compiled with NEEDS_WORLD_POSITION_EXCLUDING_SHADER_OFFSETS, otherwise just contains 0
	 */
    float3 WorldPosition_NoOffsets;

	/** 
	 * Interpolated worldspace position of this pixel, not including any world position offset or displacement.
	 * Only valid if shader is compiled with NEEDS_WORLD_POSITION_EXCLUDING_SHADER_OFFSETS, otherwise just contains 0
	 */
    float3 WorldPosition_NoOffsets_CamRelative;

	/** Offset applied to the lighting position for translucency, used to break up aliasing artifacts. */
    half3 LightingPositionOffset;

    float AOMaterialMask;

#if LIGHTMAP_UV_ACCESS
	float2	LightmapUVs;
#endif

#if USE_INSTANCING
	half4 PerInstanceParams;
#endif

	/** Per-particle properties. Only valid for particle vertex factories. */
    FMaterialParticleParameters Particle;

#if (ES2_PROFILE || ES3_1_PROFILE)
	float4 LayerWeights;
#endif

#if TEX_COORD_SCALE_ANALYSIS
	/** Parameters used by the MaterialTexCoordScales shader. */
	FTexCoordScalesParams TexCoordScalesParams;
#endif

#if POST_PROCESS_MATERIAL && (FEATURE_LEVEL <= FEATURE_LEVEL_ES3_1)
	/** Used in mobile custom pp material to preserve original SceneColor Alpha */
	half BackupSceneColorAlpha;
#endif

#if COMPILER_HLSL
	// Workaround for "error X3067: 'GetObjectWorldPosition': ambiguous function call"
	// Which happens when FMaterialPixelParameters and FMaterialVertexParameters have the same number of floats with the HLSL compiler ver 9.29.952.3111
	// Function overload resolution appears to identify types based on how many floats / ints / etc they contain
	uint Dummy;
#endif
};

// @todo compat hack
FMaterialPixelParameters MakeInitializedMaterialPixelParameters()
{
    FMaterialPixelParameters MPP;
    MPP = (FMaterialPixelParameters) 0;
    MPP.TangentToWorld = float3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return MPP;
}

#include "PlanarReflectionShared.ush"
#include "ForwardLightingCommon.ush"


//--------------------------------------------------------------------------------------
// ComputeShadow
//
// Computes the shadow using a simplified deep shadow map technique for the hair and
// PCF for scene objects. It uses multiple taps to filter over a (KERNEL_SIZE x KERNEL_SIZE)
// kernel for high quality results.
//--------------------------------------------------------------------------------------
float ComputeShadow(float3 worldPos, float alpha, int iTechSM)
{

    return 1;
	/*
	if (iTechSM == SHADOW_NONE)
		return 1;

	float4 projPosLight = mul(float4(worldPos, 1), g_mViewProjLight);
	float2 texSM = float2(projPosLight.x / projPosLight.w + 1, -projPosLight.y / projPosLight.w + 1) * 0.5;
	float depth = projPosLight.z / projPosLight.w;
	float epsilon = depth * SM_EPSILON;
	float depth_fragment = projPosLight.w;

    // for shadow casted by scene objs, use PCF shadow
	float total_weight = 0;
	float amountLight_hair = 0;

	total_weight = 0;
    [unroll]
	for (int dx = (1 - KERNEL_SIZE) / 2; dx <= KERNEL_SIZE / 2; dx++)
	{
        [unroll]
		for (int dy = (1 - KERNEL_SIZE) / 2; dy <= KERNEL_SIZE / 2; dy++)
		{
			float size = 2.4;
			float sigma = (KERNEL_SIZE / 2.0) / size; // standard deviation, when kernel/2 > 3*sigma, it's close to zero, here we use 1.5 instead
			float exp = -1 * (dx * dx + dy * dy) / (2 * sigma * sigma);
			float weight = 1 / (2 * PI * sigma * sigma) * pow(e, exp);

            // shadow casted by hair: simplified deep shadow map
			float depthSMHair = g_txSMHair.SampleLevel(g_samPointClamp, texSM, 0, int2(dx, dy)).x; //z/w

			float depth_smPoint = g_fNearLight / (1 - depthSMHair * (g_fFarLight - g_fNearLight) / g_fFarLight);

			float depth_range = max(0, depth_fragment - depth_smPoint);
			float numFibers = depth_range / (g_FiberSpacing * g_FiberRadius);

            // if occluded by hair, there is at least one fiber
            [flatten]
			if (depth_range > 1e-5)
				numFibers += 1;
			amountLight_hair += pow(abs(1 - alpha), numFibers) * weight;

			total_weight += weight;
		}
	}
	amountLight_hair /= total_weight;

	float amountLight_scene = g_txSMScene.SampleCmpLevelZero(g_samShadow, texSM, depth - epsilon);

	return (amountLight_hair * amountLight_scene);*/

}


#ifndef HEAD_SHADING

float3 AccumulateHairLight(uint GridIndex, float3 WorldPosition, float3 vViewWS, float3 vTangent, HairShadeParams params, float2 ScreenUV, uint EyeIndex)
{
    float4 DynamicShadowFactors = 1;

#if MATERIALBLENDING_SOLID || MATERIALBLENDING_MASKED
		DynamicShadowFactors = GetForwardDynamicShadowFactors(ScreenUV);
#endif

    float3 DirectLighting = 0;

	// Prevent 0 Roughness which causes NaNs in Vis_SmithJointApprox
    float SpecularScale = 1;

#if TRANSLUCENCY_ANY_VOLUMETRIC
	// No specular on volumetric translucency lighting modes
	SpecularScale = 0.0f;
#endif	
	
    float3 color = float3(0, 0, 0);
    float3 V = normalize(vViewWS);
    float3 T = normalize(vTangent);
    float fLightScale = 1;
	
    BRANCH
    if (ForwardLightData.HasDirectionalLight)
    {
        FDeferredLightData LightData = (FDeferredLightData) 0;
        LightData.LightColorAndFalloffExponent = float4(ForwardLightData.DirectionalLightColor, 0);
        LightData.LightDirection = ForwardLightData.DirectionalLightDirection;
        LightData.DistanceFadeMAD = ForwardLightData.DirectionalLightDistanceFadeMAD;
        LightData.bRadialLight = false;
        LightData.SpecularScale = SpecularScale;

        LightData.ShadowedBits = (ForwardLightData.DirectionalLightShadowMapChannelMask & 0xFF) != 0 ? 1 : 0;
		// Static shadowing uses ShadowMapChannel, dynamic shadows are packed into light attenuation using PreviewShadowMapChannel
        LightData.ShadowMapChannelMask = UnpackShadowMapChannelMask(ForwardLightData.DirectionalLightShadowMapChannelMask);
        float4 PreviewShadowMapChannelMask = UnpackShadowMapChannelMask(ForwardLightData.DirectionalLightShadowMapChannelMask >> 4);
        float DynamicShadowing = dot(PreviewShadowMapChannelMask, DynamicShadowFactors);

		// In the forward shading path we can't separate per-object shadows from CSM, since we only spend one light attenuation channel per light
		// If CSM is enabled (distance fading to precomputed shadowing is active), treat all of our dynamic shadowing as whole scene shadows that will be faded out at the max CSM distance
		// If CSM is not enabled, allow our dynamic shadowing to coexist with precomputed shadowing
        float PerObjectShadowing = LightData.DistanceFadeMAD.y < 0.0f ? 1.0f : DynamicShadowing;
        float WholeSceneShadowing = LightData.DistanceFadeMAD.y < 0.0f ? DynamicShadowing : 1.0f;
		
        float4 LightAttenuation = float4(WholeSceneShadowing.xx, PerObjectShadowing.xx);

		// spec vs diffuse through the light.
        float lightEmitsDiffuse = 1;
        float lightEmitsSpecular = 1;
        float3 cLightColor = LightData.LightColorAndFalloffExponent.rgb;
		// if we get zero, we can save the BRDF eval, which is costly.
        float fShadowTerm = 1.f; //ComputeLightShadow(nLightID, vPositionWS);

        if (fShadowTerm > 0.00001)
        {
            float3 L = normalize(LightData.LightDirection);

            float3 reflection = TressFX_ComputeDiffuseSpecFactors(V, L, T);

            float3 cReflectedLight = reflection.x * cLightColor * lightEmitsDiffuse * params.cColor;
            cReflectedLight += reflection.y * cLightColor * lightEmitsSpecular;
            cReflectedLight += reflection.z * cLightColor * lightEmitsSpecular * params.cColor;
            cReflectedLight *= fShadowTerm * fLightScale; // * 0.16;

            color += max(float3(0, 0, 0), cReflectedLight);

        }

        float3 NewLighting = color;

		//float3 NewLighting = GetDynamicLighting(WorldPosition, -CameraVector, GBufferData, 1, GBufferData.ShadingModelID, LightData, LightAttenuation, uint2(0, 0)).xyz;


		//float3 NewLighting = GetDynamicLighting(WorldPosition, -CameraVector, GBufferData, 1, GBufferData.ShadingModelID, LightData, LightAttenuation, uint2(0, 0)).xyz;

        FLATTEN
        if ((ForwardLightData.DirectionalLightShadowMapChannelMask >> 8) & Primitive.LightingChannelMask)
        {
            DirectLighting += NewLighting;
        }
    }
	

	/*
	const CulledLightsGridData CulledLightsGrid = GetCulledLightsGrid(GridIndex, EyeIndex);

	LOOP
	for (uint LocalLightListIndex = 0; LocalLightListIndex < CulledLightsGrid.NumLocalLights; LocalLightListIndex++)
	{
		const LocalLightData LocalLight = GetLocalLightData(CulledLightsGrid.DataStartIndex + LocalLightListIndex, EyeIndex);
		 
		FDeferredLightData LightData = (FDeferredLightData) 0;
		LightData.LightPositionAndInvRadius = LocalLight.LightPositionAndInvRadius;
		LightData.LightColorAndFalloffExponent = LocalLight.LightColorAndFalloffExponent;
		LightData.LightDirection = LocalLight.LightDirectionAndShadowMask.xyz;
		LightData.SpotAnglesAndSourceRadius = LocalLight.SpotAnglesAndSourceRadius;
		LightData.bInverseSquared = LightData.LightColorAndFalloffExponent.w == 0;
		LightData.bRadialLight = true;
		LightData.bSpotLight = LightData.SpotAnglesAndSourceRadius.x > -2.0f;
		LightData.MinRoughness = MinRoughness;

		uint PackedShadowMapChannelMask = asuint(LocalLight.LightDirectionAndShadowMask.w);
		LightData.ShadowedBits = (PackedShadowMapChannelMask & 0xFF) != 0 ? 1 : 0;
		// Static shadowing uses ShadowMapChannel, dynamic shadows are packed into light attenuation using PreviewShadowMapChannel
		LightData.ShadowMapChannelMask = UnpackShadowMapChannelMask(PackedShadowMapChannelMask);
		float4 PreviewShadowMapChannelMask = UnpackShadowMapChannelMask(PackedShadowMapChannelMask >> 4);
		float DynamicShadowing = dot(PreviewShadowMapChannelMask, DynamicShadowFactors);
		float4 LightAttenuation = float4(1, 1, DynamicShadowing.x, DynamicShadowing.x);

		                // yes, I know this seems weird - but it's basically a way to control
                // spec vs diffuse through the light.
		float lightEmitsDiffuse = 1;
		float lightEmitsSpecular = 1;
		float3 cLightColor = LightData.LightColorAndFalloffExponent.rgb;
				// if we get zero, we can save the BRDF eval, which is costly.
		float fShadowTerm = 1.f;//ComputeLightShadow(nLightID, vPositionWS);

		if (fShadowTerm > 0.00001)
		{
			float3 L = normalize(LightData.LightDirection);

			float3 reflection = TressFX_ComputeDiffuseSpecFactors(V, L, T);

			float3 cReflectedLight = reflection.x * cLightColor * lightEmitsDiffuse * params.cColor;
			cReflectedLight += reflection.y * cLightColor * lightEmitsSpecular;
			cReflectedLight += reflection.z * cLightColor * lightEmitsSpecular * params.cColor;
			cReflectedLight *= fShadowTerm * fLightScale; // * 0.16;

			color += max(float3(0, 0, 0), cReflectedLight);

		}

		float3 NewLighting = color;

		//float3 NewLighting = GetDynamicLighting(WorldPosition, -CameraVector, GBufferData, 1, GBufferData.ShadingModelID, LightData, LightAttenuation, uint2(0, 0)).xyz;

		FLATTEN
		if ((PackedShadowMapChannelMask >> 8) & Primitive.LightingChannelMask)
		{
			DirectLighting += NewLighting;
		}
	}
*/

	// For debugging
	//DirectLighting = CulledLightsGrid.NumLocalLights / (float)ForwardLightData.MaxCulledLightsPerCell;
    return DirectLighting;
}



float4 TressFXHeadColor(float2 pixelCoord, float depth, float4 vTangentCoverage, float3 baseColor)
{
	//TressFX_ComputeDiffuseSpecFactors()
    return float4(baseColor, vTangentCoverage.w);
}

#define HEAD_SHADING TressFXHeadColor

#endif 

struct PS_INPUT_HAIR_AA
{
    float4 Position : SV_POSITION;
    float4 Tangent : Tangent;
    float4 p0p1 : TEXCOORD0;
    float3 strandColor : TEXCOORD1;
};

// Third pass of ShortCut.
// Geometry pass that shades pixels passing early depth test.  Limited to near fragments due to previous depth write pass.
// Colors are accumulated in render target for a weighted average in final pass.
[earlydepthstencil]
float4 main(PS_INPUT_HAIR_AA input) : SV_Target
{
    float4 viewport = float4(View.ViewRectMin.xy, View.ViewSizeAndInvSize.xy);
    float3 vNDC = ScreenPosToNDC(input.Position.xyz, viewport);
    float coverage = ComputeCoverage(input.p0p1.zw, input.p0p1.xy, vNDC.xy, viewport.zw);
    int2 vScreenAddress = int2(input.Position.xy);
    float3 vPositionWS = NDCToWorld(vNDC, g_mInvViewProj);

    uint GridIndex = ComputeLightGridCellIndex((uint2) (input.Position.xy - ResolvedView.ViewRectMin.xy), input.Position.w, 0);

	

	                // TODO remove params, since we are using globals anyways.
    HairShadeParams params;

    params.cColor = input.strandColor.xyz;
    params.fRadius = g_FiberRadius;
    params.fSpacing = g_FiberSpacing;
    params.fAlpha = g_HairShadowAlpha;

    //float3 Light = GetForwardDirectLighting(GridIndex, vPositionWS, , GBufferData, vScreenAddress, 0);
    float alpha = coverage * 0.63;

    if (alpha < SHORTCUT_MIN_ALPHA)
    {
        return float4(0, 0, 0, 0);
    }	

    uint uDepth = asuint(input.Position.z);

	// Shade regardless of depth, since ResolveDepth pass writes one of the near depths     
	
    float4 rgbaColor = float4(AccumulateHairLight(GridIndex, vPositionWS, -View.ViewForward, input.Tangent, params, vScreenAddress, 0), 0);
	//HEAD_SHADING(input.Position.xy, input.Position.z, float4(input.Tangent.xyz*0.5 + float3(0.5, 0.5, 0.5), alpha), input.strandColor.xyz);
    
    float3 color = rgbaColor.xyz;
    uint uColor = PackFloat4IntoUint(float4(color, alpha));

    return float4(color * alpha, alpha);
}
