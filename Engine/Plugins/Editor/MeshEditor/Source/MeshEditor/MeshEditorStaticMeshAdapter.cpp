// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#include "MeshEditorStaticMeshAdapter.h"
#include "EditableMesh.h"
#include "WireframeMeshComponent.h"


static FColor GetEdgeColor( bool bIsHardEdge )
{
	return bIsHardEdge ? FColor( 0, 76, 76 ) : FColor( 0, 0, 76 );
}


UMeshEditorStaticMeshAdapter::UMeshEditorStaticMeshAdapter()
{
}


void UMeshEditorStaticMeshAdapter::Initialize( UEditableMesh* EditableMesh, UWireframeMesh* InWireframeMesh )
{
	WireframeMesh = InWireframeMesh;
}


void UMeshEditorStaticMeshAdapter::OnRebuildRenderMeshStart( const UEditableMesh* EditableMesh, const bool bInvalidateLighting )
{
	for( TObjectIterator<UWireframeMeshComponent> It( RF_ClassDefaultObject, false, EInternalObjectFlags::PendingKill ); It; ++It )
	{
		if( It->GetWireframeMesh() == WireframeMesh )
		{
			if( It->IsRenderStateCreated() )
			{
				check( It->IsRegistered() );
				It->UnregisterComponent();
			}
		}
	}

	WireframeMesh->ReleaseResources();

	// Flush the rendering commands generated by the detachments.
	FlushRenderingCommands();
}


void UMeshEditorStaticMeshAdapter::OnRebuildRenderMesh( const UEditableMesh* EditableMesh )
{
	WireframeMesh->Reset();

	// Add all vertices
	for( const FVertexID VertexID : EditableMesh->GetMeshDescription()->Vertices().GetElementIDs() )
	{
		WireframeMesh->AddVertex( VertexID );
		WireframeMesh->SetVertexPosition( VertexID, EditableMesh->GetVertexAttribute( VertexID, UEditableMeshAttribute::VertexPosition(), 0 ) );
	}

	// Add all edges
	for( const FEdgeID EdgeID : EditableMesh->GetMeshDescription()->Edges().GetElementIDs() )
	{
		WireframeMesh->AddEdge( EdgeID );
		WireframeMesh->SetEdgeVertices( EdgeID, EditableMesh->GetEdgeVertex( EdgeID, 0 ), EditableMesh->GetEdgeVertex( EdgeID, 1 ) );
		WireframeMesh->SetEdgeColor( EdgeID, GetEdgeColor( EditableMesh->GetEdgeAttribute( EdgeID, UEditableMeshAttribute::EdgeIsHard(), 0 ).X > 0.0f ) );
	}

	// Add all polygons and edge instances
	// @todo mesheditor wireframe: holes not yet handled
	for( const FPolygonID PolygonID : EditableMesh->GetMeshDescription()->Polygons().GetElementIDs() )
	{
		WireframeMesh->AddPolygon( PolygonID );
		WireframeMesh->SetPolygonNormal( PolygonID, EditableMesh->ComputePolygonNormal( PolygonID ) );

		const int32 NumEdges = EditableMesh->GetPolygonPerimeterEdgeCount( PolygonID );
		for( int32 Index = 0; Index < NumEdges; ++Index )
		{
			bool bOutWindingIsReversed;
			WireframeMesh->AddEdgeInstance( EditableMesh->GetPolygonPerimeterEdge( PolygonID, Index, bOutWindingIsReversed ), PolygonID );
		}
	}
}


void UMeshEditorStaticMeshAdapter::OnRebuildRenderMeshFinish( const UEditableMesh* EditableMesh, const bool bRebuildBoundsAndCollision, const bool bIsPreviewRollback )
{
	for( const FPolygonID PolygonID : EditableMesh->PolygonsPendingNewTangentBasis )
	{
		const FMeshPolygon& Polygon = EditableMesh->GetMeshDescription()->GetPolygon( PolygonID );
		WireframeMesh->SetPolygonNormal( PolygonID, Polygon.PolygonNormal );
	}

	WireframeMesh->InitResources();

	for( TObjectIterator<UWireframeMeshComponent> It( RF_ClassDefaultObject, false, EInternalObjectFlags::PendingKill ); It; ++It )
	{
		if( It->GetWireframeMesh() == WireframeMesh )
		{
			if( !It->IsRenderStateCreated() )
			{
				It->RegisterComponent();
			}
		}
	}
}


void UMeshEditorStaticMeshAdapter::OnStartModification( const UEditableMesh* EditableMesh, const EMeshModificationType MeshModificationType, const EMeshTopologyChange MeshTopologyChange )
{
}


void UMeshEditorStaticMeshAdapter::OnEndModification( const UEditableMesh* EditableMesh )
{
}


void UMeshEditorStaticMeshAdapter::OnReindexElements( const UEditableMesh* EditableMesh, const FElementIDRemappings& Remappings )
{
}


bool UMeshEditorStaticMeshAdapter::IsCommitted( const UEditableMesh* EditableMesh ) const
{
	return false;
}


bool UMeshEditorStaticMeshAdapter::IsCommittedAsInstance( const UEditableMesh* EditableMesh ) const
{
	return false;
}


void UMeshEditorStaticMeshAdapter::OnCommit( UEditableMesh* EditableMesh )
{
}


UEditableMesh* UMeshEditorStaticMeshAdapter::OnCommitInstance( UEditableMesh* EditableMesh, UPrimitiveComponent* ComponentToInstanceTo )
{
	return nullptr;
}


void UMeshEditorStaticMeshAdapter::OnRevert( UEditableMesh* EditableMesh )
{
}


UEditableMesh* UMeshEditorStaticMeshAdapter::OnRevertInstance( UEditableMesh* EditableMesh )
{
	return nullptr;
}


void UMeshEditorStaticMeshAdapter::OnPropagateInstanceChanges( UEditableMesh* EditableMesh )
{
}


void UMeshEditorStaticMeshAdapter::OnDeleteVertexInstances( const UEditableMesh* EditableMesh, const TArray<FVertexInstanceID>& VertexInstanceIDs )
{
}


void UMeshEditorStaticMeshAdapter::OnDeleteOrphanVertices( const UEditableMesh* EditableMesh, const TArray<FVertexID>& VertexIDs )
{
	for( const FVertexID VertexID : VertexIDs )
	{
		WireframeMesh->RemoveVertex( VertexID );
	}
}


void UMeshEditorStaticMeshAdapter::OnCreateEmptyVertexRange( const UEditableMesh* EditableMesh, const TArray<FVertexID>& VertexIDs )
{
	for( const FVertexID VertexID : VertexIDs )
	{
		WireframeMesh->AddVertex( VertexID );
	}
}


void UMeshEditorStaticMeshAdapter::OnCreateVertices( const UEditableMesh* EditableMesh, const TArray<FVertexID>& VertexIDs )
{
	for( const FVertexID VertexID : VertexIDs )
	{
		WireframeMesh->AddVertex( VertexID );
		WireframeMesh->SetVertexPosition( VertexID, EditableMesh->GetVertexAttribute( VertexID, UEditableMeshAttribute::VertexPosition(), 0 ) );
	}
}


void UMeshEditorStaticMeshAdapter::OnCreateVertexInstances( const UEditableMesh* EditableMesh, const TArray<FVertexInstanceID>& VertexInstanceIDs )
{
}


void UMeshEditorStaticMeshAdapter::OnSetVertexAttribute( const UEditableMesh* EditableMesh, const FVertexID VertexID, const FName AttributeName, const int32 AttributeIndex, const FVector4 AttributeValue )
{
	if( AttributeName == UEditableMeshAttribute::VertexPosition() )
	{
		WireframeMesh->SetVertexPosition( VertexID, AttributeValue );
	}
}


void UMeshEditorStaticMeshAdapter::OnSetVertexInstanceAttribute( const UEditableMesh* EditableMesh, const FVertexInstanceID VertexInstanceID, const FName AttributeName, const int32 AttributeIndex, const FVector4 AttributeValue )
{
}


void UMeshEditorStaticMeshAdapter::OnCreateEdges( const UEditableMesh* EditableMesh, const TArray<FEdgeID>& EdgeIDs )
{
	const FEdgeArray& Edges = EditableMesh->GetMeshDescription()->Edges();

	for( const FEdgeID EdgeID : EdgeIDs )
	{
		const FMeshEdge& Edge = Edges[ EdgeID ];

		WireframeMesh->AddEdge( EdgeID );
		WireframeMesh->SetEdgeVertices( EdgeID, EditableMesh->GetEdgeVertex( EdgeID, 0 ), EditableMesh->GetEdgeVertex( EdgeID, 1 ) );
		WireframeMesh->SetEdgeColor( EdgeID, GetEdgeColor( EditableMesh->GetEdgeAttribute( EdgeID, UEditableMeshAttribute::EdgeIsHard(), 0 ).X > 0.0f ) );

		for( const FPolygonID PolygonID : Edge.ConnectedPolygons )
		{
			WireframeMesh->AddEdgeInstance( EdgeID, PolygonID );
		}
	}
}


void UMeshEditorStaticMeshAdapter::OnDeleteEdges( const UEditableMesh* EditableMesh, const TArray<FEdgeID>& EdgeIDs )
{
	const FEdgeArray& Edges = EditableMesh->GetMeshDescription()->Edges();

	for( const FEdgeID EdgeID : EdgeIDs )
	{
		const FMeshEdge& Edge = Edges[ EdgeID ];

		for( const FPolygonID PolygonID : Edge.ConnectedPolygons )
		{
			WireframeMesh->RemoveEdgeInstance( EdgeID, PolygonID );
		}

		WireframeMesh->RemoveEdge( EdgeID );
	}
}


void UMeshEditorStaticMeshAdapter::OnSetEdgesVertices( const UEditableMesh* EditableMesh, const TArray<FEdgeID>& EdgeIDs )
{
	for( const FEdgeID EdgeID : EdgeIDs )
	{
		WireframeMesh->SetEdgeVertices( EdgeID, EditableMesh->GetEdgeVertex( EdgeID, 0 ), EditableMesh->GetEdgeVertex( EdgeID, 1 ) );
	}
}


void UMeshEditorStaticMeshAdapter::OnSetEdgeAttribute( const UEditableMesh* EditableMesh, const FEdgeID EdgeID, const FName AttributeName, const int32 AttributeIndex, const FVector4 AttributeValue )
{
	if( AttributeName == UEditableMeshAttribute::EdgeIsHard() )
	{
		WireframeMesh->SetEdgeColor( EdgeID, GetEdgeColor( AttributeValue.X > 0.0f ) );
	}
}


void UMeshEditorStaticMeshAdapter::OnCreatePolygons( const UEditableMesh* EditableMesh, const TArray<FPolygonID>& PolygonIDs )
{
	for( const FPolygonID PolygonID : PolygonIDs )
	{
		WireframeMesh->AddPolygon( PolygonID );
		WireframeMesh->SetPolygonNormal( PolygonID, EditableMesh->ComputePolygonNormal( PolygonID ) );

		const int32 NumEdges = EditableMesh->GetPolygonPerimeterEdgeCount( PolygonID );
		for( int32 Index = 0; Index < NumEdges; ++Index )
		{
			bool bOutWindingIsReversed;
			WireframeMesh->AddEdgeInstance( EditableMesh->GetPolygonPerimeterEdge( PolygonID, Index, bOutWindingIsReversed ), PolygonID );
		}
	}
}


void UMeshEditorStaticMeshAdapter::OnDeletePolygons( const UEditableMesh* EditableMesh, const TArray<FPolygonID>& PolygonIDs )
{
	for( const FPolygonID PolygonID : PolygonIDs )
	{
		const int32 NumEdges = EditableMesh->GetPolygonPerimeterEdgeCount( PolygonID );
		for( int32 Index = 0; Index < NumEdges; ++Index )
		{
			bool bOutWindingIsReversed;
			WireframeMesh->RemoveEdgeInstance( EditableMesh->GetPolygonPerimeterEdge( PolygonID, Index, bOutWindingIsReversed ), PolygonID );
		}

		WireframeMesh->RemovePolygon( PolygonID );
	}
}


void UMeshEditorStaticMeshAdapter::OnChangePolygonVertexInstances( const UEditableMesh* EditableMesh, const TArray<FPolygonID>& PolygonIDs )
{
}


void UMeshEditorStaticMeshAdapter::OnCreatePolygonGroups( const UEditableMesh* EditableMesh, const TArray<FPolygonGroupID>& PolygonGroupIDs )
{
}


void UMeshEditorStaticMeshAdapter::OnDeletePolygonGroups( const UEditableMesh* EditableMesh, const TArray<FPolygonGroupID>& PolygonGroupIDs )
{
}


void UMeshEditorStaticMeshAdapter::OnRetriangulatePolygons( const UEditableMesh* EditableMesh, const TArray<FPolygonID>& PolygonIDs )
{
}
