#pragma once
#include "Common.ush"
#include "ShadingModels.ush"
#include "TressFXRendering.ush"
#include "ReflectionEnvironmentShared.ush"
#include "PlanarReflectionShared.ush"
#include "BRDF.ush"
#include "Random.ush"
#include "LightAccumulator.ush"


#define NON_DIRECTIONAL_DIRECT_LIGHTING (TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL || TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_NONDIRECTIONAL)
#define SUPPORT_CONTACT_SHADOWS 0

#include "DeferredLightingCommon.ush"
#include "LightGridCommon.ush"



#if ERROR_CHECK
#define ASSERT(x) if(!(x)) RETURN_ERROR
#else
#define ASSERT(x) 
#endif

//#define COLORDEBUG

struct PPLL_STRUCT
{
    uint depth;
    uint data;
    uint color;
    uint Gbuffer;
    uint uNext;
};

#ifndef FRAGMENT_LIST_NULL
#define FRAGMENT_LIST_NULL 0xffffffff
#endif

#define HAS_COLOR 1

#ifndef KBUFFER_SIZE
#define KBUFFER_SIZE 4
#endif


float3 ScreenPosToNDC(float3 vScreenPos, float4 viewport)
{
    float2 xy = vScreenPos.xy;

	// add viewport offset.
    xy += viewport.xy;

	// scale by viewport to put in 0 to 1
    xy /= viewport.zw;

	// shift and scale to put in -1 to 1. y is also being flipped.
    xy.x = (2 * xy.x) - 1;
    xy.y = 1 - (2 * xy.y);

    return float3(xy, vScreenPos.z);
}


float3 ScreenToNDC(float3 vScreenPos, float4 viewport)
{
    float2 xy = vScreenPos.xy;

	// add viewport offset.
    xy += viewport.xy;

	// scale by viewport to put in 0 to 1
    xy /= viewport.zw;

	// shift and scale to put in -1 to 1. y is also being flipped.
    xy.x = (2 * xy.x) - 1;
    xy.y = 1 - (2 * xy.y);

    return float3(xy, vScreenPos.z);

}

float3 NDCToWorld(float3 vNDC, float4x4 mInvViewProj)
{
    float4 pos = mul(mInvViewProj, float4(vNDC, 1));

    return pos.xyz / pos.w;
}


// viewport.xy = offset, viewport.zw = size
float3 GetWorldPos(float4 vScreenPos, float4 viewport, float4x4 invViewProj)
{
    float2 xy = vScreenPos.xy;

	// add viewport offset.
    xy += viewport.xy;

	// scale by viewport to put in 0 to 1
    xy /= viewport.zw;

	// shift and scale to put in -1 to 1. y is also being flipped.
    xy.x = (2 * xy.x) + 1;
    xy.y = 1 - (2 * xy.y);

    float4 pos = mul(invViewProj, float4(xy.x, xy.y, vScreenPos.z, 1));
	//float4 pos = float4(xy.x, xy.y, 1, 1);
	//pos *= sv_pos.w;

    return pos.xyz / pos.w;
}





#ifndef TAIL_SHADING

float4 TressFXTailColor(float2 pixelCoord, float depth, float4 vTangentCoverage, float3 baseColor)
{

    return float4(baseColor, vTangentCoverage.w);
}
#define TAIL_SHADING TressFXTailColor

#endif


Texture2D ResolvedSceneDepthTexture;

void UpdateNearestSample(float Z, float2 UV, float FullResZ, inout float MinDist, inout float2 NearestUV)
{
    float DepthDelta = abs(Z - FullResZ);

    FLATTEN
    if (DepthDelta < MinDist)
    {
        MinDist = DepthDelta;
        NearestUV = UV;
    }
}

float2 CalculateNearestResolvedDepthScreenUV(float2 ScreenUV, float SceneDepth)
{
    float2 EffectiveScreenUV = ScreenUV;

    if (View.NumSceneColorMSAASamples > 1)
    {
        int2 IntScreenUV = int2(trunc(ScreenUV * View.BufferSizeAndInvSize.xy));

        float DeferredShadowingDepth = ConvertFromDeviceZ(ResolvedSceneDepthTexture.Load(int3(IntScreenUV, 0)).r);
        float RelativeDepthThreshold = .01f;

		// Fragment depth doesn't match what we used for deferred shadowing, search neighbors in cross pattern
		// Even with this nearest depth upsampling there can be edge artifacts from deferred shadowing, 
		// Since depth testing and stencil testing used during shadow projection are done per-sample and we're fetching from the resolved light attenuation
        if (abs(DeferredShadowingDepth - SceneDepth) / SceneDepth > RelativeDepthThreshold)
        {
            float2 TexelSize = View.BufferSizeAndInvSize.zw;
            float MinDist = 1.e8f;

            float2 LeftUV = ScreenUV + float2(-TexelSize.x, 0);
            float LeftDepth = ConvertFromDeviceZ(ResolvedSceneDepthTexture.Load(int3(IntScreenUV.x - 1, IntScreenUV.y, 0)).r);
            UpdateNearestSample(LeftDepth, LeftUV, SceneDepth, MinDist, EffectiveScreenUV);

            float2 UpUV = ScreenUV + float2(0, TexelSize.y);
            float UpDepth = ConvertFromDeviceZ(ResolvedSceneDepthTexture.Load(int3(IntScreenUV.x, IntScreenUV.y + 1, 0)).r);
            UpdateNearestSample(UpDepth, UpUV, SceneDepth, MinDist, EffectiveScreenUV);

            float2 RightUV = ScreenUV + float2(TexelSize.x, 0);
            float RightDepth = ConvertFromDeviceZ(ResolvedSceneDepthTexture.Load(int3(IntScreenUV.x + 1, IntScreenUV.y, 0)).r);
            UpdateNearestSample(RightDepth, RightUV, SceneDepth, MinDist, EffectiveScreenUV);

            float2 BottomUV = ScreenUV + float2(0, -TexelSize.y);
            float BottomDepth = ConvertFromDeviceZ(ResolvedSceneDepthTexture.Load(int3(IntScreenUV.x, IntScreenUV.y - 1, 0)).r);
            UpdateNearestSample(BottomDepth, BottomUV, SceneDepth, MinDist, EffectiveScreenUV);
        }
    }

    return EffectiveScreenUV;
}

float4 GetForwardDynamicShadowFactors(float2 ScreenUV)
{
    return GetPerPixelLightAttenuation(ScreenUV);
}

float4 UnpackShadowMapChannelMask(uint ShadowMapChannelMaskPacked)
{
    return float4((ShadowMapChannelMaskPacked & 1) ? 1.0f : 0.0f, (ShadowMapChannelMaskPacked & 2) ? 1.0f : 0.0f, (ShadowMapChannelMaskPacked & 4) ? 1.0f : 0.0f, (ShadowMapChannelMaskPacked & 8) ? 1.0f : 0.0f);
}

Texture2D IndirectOcclusionTexture;
SamplerState IndirectOcclusionTextureSampler;

float GetIndirectOcclusion(float2 ScreenUV, FGBufferData GBufferData)
{
    float IndirectOcclusion;
#if SUPPORTS_INDEPENDENT_SAMPLERS
	IndirectOcclusion = Texture2DSampleLevel(IndirectOcclusionTexture, LightAttenuationTextureSampler, ScreenUV, 0).x;
#else
    IndirectOcclusion = Texture2DSampleLevel(IndirectOcclusionTexture, IndirectOcclusionTextureSampler, ScreenUV, 0).x;
#endif

	// Reduce self shadowing intensity on characters (reuse distance field bit, really should be HasCapsuleShadowRepresentation)
    IndirectOcclusion = lerp(1, IndirectOcclusion, HasDynamicIndirectShadowCasterRepresentation(GBufferData) ? View.IndirectCapsuleSelfShadowingIntensity : 1);

    return IndirectOcclusion;
}

float3 GetForwardDirectLighting(uint GridIndex, float3 WorldPosition, float3 CameraVector, FGBufferData GBufferData, float2 ScreenUV, uint EyeIndex)
{
    float4 DynamicShadowFactors = 1;

    DynamicShadowFactors = GetForwardDynamicShadowFactors(ScreenUV);


    float3 DirectLighting = 0;

	// Prevent 0 Roughness which causes NaNs in Vis_SmithJointApprox
    float SpecularScale = 1;

#if TRANSLUCENCY_ANY_VOLUMETRIC
	// No specular on volumetric translucency lighting modes
    float SpecularScale = 0;
#endif

    BRANCH
    if (ForwardLightData.HasDirectionalLight)
    {
        FDeferredLightData LightData = (FDeferredLightData) 0;
        LightData.LightColorAndFalloffExponent = float4(ForwardLightData.DirectionalLightColor, 0);
        LightData.LightDirection = ForwardLightData.DirectionalLightDirection;
        LightData.DistanceFadeMAD = ForwardLightData.DirectionalLightDistanceFadeMAD;
        LightData.bRadialLight = false;
        LightData.SpecularScale = SpecularScale;

        LightData.ShadowedBits = (ForwardLightData.DirectionalLightShadowMapChannelMask & 0xFF) != 0 ? 1 : 0;
			// Static shadowing uses ShadowMapChannel, dynamic shadows are packed into light attenuation using PreviewShadowMapChannel
        LightData.ShadowMapChannelMask = UnpackShadowMapChannelMask(ForwardLightData.DirectionalLightShadowMapChannelMask);
        float4 PreviewShadowMapChannelMask = UnpackShadowMapChannelMask(ForwardLightData.DirectionalLightShadowMapChannelMask >> 4);
        float DynamicShadowing = dot(PreviewShadowMapChannelMask, DynamicShadowFactors);

			// In the forward shading path we can't separate per-object shadows from CSM, since we only spend one light attenuation channel per light
			// If CSM is enabled (distance fading to precomputed shadowing is active), treat all of our dynamic shadowing as whole scene shadows that will be faded out at the max CSM distance
			// If CSM is not enabled, allow our dynamic shadowing to coexist with precomputed shadowing
        float PerObjectShadowing = LightData.DistanceFadeMAD.y < 0.0f ? 1.0f : DynamicShadowing;
        float WholeSceneShadowing = LightData.DistanceFadeMAD.y < 0.0f ? DynamicShadowing : 1.0f;

        float4 LightAttenuation = float4(WholeSceneShadowing.xx, PerObjectShadowing.xx);
        float3 NewLighting = GetDynamicLighting(WorldPosition, -CameraVector, GBufferData, 1, GBufferData.ShadingModelID, LightData, LightAttenuation, 0.5, uint2(0, 0)).xyz;

	
        DirectLighting += NewLighting;
				
    }

    const FCulledLightsGridData CulledLightsGrid = GetCulledLightsGrid(GridIndex, EyeIndex);

    LOOP
    for (uint LocalLightListIndex = 0; LocalLightListIndex < CulledLightsGrid.NumLocalLights; LocalLightListIndex++)
    {
        const FLocalLightData LocalLight = GetLocalLightData(CulledLightsGrid.DataStartIndex + LocalLightListIndex, EyeIndex);

        FDeferredLightData LightData = (FDeferredLightData) 0;
        LightData.LightPositionAndInvRadius = LocalLight.LightPositionAndInvRadius;
        LightData.LightColorAndFalloffExponent = LocalLight.LightColorAndFalloffExponent;
        LightData.LightDirection = LocalLight.LightDirectionAndShadowMask.xyz;
        float SourceLength = f16tof32(asuint(LocalLight.SpotAnglesAndSourceRadiusPacked.w));
        LightData.SpotAnglesAndSourceRadius = float4(LocalLight.SpotAnglesAndSourceRadiusPacked.xyz, SourceLength);
        LightData.bInverseSquared = LightData.LightColorAndFalloffExponent.w == 0;
        LightData.bRadialLight = true;
        LightData.bSpotLight = LightData.SpotAnglesAndSourceRadius.x > -2.0f;
        LightData.SpecularScale = SpecularScale;

        uint PackedShadowMapChannelMask = asuint(LocalLight.LightDirectionAndShadowMask.w);
        LightData.ShadowedBits = (PackedShadowMapChannelMask & 0xFF) != 0 ? 1 : 0;
			// Static shadowing uses ShadowMapChannel, dynamic shadows are packed into light attenuation using PreviewShadowMapChannel
        LightData.ShadowMapChannelMask = UnpackShadowMapChannelMask(PackedShadowMapChannelMask);
        float4 PreviewShadowMapChannelMask = UnpackShadowMapChannelMask(PackedShadowMapChannelMask >> 4);
        float DynamicShadowing = dot(PreviewShadowMapChannelMask, DynamicShadowFactors);
        float4 LightAttenuation = float4(1, 1, DynamicShadowing.x, DynamicShadowing.x);
        float3 NewLighting = GetDynamicLighting(WorldPosition, -CameraVector, GBufferData, 1, GBufferData.ShadingModelID, LightData, LightAttenuation, 0.5, uint2(0, 0)).xyz;

	
        DirectLighting += NewLighting;
				
    }

	// For debugging
	//DirectLighting = CulledLightsGrid.NumLocalLights / (float)ForwardLightData.MaxCulledLightsPerCell;
    return DirectLighting;
}

float3 GetForwardDirectLightingForVertexLighting(uint GridIndex, float3 WorldPosition, float3 WorldNormal, uint EyeIndex)
{
    float3 DirectLighting = 0;
	// Using white for diffuse color, real diffuse color will be incorporated per-pixel
    float3 DiffuseColor = 1.0f;

    BRANCH

    if (ForwardLightData.HasDirectionalLight)
    {
        float3 N = WorldNormal;
        float3 L = ForwardLightData.DirectionalLightDirection;
        float NoL = saturate(dot(N, L));

        float3 LightColor = ForwardLightData.DirectionalLightColor;

#if NON_DIRECTIONAL_DIRECT_LIGHTING
			NoL = 1.0f;
#endif

			// No specular for vertex lighting
        float3 DiffuseLighting = Diffuse_Lambert(DiffuseColor);
        DirectLighting += LightColor * NoL * (DiffuseLighting);
    }

    const FCulledLightsGridData CulledLightsGrid = GetCulledLightsGrid(GridIndex, EyeIndex);

    LOOP
    for (uint LocalLightListIndex = 0; LocalLightListIndex < CulledLightsGrid.NumLocalLights; LocalLightListIndex++)
    {
        const FLocalLightData LocalLight = GetLocalLightData(CulledLightsGrid.DataStartIndex + LocalLightListIndex, EyeIndex);

        FSimpleDeferredLightData LightData = (FSimpleDeferredLightData) 0;
        LightData.LightPositionAndInvRadius = LocalLight.LightPositionAndInvRadius;
        LightData.LightColorAndFalloffExponent = LocalLight.LightColorAndFalloffExponent;
        LightData.bInverseSquared = LightData.LightColorAndFalloffExponent.w == 0;

			// No specular for vertex lighting
        float3 CameraVector = 0;
        float3 SpecularColor = 0;
        float Roughness = 1.0f;
        DirectLighting += GetSimpleDynamicLighting(WorldPosition, CameraVector, WorldNormal, 1, DiffuseColor, SpecularColor, Roughness, LightData);
    }

    return DirectLighting;
}


/*float4 TressFXHeadColor(float2 pixelCoord, float depth, float4 vTangentCoverage, float3 baseColor, float4 vGbuffer)
{
	return float4(baseColor, vTangentCoverage.w);

}*/
//#define HEAD_SHADING TressFXHeadColor


#define BRIGHT_OUTSIDE_FRUSTUM 1

bool FrustumCheck(float3 vPositionSM)
{
#if BRIGHT_OUTSIDE_FRUSTUM
    if (max(vPositionSM.x, vPositionSM.y) > 1.)
    {
        return false;
    }
    if (min(vPositionSM.x, vPositionSM.y) < 0.)
    {
        return false;
    }
    if (vPositionSM.z > 1.)
    {
        return false;
    }
    if (vPositionSM.z < 0.)
    {
        return false;
    }
#endif
    return true;
}

float GetWSDepth_D3D(float depthNDC, float fNear, float fFar)
{
    return fNear * fFar / (fFar - depthNDC * (fFar - fNear));
}


float3 ComputeShadowUV(float3 WorldPosition, uint CascadeIndex)
{
    float4 HomogeneousShadowPosition = mul(float4(WorldPosition, 1), ForwardLightData.DirectionalLightWorldToShadowMatrix[CascadeIndex]);
    float3 ShadowUVs = HomogeneousShadowPosition.xyz / HomogeneousShadowPosition.w;

    return ShadowUVs;
}

//=================================================================
// Shadow map sampling with 28 tap poisson kernel (each Poisson tap 
// is a 2x2 PCF kernel). This gives 140 shades of gray.
//=================================================================
float ComputeShadowHair(float3 vPositionWS, HairShadeParams params, float CascadeIndex)
{
    const float2 vPoisson[11] =
    {
        float2(0, 0),
		float2((0.079928 - 0.5) * 2, (0.995178 - 0.5) * 2),
		float2((0.120334 - 0.5) * 2, (0.710807 - 0.5) * 2),
		float2((0.186102 - 0.5) * 2, (0.400647 - 0.5) * 2),
		float2((0.386639 - 0.5) * 2, (0.992065 - 0.5) * 2),
		float2((0.448134 - 0.5) * 2, (0.469771 - 0.5) * 2),
		float2((0.620014 - 0.5) * 2, (0.666311 - 0.5) * 2),
		float2((0.719260 - 0.5) * 2, (0.385296 - 0.5) * 2),
		float2((0.720695 - 0.5) * 2, (0.990722 - 0.5) * 2),
		float2((0.888516 - 0.5) * 2, (0.187658 - 0.5) * 2),
		float2((0.890286 - 0.5) * 2, (0.591052 - 0.5) * 2)
    };
    float fRadius = params.fRadius;
    float3 vPositionSM = ComputeShadowUV(vPositionWS, CascadeIndex);
    if (!FrustumCheck(vPositionSM))
        return 1.0;

    float2 vTexelSize = 1.0 / float2(6144, 2048); //vShadowMapDimensions.xy;

    float fNear = 1.f;
    float fFar = 1000000.f; //ShadowParams[int(nSMIndex)].w;
    float fDepthFragment = GetWSDepth_D3D(vPositionSM.z, fNear, fFar);


    float fShadow = 0;

    float fTotalWeight = 0;

    for (int iSample = 0; iSample < 11; ++iSample)
    {

        float fWeight = 1.0;

        float fDepthSM_NDC = Texture2DSampleLevel(ForwardLightData.DirectionalLightShadowmapAtlas, ForwardLightData.ShadowmapSampler, vPositionSM.xy + (vTexelSize * vPoisson[iSample] * fRadius.xx), 0).x;
		//tShadowMap.SampleLevel(sPointBorder, float3(vPositionSM.xy + (vTexelSize * vPoisson[iSample] * fRadius.xx), nSMIndex), 0);
        float fDepthSM = GetWSDepth_D3D(fDepthSM_NDC, fNear, fFar);
        float fDeltaDepth = max(0, fDepthFragment - fDepthSM);

        fShadow += ComputeShadowAttenuation(fDeltaDepth, params) * fWeight;

        fTotalWeight += fWeight;
    }
    return fShadow / fTotalWeight;

}




float3 AccumulateHairLight(uint GridIndex, float3 WorldPosition, float3 vViewWS, float3 vTangent, HairShadeParams params, float2 ScreenUV, float SceneDepth, uint EyeIndex, out float4 Debug)
{
    Debug = float4(1, 0, 0, 1);

    float4 DynamicShadowFactors = 1;

	//#if MATERIALBLENDING_SOLID || MATERIALBLENDING_MASKED
    DynamicShadowFactors = GetForwardDynamicShadowFactors(ScreenUV);

    float3 DirectLighting = 0;

	// Prevent 0 Roughness which causes NaNs in Vis_SmithJointApprox
    float SpecularScale = 1;

#if TRANSLUCENCY_ANY_VOLUMETRIC
	// No specular on volumetric translucency lighting modes
	SpecularScale = 0.0f;
#endif	

    float3 color = float3(0, 0, 0);
    float3 V = normalize(vViewWS);
    float3 T = normalize(vTangent);
    float fLightScale = 1;

    BRANCH
    if (ForwardLightData.HasDirectionalLight)
    {
        FDeferredLightData LightData = (FDeferredLightData) 0;
        LightData.LightColorAndFalloffExponent = float4(ForwardLightData.DirectionalLightColor, 0);
        LightData.LightDirection = ForwardLightData.DirectionalLightDirection;
        LightData.DistanceFadeMAD = ForwardLightData.DirectionalLightDistanceFadeMAD;
        LightData.bRadialLight = false;
        LightData.SpecularScale = SpecularScale;

        LightData.ShadowedBits = (ForwardLightData.DirectionalLightShadowMapChannelMask & 0xFF) != 0 ? 1 : 0;
			// Static shadowing uses ShadowMapChannel, dynamic shadows are packed into light attenuation using PreviewShadowMapChannel
        LightData.ShadowMapChannelMask = UnpackShadowMapChannelMask(ForwardLightData.DirectionalLightShadowMapChannelMask);
        float4 PreviewShadowMapChannelMask = UnpackShadowMapChannelMask(ForwardLightData.DirectionalLightShadowMapChannelMask >> 4);
        float DynamicShadowing = dot(PreviewShadowMapChannelMask, DynamicShadowFactors);

			// In the forward shading path we can't separate per-object shadows from CSM, since we only spend one light attenuation channel per light
			// If CSM is enabled (distance fading to precomputed shadowing is active), treat all of our dynamic shadowing as whole scene shadows that will be faded out at the max CSM distance
			// If CSM is not enabled, allow our dynamic shadowing to coexist with precomputed shadowing
        float PerObjectShadowing = LightData.DistanceFadeMAD.y < 0.0f ? 1.0f : DynamicShadowing;
        float WholeSceneShadowing = LightData.DistanceFadeMAD.y < 0.0f ? DynamicShadowing : 1.0f;

        float4 LightAttenuation = float4(WholeSceneShadowing.xx, PerObjectShadowing.xx);

			// spec vs diffuse through the light.
        float lightEmitsDiffuse = 1;
        float lightEmitsSpecular = 1;
        float3 cLightColor = LightData.LightColorAndFalloffExponent.rgb;
			// if we get zero, we can save the BRDF eval, which is costly.
        float fShadowTerm = 1.f; //ComputeLightShadow(nLightID, vPositionWS);

									 //float ShadowFactor = ComputeStaticShadowing(WorldPosition);

        if (ForwardLightData.NumDirectionalLightCascades > 0)
        {
            uint CascadeIndex = ForwardLightData.NumDirectionalLightCascades;

            for (uint TestCascadeIndex = 0; TestCascadeIndex < ForwardLightData.NumDirectionalLightCascades; TestCascadeIndex++)
            {
                if (SceneDepth < ForwardLightData.CascadeEndDepths[TestCascadeIndex])
                {
                    CascadeIndex = TestCascadeIndex;
                    break;
                }
            }

            if (CascadeIndex < ForwardLightData.NumDirectionalLightCascades)
            {
					// Transform the world position into shadowmap space
                float4 HomogeneousShadowPosition = mul(float4(WorldPosition, 1), ForwardLightData.DirectionalLightWorldToShadowMatrix[CascadeIndex]);
                float2 ShadowUVs = HomogeneousShadowPosition.xy / HomogeneousShadowPosition.w;
                float4 ShadowmapMinMax = ForwardLightData.DirectionalLightShadowmapMinMax[CascadeIndex];

					// Treat as unshadowed if the voxel is outside of the shadow map
                if (all(ShadowUVs >= ShadowmapMinMax.xy && ShadowUVs <= ShadowmapMinMax.zw))
                {
						// Sample the shadowmap depth and determine if this voxel is shadowed
						//float ShadowDepth = Texture2DSampleLevel(ForwardLightData.DirectionalLightShadowmapAtlas, ForwardLightData.ShadowmapSampler, ShadowUVs, 0).x;
						//Debug.x = ShadowDepth;
                    fShadowTerm = ComputeShadowHair(WorldPosition, params, CascadeIndex); //ComputeHairShadowAttenuation(ShadowDepth);
																							  //HomogeneousShadowPosition.z < ShadowDepth - ForwardLightData.DirectionalLightDepthBias.x;
                }
            }
        }

        if (fShadowTerm > 0.00001)
        {
            float3 L = normalize(LightData.LightDirection);

            float3 reflection = TressFX_ComputeDiffuseSpecFactors(V, L, T);

            float3 cReflectedLight = reflection.x * cLightColor * lightEmitsDiffuse * params.cColor;
            cReflectedLight += reflection.y * cLightColor * lightEmitsSpecular;
            cReflectedLight += reflection.z * cLightColor * lightEmitsSpecular * params.cColor;
            cReflectedLight *= fShadowTerm * fLightScale; // * 0.16;
															  //color = float3(1, 1, 1);
            color = max(float3(0, 0, 0), cReflectedLight);

        }

			//color = float3(1, 1, 1);


        float3 NewLighting = color;

			//float3 NewLighting = GetDynamicLighting(WorldPosition, -CameraVector, GBufferData, 1, GBufferData.ShadingModelID, LightData, LightAttenuation, uint2(0, 0)).xyz;


			//float3 NewLighting = GetDynamicLighting(WorldPosition, -CameraVector, GBufferData, 1, GBufferData.ShadingModelID, LightData, LightAttenuation, uint2(0, 0)).xyz;

			//FLATTEN
			//	if ((ForwardLightData.DirectionalLightShadowMapChannelMask >> 8) & Primitive.LightingChannelMask)
			//	{
        DirectLighting += NewLighting;
			//	}
    }


	/*
	const CulledLightsGridData CulledLightsGrid = GetCulledLightsGrid(GridIndex, EyeIndex);

	LOOP
	for (uint LocalLightListIndex = 0; LocalLightListIndex < CulledLightsGrid.NumLocalLights; LocalLightListIndex++)
	{
	const LocalLightData LocalLight = GetLocalLightData(CulledLightsGrid.DataStartIndex + LocalLightListIndex, EyeIndex);

	FDeferredLightData LightData = (FDeferredLightData) 0;
	LightData.LightPositionAndInvRadius = LocalLight.LightPositionAndInvRadius;
	LightData.LightColorAndFalloffExponent = LocalLight.LightColorAndFalloffExponent;
	LightData.LightDirection = LocalLight.LightDirectionAndShadowMask.xyz;
	LightData.SpotAnglesAndSourceRadius = LocalLight.SpotAnglesAndSourceRadius;
	LightData.bInverseSquared = LightData.LightColorAndFalloffExponent.w == 0;
	LightData.bRadialLight = true;
	LightData.bSpotLight = LightData.SpotAnglesAndSourceRadius.x > -2.0f;
	LightData.MinRoughness = MinRoughness;

	uint PackedShadowMapChannelMask = asuint(LocalLight.LightDirectionAndShadowMask.w);
	LightData.ShadowedBits = (PackedShadowMapChannelMask & 0xFF) != 0 ? 1 : 0;
	// Static shadowing uses ShadowMapChannel, dynamic shadows are packed into light attenuation using PreviewShadowMapChannel
	LightData.ShadowMapChannelMask = UnpackShadowMapChannelMask(PackedShadowMapChannelMask);
	float4 PreviewShadowMapChannelMask = UnpackShadowMapChannelMask(PackedShadowMapChannelMask >> 4);
	float DynamicShadowing = dot(PreviewShadowMapChannelMask, DynamicShadowFactors);
	float4 LightAttenuation = float4(1, 1, DynamicShadowing.x, DynamicShadowing.x);

	// yes, I know this seems weird - but it's basically a way to control
	// spec vs diffuse through the light.
	float lightEmitsDiffuse = 1;
	float lightEmitsSpecular = 1;
	float3 cLightColor = LightData.LightColorAndFalloffExponent.rgb;
	// if we get zero, we can save the BRDF eval, which is costly.
	float fShadowTerm = 1.f;//ComputeLightShadow(nLightID, vPositionWS);

	if (fShadowTerm > 0.00001)
	{
	float3 L = normalize(LightData.LightDirection);

	float3 reflection = TressFX_ComputeDiffuseSpecFactors(V, L, T);

	float3 cReflectedLight = reflection.x * cLightColor * lightEmitsDiffuse * params.cColor;
	cReflectedLight += reflection.y * cLightColor * lightEmitsSpecular;
	cReflectedLight += reflection.z * cLightColor * lightEmitsSpecular * params.cColor;
	cReflectedLight *= fShadowTerm * fLightScale; // * 0.16;

	color += max(float3(0, 0, 0), cReflectedLight);

	}

	float3 NewLighting = color;

	//float3 NewLighting = GetDynamicLighting(WorldPosition, -CameraVector, GBufferData, 1, GBufferData.ShadingModelID, LightData, LightAttenuation, uint2(0, 0)).xyz;

	FLATTEN
	if ((PackedShadowMapChannelMask >> 8) & Primitive.LightingChannelMask)
	{
	DirectLighting += NewLighting;
	}
	}
	*/

	// For debugging
	//DirectLighting = CulledLightsGrid.NumLocalLights / (float)ForwardLightData.MaxCulledLightsPerCell;
    return DirectLighting;


}






#ifndef HEAD_SHADING

float4 TressFXHeadColor(float2 pixelCoord, float depth, float4 vTangentCoverage, float3 baseColor, float4 vGbuffer)
{


	//return float4(baseColor, vTangentCoverage.w);
	
    float4 color = (float4) 0;

    float4 viewport = float4(View.ViewRectMin.xy, View.ViewSizeAndInvSize.xy);
    float3 vTangent = 2.0 * vTangentCoverage.xyz - 1.0;
    float3 vNDC = ScreenToNDC(float3(pixelCoord, depth), viewport);
    float3 vPositionWS = NDCToWorld(vNDC, View.ClipToTranslatedWorld);
    float3 vViewWS = View.WorldCameraOrigin - vPositionWS;

    uint GridIndex = ComputeLightGridCellIndex((uint2) (vPositionWS.xy - ResolvedView.ViewRectMin.xy), depth, 0);

	//float3 GetForwardDirectLighting(uint GridIndex, float3 WorldPosition, float3 CameraVector, FGBufferData GBufferData, float2 ScreenUV, uint EyeIndex)

    FGBufferData GBufferData = (FGBufferData) 0;



    GBufferData.WorldNormal = vTangent;
    GBufferData.BaseColor = baseColor;
    GBufferData.ShadingModelID = 7;
    GBufferData.Roughness = vGbuffer.z;
    GBufferData.Metallic = vGbuffer.y;
    GBufferData.Specular = vGbuffer.x;
    GBufferData.Depth = depth;

	// TODO remove params, since we are using globals anyways.
    HairShadeParams params;



    params.cColor = baseColor; // GetMaterialBaseColor(PixelMaterialInputs);
    params.fRadius = g_FiberRadius;
    params.fSpacing = g_FiberSpacing;
    params.fAlpha = g_HairShadowAlpha;


    float4 Dummy;

    color = float4(AccumulateHairLight(GridIndex, vPositionWS, View.ViewForward, vTangent, params, pixelCoord, depth, 0, Dummy), vTangentCoverage.w);

	//color =float4( GetForwardDirectLighting(GridIndex, vPositionWS, vViewWS, GBufferData, pixelCoord, 0).rgb, vTangentCoverage.w);
	
    return color;

	//return float4(baseColor,1- vTangentCoverage.w);
	
}

#define HEAD_SHADING TressFXHeadColor

#endif


#define MAX_FRAGMENTS 512
#define TAIL_COMPRESS 0



#if (KBUFFER_SIZE <= 16)
#define ALU_INDEXING			// avoids using an indexed array for better performance
#endif



#ifdef ALU_INDEXING
//--------------------------------------------------------------------------------------
// 
// Helper functions for storing the k-buffer into non-indexed registers for better 
// performance. For this code to work, KBUFFER_SIZE must be <= 16.
//
//--------------------------------------------------------------------------------------

uint GetUintFromIndex_Size16(uint4 V03, uint4 V47, uint4 V811, uint4 V1215, uint uIndex)
{
    uint u;
    u = uIndex == 1 ? V03.y : V03.x;
    u = uIndex == 2 ? V03.z : u;
    u = uIndex == 3 ? V03.w : u;
    u = uIndex == 4 ? V47.x : u;
    u = uIndex == 5 ? V47.y : u;
    u = uIndex == 6 ? V47.z : u;
    u = uIndex == 7 ? V47.w : u;
    u = uIndex == 8 ? V811.x : u;
    u = uIndex == 9 ? V811.y : u;
    u = uIndex == 10 ? V811.z : u;
    u = uIndex == 11 ? V811.w : u;
    u = uIndex == 12 ? V1215.x : u;
    u = uIndex == 13 ? V1215.y : u;
    u = uIndex == 14 ? V1215.z : u;
    u = uIndex == 15 ? V1215.w : u;
    return u;
}

void StoreUintAtIndex_Size16(inout uint4 V03, inout uint4 V47, inout uint4 V811, inout uint4 V1215, uint uIndex, uint uValue)
{
    V03.x = (uIndex == 0) ? uValue : V03.x;
    V03.y = (uIndex == 1) ? uValue : V03.y;
    V03.z = (uIndex == 2) ? uValue : V03.z;
    V03.w = (uIndex == 3) ? uValue : V03.w;
    V47.x = (uIndex == 4) ? uValue : V47.x;
    V47.y = (uIndex == 5) ? uValue : V47.y;
    V47.z = (uIndex == 6) ? uValue : V47.z;
    V47.w = (uIndex == 7) ? uValue : V47.w;
    V811.x = (uIndex == 8) ? uValue : V811.x;
    V811.y = (uIndex == 9) ? uValue : V811.y;
    V811.z = (uIndex == 10) ? uValue : V811.z;
    V811.w = (uIndex == 11) ? uValue : V811.w;
    V1215.x = (uIndex == 12) ? uValue : V1215.x;
    V1215.y = (uIndex == 13) ? uValue : V1215.y;
    V1215.z = (uIndex == 14) ? uValue : V1215.z;
    V1215.w = (uIndex == 15) ? uValue : V1215.w;
}


#define GET_DEPTH_AT_INDEX(uIndex) GetUintFromIndex_Size16(kBufferDepthV03, kBufferDepthV47, kBufferDepthV811, kBufferDepthV1215, uIndex)
#define GET_DATA_AT_INDEX( uIndex) GetUintFromIndex_Size16(kBufferDataV03, kBufferDataV47, kBufferDataV811, kBufferDataV1215, uIndex)
#define GET_COLOR_AT_INDEX( uIndex) GetUintFromIndex_Size16(kBufferStrandColorV03, kBufferStrandColorV47, kBufferStrandColorV811, kBufferStrandColorV1215, uIndex)
#define GET_GBUFFER_AT_INDEX(uIndex) GetUintFromIndex_Size16(kBufferGBufferV03, kBufferGBufferV47, kBufferGBufferV811, kBufferGBufferV1215,uIndex)
#define STORE_DEPTH_AT_INDEX(uIndex, uValue) StoreUintAtIndex_Size16(kBufferDepthV03, kBufferDepthV47, kBufferDepthV811, kBufferDepthV1215, uIndex, uValue)
#define STORE_DATA_AT_INDEX(uIndex, uValue) StoreUintAtIndex_Size16(kBufferDataV03, kBufferDataV47, kBufferDataV811, kBufferDataV1215, uIndex, uValue)
#define STORE_COLOR_AT_INDEX(uIndex, uValue) StoreUintAtIndex_Size16(kBufferStrandColorV03, kBufferStrandColorV47, kBufferStrandColorV811, kBufferStrandColorV1215, uIndex, uValue)
#define STORE_GBUFFER_AT_INDEX(uIndex, uValue) StoreUintAtIndex_Size16(kBufferGBufferV03, kBufferGBufferV47, kBufferGBufferV811, kBufferGBufferV1215,uIndex,uValue)
#else

//#define GET_DEPTH_AT_INDEX(uIndex) kBuffer[uIndex].depth
//#define GET_DATA_AT_INDEX(uIndex) kBuffer[uIndex].data
//#define STORE_DEPTH_AT_INDEX(uIndex, uValue) kBuffer[uIndex].depth = uValue
//#define STORE_DATA_AT_INDEX( uIndex, uValue) kBuffer[uIndex].data = uValue
#define GET_DEPTH_AT_INDEX(uIndex) kBuffer[uIndex].x
#define GET_DATA_AT_INDEX(uIndex) kBuffer[uIndex].y
#define STORE_DEPTH_AT_INDEX(uIndex, uValue) kBuffer[uIndex].x = uValue
#define STORE_DATA_AT_INDEX( uIndex, uValue) kBuffer[uIndex].y = uValue

#endif


#define NODE_DATA(x) LinkedListSRV[x].data
#define NODE_NEXT(x) LinkedListSRV[x].uNext
#define NODE_DEPTH(x) LinkedListSRV[x].depth
#define NODE_COLOR(x) LinkedListSRV[x].color
#define NODE_GBUFFER(x) LinkedListSRV[x].Gbuffer



Texture2D<uint> tFragmentListHead;
StructuredBuffer<PPLL_STRUCT> LinkedListSRV;



float4 UnpackUintIntoFloat4(uint uValue)
{
    return float4(((uValue & 0xFF000000) >> 24) / 255.0, ((uValue & 0x00FF0000) >> 16) / 255.0, ((uValue & 0x0000FF00) >> 8) / 255.0, ((uValue & 0x000000FF)) / 255.0);
}

float4 ExtractHairColor(float2 pixelCoord, float depth, float4 data)
{
    return data;
}

float4 ExtractHairColor(float2 pixelCoord, float depth, float4 data, float4 color)
{
    return data;
}





#define KBUFFER_TYPE uint2



#define MAX_INITIAL_DEPTH -1

float4 GatherLinkedList(float2 vfScreenAddress)
{
    uint2 vScreenAddress = uint2(vfScreenAddress);
    uint pointer = tFragmentListHead[vScreenAddress];

    float4 outColor = float4(0, 0, 0, 1);


    if (pointer == FRAGMENT_LIST_NULL)
        discard;

	ASSERT(pointer >= 0 && pointer < FRAGMENT_LIST_NULL)


#ifdef ALU_INDEXING

    uint4 kBufferDepthV03, kBufferDepthV47, kBufferDepthV811, kBufferDepthV1215;
    uint4 kBufferDataV03, kBufferDataV47, kBufferDataV811, kBufferDataV1215;
    uint4 kBufferStrandColorV03, kBufferStrandColorV47, kBufferStrandColorV811, kBufferStrandColorV1215;
    uint4 kBufferGBufferV03, kBufferGBufferV47, kBufferGBufferV811, kBufferGBufferV1215;
    kBufferDepthV03 = uint4(asuint(MAX_INITIAL_DEPTH), asuint(MAX_INITIAL_DEPTH), asuint(MAX_INITIAL_DEPTH), asuint(MAX_INITIAL_DEPTH));
    kBufferDepthV47 = uint4(asuint(MAX_INITIAL_DEPTH), asuint(MAX_INITIAL_DEPTH), asuint(MAX_INITIAL_DEPTH), asuint(MAX_INITIAL_DEPTH));
    kBufferDepthV811 = uint4(asuint(MAX_INITIAL_DEPTH), asuint(MAX_INITIAL_DEPTH), asuint(MAX_INITIAL_DEPTH), asuint(MAX_INITIAL_DEPTH));
    kBufferDepthV1215 = uint4(asuint(MAX_INITIAL_DEPTH), asuint(MAX_INITIAL_DEPTH), asuint(MAX_INITIAL_DEPTH), asuint(MAX_INITIAL_DEPTH));
	//kBufferDepthV03 = uint4(asuint(0.0f), asuint(0.0f), asuint(0.0f), asuint(0.0f));
	//kBufferDepthV47 = uint4(asuint(0.0f), asuint(0.0f), asuint(0.0f), asuint(0.0f));
	//kBufferDepthV811 = uint4(asuint(0.0f), asuint(0.0f), asuint(0.0f), asuint(0.0f));
	//kBufferDepthV1215 = uint4(asuint(0.0f), asuint(0.0f), asuint(0.0f), asuint(0.0f));
    kBufferDataV03 = uint4(0, 0, 0, 0);
    kBufferDataV47 = uint4(0, 0, 0, 0);
    kBufferDataV811 = uint4(0, 0, 0, 0);
    kBufferDataV1215 = uint4(0, 0, 0, 0);
    kBufferStrandColorV03 = uint4(0, 0, 0, 0);
    kBufferStrandColorV47 = uint4(0, 0, 0, 0);
    kBufferStrandColorV811 = uint4(0, 0, 0, 0);
    kBufferStrandColorV1215 = uint4(0, 0, 0, 0);
    kBufferGBufferV03 = uint4(0, 0, 0, 0);
    kBufferGBufferV47 = uint4(0, 0, 0, 0);
    kBufferGBufferV811 = uint4(0, 0, 0, 0);
    kBufferGBufferV1215 = uint4(0, 0, 0, 0);

#else

		KBUFFER_TYPE kBuffer[KBUFFER_SIZE];

	[unroll]
	for (int t = 0; t < KBUFFER_SIZE; ++t)
	{
		//kBuffer[t].y = 0;
		//kBuffer[t].x = asuint(100000.0);
		STORE_DEPTH_AT_INDEX(t, asuint(100000.0));
		STORE_DATA_AT_INDEX(t, 0);
		//compile error 
	}
#endif
    int nNumFragments = 0;
	// Get first K elements.
    for (int p = 0; p < KBUFFER_SIZE; ++p)
    {
        if (pointer != FRAGMENT_LIST_NULL)
        {
			STORE_DEPTH_AT_INDEX(p, NODE_DEPTH(pointer));
			STORE_DATA_AT_INDEX(p, NODE_DATA(pointer));
			STORE_COLOR_AT_INDEX(p, NODE_COLOR(pointer));
			STORE_GBUFFER_AT_INDEX(p, NODE_GBUFFER(pointer));
            pointer = NODE_NEXT(pointer);
#ifdef COLORDEBUG
			nNumFragments++;
#endif
        }
    }

    float4 fcolor = float4(0, 0, 0, 1);

    float3 tailColor;
	[allow_uav_condition]
    for (int iFragment = 0; iFragment < MAX_FRAGMENTS && pointer != FRAGMENT_LIST_NULL; ++iFragment)
    {
        if (pointer == FRAGMENT_LIST_NULL)
            break;

#ifdef COLORDEBUG
		nNumFragments++;
#endif

        int id = 0;
        float max_depth = 1.f;

		// find the furthest node in array
        for (int i = 0; i < KBUFFER_SIZE; i++)
        {
            float fDepth = asfloat(GET_DEPTH_AT_INDEX(i));
            if (max_depth > fDepth)
            {
                max_depth = fDepth;
                id = i;
            }
        }


        uint data = NODE_DATA(pointer);
        uint color = NODE_COLOR(pointer);
        uint nodeDepth = NODE_DEPTH(pointer);
        uint packedGbuffer = NODE_GBUFFER(pointer);
        float fNodeDepth = asfloat(nodeDepth);


		// If the node in the linked list is nearer than the furthest one in the local array, exchange the node 
		// in the local array for the one in the linked list.
        if (max_depth < fNodeDepth)
        {
            uint tmp = GET_DEPTH_AT_INDEX(id);
			STORE_DEPTH_AT_INDEX(id, nodeDepth);
            fNodeDepth = asfloat(tmp);

            tmp = GET_DATA_AT_INDEX(id);
			STORE_DATA_AT_INDEX(id, data);
            data = tmp;

            tmp = GET_COLOR_AT_INDEX(id);
			STORE_COLOR_AT_INDEX(id, color);
            color = tmp;

            tmp = GET_GBUFFER_AT_INDEX(id);
			STORE_GBUFFER_AT_INDEX(id, packedGbuffer);
            packedGbuffer = tmp;


        }

        float4 vData = UnpackUintIntoFloat4(data);
#if TAIL_COMPRESS
		float4 vColor = UnpackUintIntoFloat4(color);
		fcolor.w = mad(-fcolor.w, vColor.w, fcolor.w);
#else
        float4 vColor = UnpackUintIntoFloat4(color);
        float4 fragmentColor = TAIL_SHADING(vfScreenAddress, fNodeDepth, vData, vColor.rgb);
		//fragmentColor = float4( max(float(iFragment)/255.0,255.0)/255.0, iFragment <= 255 ? float(iFragment%255) : 0, 0, 1); 
        fcolor.xyz = mad(-fcolor.xyz, fragmentColor.w, fcolor.xyz) + fragmentColor.xyz * fragmentColor.w;
        fcolor.w = mad(-fcolor.w, fragmentColor.w, fcolor.w);
#endif

        pointer = NODE_NEXT(pointer);
    }
#if TAIL_COMPRESS
	float fTailAlphaInv = fcolor.w;
	fcolor.xyzw = float4(0, 0, 0, 1);
#endif

	// Blend the k nearest layers of fragments from back to front, where k = MAX_TOP_LAYERS_EYE
    for (int j = 0; j < KBUFFER_SIZE; j++)
    {
        int id = 0;
        float max_depth = 1.f;


		// find the furthest node in the array
        for (int i = 0; i < KBUFFER_SIZE; i++)
        {
            float fDepth = asfloat(GET_DEPTH_AT_INDEX(i));
            if (max_depth > fDepth)
            {
                max_depth = fDepth;
                id = i;
            }
        }

		// take this node out of the next search
        uint nodeDepth = GET_DEPTH_AT_INDEX(id);
        uint data = GET_DATA_AT_INDEX(id);
        uint color = GET_COLOR_AT_INDEX(id);
        uint packedGbuffer = GET_GBUFFER_AT_INDEX(id);

		// take this node out of the next search
		STORE_DEPTH_AT_INDEX(id, 1.f);

		// Use high quality shading for the nearest k fragments
        float fDepth = asfloat(nodeDepth);
        float4 vData = UnpackUintIntoFloat4(data);
        float4 vColor = UnpackUintIntoFloat4(color);
        float4 unpackedGbuffer = UnpackUintIntoFloat4(packedGbuffer);




        float4 fragmentColor = HEAD_SHADING(vfScreenAddress, fDepth, vData, vColor.rgb, unpackedGbuffer);
#if TAIL_COMPRESS
		fragmentColor.w = 1 - (1 - fragmentColor.w)*fTailAlphaInv;
		//fTailAlphaInv = 1;
#endif
		// Blend the fragment color
        fcolor.xyz = mad(-fcolor.xyz, fragmentColor.w, fcolor.xyz) + fragmentColor.xyz * fragmentColor.w;
        fcolor.w = fcolor.w * (1 - fragmentColor.w); //mad(-fcolor.w, fragmentColor.w, fcolor.w);
    }

#ifdef COLORDEBUG
	fcolor.xyz = float3(0, 1, 0);
	
	if (nNumFragments>32) fcolor.xyz = float3(1, 1, 0);
	if (nNumFragments>64) fcolor.xyz = float3(1, 0.5, 0);
	if (nNumFragments>128) fcolor.xyz = float3(1, 0, 0);
#endif
	//outColor = fcolor;
	//fcolor.w = 0;


    return fcolor;
}


//[earlydepthstencil]
void PPLLGather_MainPS(FScreenVertexOutput Input,
	out float4 OutColor : SV_Target0
)
{
    OutColor = (float4) 0;
    OutColor = GatherLinkedList(Input.Position.xy);
}