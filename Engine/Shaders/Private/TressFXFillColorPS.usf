
#define OpaqueBasePass TressFXColorFillPass

#include "Common.ush"
#include "SHCommon.ush"
#include "/Engine/Generated/Material.ush"
#include "BasePassCommon.ush"
#include "/Engine/Generated/VertexFactory.ush"
#include "LightmapCommon.ush" 
#include "PlanarReflectionShared.ush"
#include "BRDF.ush"
#include "Random.ush"
#include "LightAccumulator.ush"
#include "DeferredShadingCommon.ush"
#include "VelocityCommon.ush"
#include "SphericalGaussian.ush"
#include "TressFXCommon.ush"
#include "TressFXShortCutCommon.ush"
#include "TressFXRendering.ush"
#include "ReflectionEnvironmentShared.ush"
#include "ShadowFilteringCommon.ush"

#ifndef TFX_SHORTCUT
	#define TFX_SHORTCUT 1
#endif

#ifndef TFX_PPLL
	#define TFX_PPLL 0
#endif


#ifndef ENABLE_SKY_LIGHT
	#define ENABLE_SKY_LIGHT 1
#endif

#ifndef OPTIONAL_IsFrontFace
	#define OPTIONAL_IsFrontFace
#endif


struct PS_INPUT_HAIR_AA
{
    float4 Position : SV_POSITION;
    FVertexFactoryInterpolantsVSToPS FactoryInterpolants;

};

float NormalCurvatureToRoughness(float3 WorldNormal)
{
    float3 dNdx = ddx(WorldNormal);
    float3 dNdy = ddy(WorldNormal);
    float x = dot(dNdx, dNdx);
    float y = dot(dNdy, dNdy);
    float CurvatureApprox = pow(max(x, y), View.NormalCurvatureToRoughnessScaleBias.z);
    return saturate(CurvatureApprox * View.NormalCurvatureToRoughnessScaleBias.x + View.NormalCurvatureToRoughnessScaleBias.y);
}

#if TRANSLUCENT_SELF_SHADOWING
	#include "ShadowProjectionCommon.ush"	 
#endif

#include "ShadingModelsMaterial.ush"
#if MATERIAL_SHADINGMODEL_HAIR || SIMPLE_FORWARD_DIRECTIONAL_LIGHT || MATERIAL_SHADINGMODEL_TRESSFX
#include "ShadingModels.ush"
#endif

#ifndef COMPILER_GLSL
	#define COMPILER_GLSL 0
#endif

#define FORCE_FULLY_ROUGH (SIMPLE_FORWARD_SHADING || MATERIAL_FULLY_ROUGH)
#define EDITOR_ALPHA2COVERAGE (USE_EDITOR_COMPOSITING && SUPPORTS_PIXEL_COVERAGE)
#define POST_PROCESS_SUBSURFACE ((MATERIAL_SHADINGMODEL_SUBSURFACE_PROFILE || MATERIAL_SHADINGMODEL_EYE) && USES_GBUFFER)

#include "ForwardLightingCommon.ush" 

#if !FORWARD_SHADING

void GetVolumeLightingNonDirectional(float4 AmbientLightingVector, float3 DiffuseColor, inout float3 InterpolatedLighting, out float4 VolumeLighting)
{
	// Normal is not taken into account with non directional lighting, and only the ambient term of the SH coefficients are needed
    FOneBandSHVectorRGB TranslucentLighting;
    TranslucentLighting.R.V.x = AmbientLightingVector.r;
    TranslucentLighting.G.V.x = AmbientLightingVector.g;
    TranslucentLighting.B.V.x = AmbientLightingVector.b;

    FOneBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH1(1);
    VolumeLighting = float4(DotSH1(TranslucentLighting, DiffuseTransferSH), AmbientLightingVector.a);
    InterpolatedLighting = DiffuseColor * VolumeLighting.rgb;
}

void GetVolumeLightingDirectional(float4 AmbientLightingVector, float3 DirectionalLightingVector, float3 WorldNormal, float3 DiffuseColor, inout float3 InterpolatedLighting, out float4 VolumeLighting)
{
    float DirectionalLightingIntensity = GetMaterialTranslucencyDirectionalLightingIntensity();

    AmbientLightingVector.rgb /= DirectionalLightingIntensity;
    DirectionalLightingVector.rgb *= DirectionalLightingIntensity;

	// Reconstruct the SH coefficients based on what was encoded
    FTwoBandSHVectorRGB TranslucentLighting;
    TranslucentLighting.R.V.x = AmbientLightingVector.r;
    TranslucentLighting.G.V.x = AmbientLightingVector.g;
    TranslucentLighting.B.V.x = AmbientLightingVector.b;
    float3 NormalizedAmbientColor = AmbientLightingVector.rgb / (Luminance(AmbientLightingVector.rgb) + 0.00001f);

	// Scale the monocrome directional coefficients with the normalzed ambient color as an approximation to the uncompressed values
    TranslucentLighting.R.V.yzw = DirectionalLightingVector.rgb * NormalizedAmbientColor.r;
    TranslucentLighting.G.V.yzw = DirectionalLightingVector.rgb * NormalizedAmbientColor.g;
    TranslucentLighting.B.V.yzw = DirectionalLightingVector.rgb * NormalizedAmbientColor.b;
			
	// Compute diffuse lighting which takes the normal into account
    FTwoBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH(WorldNormal, 1);
    VolumeLighting = float4(max(half3(0, 0, 0), DotSH(TranslucentLighting, DiffuseTransferSH)), AmbientLightingVector.a);
    InterpolatedLighting += DiffuseColor * VolumeLighting.rgb;
}

#endif

#if SIMPLE_FORWARD_SHADING
	#define GetEffectiveSkySHDiffuse GetSkySHDiffuseSimple
#else
	#define GetEffectiveSkySHDiffuse GetSkySHDiffuse
#endif

/** Computes sky diffuse lighting, including precomputed shadowing. */
// the following were adapted from the versions in basepasspixelshader
void GetSkyLighting(FMaterialPixelParameters MaterialParameters, float3 WorldNormal, float2 LightmapUV, float3 SkyOcclusionUV3D, out float3 OutDiffuseLighting, out float3 OutSubsurfaceLighting)
{
    OutDiffuseLighting = 0;
    OutSubsurfaceLighting = 0;

#if ENABLE_SKY_LIGHT

	float SkyVisibility = 1;
	float GeometryTerm = 1;
	float3 SkyLightingNormal = WorldNormal;
	
#if HQ_TEXTURE_LIGHTMAP || CACHED_POINT_INDIRECT_LIGHTING || CACHED_VOLUME_INDIRECT_LIGHTING || PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
		BRANCH
		if (View.SkyLightParameters.x > 0)
		{
			float3 NormalizedBentNormal = SkyLightingNormal;

#if PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
			
				float3 SkyBentNormal = GetVolumetricLightmapSkyBentNormal(SkyOcclusionUV3D);
				SkyVisibility = length(SkyBentNormal);
				NormalizedBentNormal = SkyBentNormal / max(SkyVisibility, .0001f);

#elif HQ_TEXTURE_LIGHTMAP

				// Bent normal from precomputed texture
				float4 WorldSkyBentNormalAndOcclusion = GetSkyBentNormalAndOcclusion(LightmapUV * float2(1, 2), MaterialParameters.SvPosition.xy);
				// Renormalize as vector was quantized and compressed
				NormalizedBentNormal = normalize(WorldSkyBentNormalAndOcclusion.xyz);
				SkyVisibility = WorldSkyBentNormalAndOcclusion.w;

#elif CACHED_POINT_INDIRECT_LIGHTING || CACHED_VOLUME_INDIRECT_LIGHTING

				// Bent normal from the indirect lighting cache - one value for the whole object
				if (View.IndirectLightingCacheShowFlag > 0.0f)
				{
					NormalizedBentNormal = IndirectLightingCache.PointSkyBentNormal.xyz;
					SkyVisibility = IndirectLightingCache.PointSkyBentNormal.w;
				}

#endif

#if (MATERIALBLENDING_TRANSLUCENT || MATERIALBLENDING_ADDITIVE) && (TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL || TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_NONDIRECTIONAL)
				// NonDirectional lighting can't depend on the normal
				SkyLightingNormal = NormalizedBentNormal;
#else
				
				// Weight toward the material normal to increase directionality
				float BentNormalWeightFactor = 1 - (1 - SkyVisibility) * (1 - SkyVisibility);

				// We are lerping between the inputs of two lighting scenarios based on occlusion
				// In the mostly unoccluded case, evaluate sky lighting with the material normal, because it has higher detail
				// In the mostly occluded case, evaluate sky lighting with the bent normal, because it is a better representation of the incoming lighting
				// Then treat the lighting evaluated along the bent normal as an area light, so we must apply the lambert term
				SkyLightingNormal = lerp(NormalizedBentNormal, WorldNormal, BentNormalWeightFactor);

				float DotProductFactor = lerp(saturate(dot(NormalizedBentNormal, WorldNormal)), 1, BentNormalWeightFactor);
				// Account for darkening due to the geometry term
				GeometryTerm = DotProductFactor;
#endif
		}
#endif
			
	// Compute the preconvolved incoming lighting with the bent normal direction
	float3 DiffuseLookup = GetEffectiveSkySHDiffuse(SkyLightingNormal) * ResolvedView.SkyLightColor.rgb;

	// Apply AO to the sky diffuse
	OutDiffuseLighting += DiffuseLookup * (SkyVisibility * GeometryTerm);

#if MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE
		float3 BackfaceDiffuseLookup = GetEffectiveSkySHDiffuse(-WorldNormal) * ResolvedView.SkyLightColor.rgb;
		OutSubsurfaceLighting += BackfaceDiffuseLookup * SkyVisibility;
#endif

#endif
}

#if SUPPORTS_INDEPENDENT_SAMPLERS
#define ILCSharedSampler1 View.SharedBilinearClampedSampler
#define ILCSharedSampler2 View.SharedBilinearClampedSampler
#else
#define ILCSharedSampler1 IndirectLightingCache.IndirectLightingCacheTextureSampler1
#define ILCSharedSampler2 IndirectLightingCache.IndirectLightingCacheTextureSampler2
#endif

/** Calculates indirect lighting contribution on this object from precomputed data. */
void GetPrecomputedIndirectLightingAndSkyLight(
	FMaterialPixelParameters MaterialParameters,
	FVertexFactoryInterpolantsVSToPS Interpolants,
	float3 DiffuseDir,
	float3 VolumetricLightmapBrickTextureUVs,
	out float3 OutDiffuseLighting,
	out float3 OutSubsurfaceLighting,
	out float OutIndirectIrradiance)
{
    OutIndirectIrradiance = 0;
    OutDiffuseLighting = 0;
    OutSubsurfaceLighting = 0;
    float2 SkyOcclusionUV = 0;

#if PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING

#if TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL || TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_NONDIRECTIONAL


			FOneBandSHVectorRGB IrradianceSH = GetVolumetricLightmapSH1(VolumetricLightmapBrickTextureUVs);
			FOneBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH1(1);
			OutDiffuseLighting = max(float3(0,0,0), DotSH1(IrradianceSH, DiffuseTransferSH)) / PI;

#else

			FThreeBandSHVectorRGB IrradianceSH = GetVolumetricLightmapSH3(VolumetricLightmapBrickTextureUVs);
			// Diffuse convolution
			FThreeBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH3(DiffuseDir, 1);
			OutDiffuseLighting = max(float3(0,0,0), DotSH3(IrradianceSH, DiffuseTransferSH)) / PI;

#endif


	// Method for movable components which want to use a volume texture of interpolated SH samples
#elif CACHED_VOLUME_INDIRECT_LIGHTING
		if (View.IndirectLightingCacheShowFlag > 0.0f)
		{
			// Compute volume texture UVs from world position
			float3 VolumeUVs = MaterialParameters.AbsoluteWorldPosition * IndirectLightingCache.IndirectLightingCachePrimitiveScale + IndirectLightingCache.IndirectLightingCachePrimitiveAdd;
			// Clamp UV to be within the valid region
			// Pixels outside of the object's bounding box would read garbage otherwise
			VolumeUVs = clamp(VolumeUVs, IndirectLightingCache.IndirectLightingCacheMinUV, IndirectLightingCache.IndirectLightingCacheMaxUV);
			float4 Vector0 = Texture3DSample(IndirectLightingCache.IndirectLightingCacheTexture0, IndirectLightingCache.IndirectLightingCacheTextureSampler0, VolumeUVs);

			// For debugging
#define AMBIENTONLY 0
#if AMBIENTONLY

				OutDiffuseLighting = Vector0.rgb / SHAmbientFunction() / PI;

#else

				float4 Vector1 = Texture3DSample(IndirectLightingCache.IndirectLightingCacheTexture1, ILCSharedSampler1, VolumeUVs);
				float4 Vector2 = Texture3DSample(IndirectLightingCache.IndirectLightingCacheTexture2, ILCSharedSampler2, VolumeUVs);

				// Construct the SH environment
				FTwoBandSHVectorRGB CachedSH;
				CachedSH.R.V = float4(Vector0.x, Vector1.x, Vector2.x, Vector0.w);
				CachedSH.G.V = float4(Vector0.y, Vector1.y, Vector2.y, Vector1.w);
				CachedSH.B.V = float4(Vector0.z, Vector1.z, Vector2.z, Vector2.w);

				// Diffuse convolution
				FTwoBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH(DiffuseDir, 1);
				OutDiffuseLighting = max(half3(0,0,0), DotSH(CachedSH, DiffuseTransferSH)) / PI;

#endif
		}

	// Method for movable components which want to use a single interpolated SH sample
#elif CACHED_POINT_INDIRECT_LIGHTING 
		if (View.IndirectLightingCacheShowFlag > 0.0f)
		{
#if TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL

			FOneBandSHVectorRGB PointIndirectLighting;
			PointIndirectLighting.R.V = IndirectLightingCache.IndirectLightingSHCoefficients0[0].x;
			PointIndirectLighting.G.V = IndirectLightingCache.IndirectLightingSHCoefficients0[1].x;
			PointIndirectLighting.B.V = IndirectLightingCache.IndirectLightingSHCoefficients0[2].x;

			FOneBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH1(1);
			OutDiffuseLighting = DotSH1(PointIndirectLighting, DiffuseTransferSH);

#else

			FThreeBandSHVectorRGB PointIndirectLighting;
			PointIndirectLighting.R.V0 = IndirectLightingCache.IndirectLightingSHCoefficients0[0];
			PointIndirectLighting.R.V1 = IndirectLightingCache.IndirectLightingSHCoefficients1[0];
			PointIndirectLighting.R.V2 = IndirectLightingCache.IndirectLightingSHCoefficients2[0];

			PointIndirectLighting.G.V0 = IndirectLightingCache.IndirectLightingSHCoefficients0[1];
			PointIndirectLighting.G.V1 = IndirectLightingCache.IndirectLightingSHCoefficients1[1];
			PointIndirectLighting.G.V2 = IndirectLightingCache.IndirectLightingSHCoefficients2[1];

			PointIndirectLighting.B.V0 = IndirectLightingCache.IndirectLightingSHCoefficients0[2];
			PointIndirectLighting.B.V1 = IndirectLightingCache.IndirectLightingSHCoefficients1[2];
			PointIndirectLighting.B.V2 = IndirectLightingCache.IndirectLightingSHCoefficients2[2];

			FThreeBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH3(DiffuseDir, 1);
			// Compute diffuse lighting which takes the normal into account
			OutDiffuseLighting = max(half3(0,0,0), DotSH3(PointIndirectLighting, DiffuseTransferSH));

#if MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE
				FThreeBandSHVector SubsurfaceTransferSH = CalcDiffuseTransferSH3(-DiffuseDir, 1);
				OutSubsurfaceLighting += max(half3(0,0,0), DotSH3(PointIndirectLighting, SubsurfaceTransferSH));
#endif
		
#endif
		}

	// High quality texture lightmaps
#elif HQ_TEXTURE_LIGHTMAP

		float2 LightmapUV0, LightmapUV1;
		uint LightmapDataIndex;
		GetLightMapCoordinates(Interpolants, LightmapUV0, LightmapUV1, LightmapDataIndex);
		SkyOcclusionUV = LightmapUV0;

		uint VTRequest = 0;
		GetLightMapColorHQ(LightmapUV0, LightmapUV1, LightmapDataIndex, DiffuseDir, MaterialParameters.SvPosition.xy, OutDiffuseLighting, OutSubsurfaceLighting, VTRequest);

#if LIGHTMAP_VT_ENABLED
		uint2 PixelPos = (uint2)MaterialParameters.SvPosition.xy;
		if( ( (PixelPos.x | PixelPos.y) & 15 ) == 0 )
		{
			// TODO use append buffer
			VTFeedbackBuffer[ PixelPos / 16 ] = VTRequest;
		}
#endif


	// Low quality texture lightmaps
#elif LQ_TEXTURE_LIGHTMAP

		float2 LightmapUV0, LightmapUV1;
		uint LightmapDataIndex;
		GetLightMapCoordinates(Interpolants, LightmapUV0, LightmapUV1, LightmapDataIndex);
		OutDiffuseLighting = GetLightMapColorLQ(LightmapUV0, LightmapUV1, LightmapDataIndex, DiffuseDir).rgb;

#endif

	// Apply indirect lighting scale while we have only accumulated lightmaps
    OutDiffuseLighting *= View.IndirectLightingColorScale;
    OutSubsurfaceLighting *= View.IndirectLightingColorScale;

    float3 SkyDiffuseLighting;
    float3 SkySubsurfaceLighting;
    GetSkyLighting(MaterialParameters, DiffuseDir, SkyOcclusionUV, VolumetricLightmapBrickTextureUVs, SkyDiffuseLighting, SkySubsurfaceLighting);

    OutSubsurfaceLighting += SkySubsurfaceLighting;

	// Sky lighting must contribute to IndirectIrradiance for ReflectionEnvironment lightmap mixing
    OutDiffuseLighting += SkyDiffuseLighting;

#if HQ_TEXTURE_LIGHTMAP || LQ_TEXTURE_LIGHTMAP || CACHED_VOLUME_INDIRECT_LIGHTING || CACHED_POINT_INDIRECT_LIGHTING || PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
		OutIndirectIrradiance = Luminance(OutDiffuseLighting);
#endif
}

#if SIMPLE_FORWARD_DIRECTIONAL_LIGHT

float3 GetSimpleForwardLightingDirectionalLight(FGBufferData GBuffer, float3 DiffuseColor, float3 SpecularColor, float Roughness, float3 WorldNormal, float3 CameraVector)
{
	float3 V = -CameraVector;
	float3 N = WorldNormal;
	float3 L = ResolvedView.DirectionalLightDirection;
	float NoL = saturate( dot( N, L ) );

	float3 LightColor = ResolvedView.DirectionalLightColor.rgb * PI;
	
	FShadowTerms Shadow = { 1, 1, 1 };
	FDirectLighting Lighting = EvaluateBxDF( GBuffer, N, V, L, NoL, Shadow );

	// Not computing specular, material was forced fully rough
	return LightColor * (Lighting.Diffuse + Lighting.Transmission);
}

#endif

float EnergyConservingWrappedDiffuse(float3 N, float3 L,float w)
{
    return saturate((dot(N, L) + w) / ((1 + w) * (1 + w)));
}

float HenyeyGreensteinPhase(float g, float CosTheta)
{
    g = -g;
    return (1 - g * g) / (4 * PI * pow(1 + g * g - 2 * g * CosTheta, 1.5f));
}

float SchlickPhase(float k, float CosTheta)
{
    float Inner = (1 + k * CosTheta);
    return (1 - k * k) / (4 * PI * Inner * Inner);
}

// [ Jimenez et al. 2016, "Practical Realtime Strategies for Accurate Indirect Occlusion" ]
float3 AOMultiBounce(float3 BaseColor, float AO)
{
    float3 a = 2.0404 * BaseColor - 0.3324;
    float3 b = -4.7951 * BaseColor + 0.6417;
    float3 c = 2.7552 * BaseColor + 0.6903;
    return max(AO, ((AO * a + b) * AO + c) * AO);
}

float TFX_Hair_g(float B, float Theta)
{
    return exp(-0.5 * Pow2(Theta) / (B * B)) / (sqrt(2 * PI) * B);
}

float TFX_Hair_F(float CosTheta)
{
    const float n = 1.55;
    const float F0 = Pow2((1 - n) / (1 + n));
    return F0 + (1 - F0) * Pow5(1 - CosTheta);
}

float3 TressFXHairShading(FGBufferData GBuffer, float3 L, float3 V, half3 N, float Shadow, float Backlit, float Area, uint2 Random)
{
	// to prevent NaN with decals
	// OR-18489 HERO: IGGY: RMB on E ability causes blinding hair effect
	// OR-17578 HERO: HAMMER: E causes blinding light on heroes with hair
    float ClampedRoughness = clamp(GBuffer.Roughness, 1 / 255.0f, 1.0f);

	//const float3 DiffuseN	= OctahedronToUnitVector( GBuffer.CustomData.xy * 2 - 1 );
	//const float Backlit	= GBuffer.CustomData.z;


	// N is the vector parallel to hair pointing toward root

    const float VoL = dot(V, L);
    const float SinThetaL = dot(N, L);
    const float SinThetaV = dot(N, V);
    float CosThetaD = cos(0.5 * abs(asinFast(SinThetaV) - asinFast(SinThetaL)));

	//CosThetaD = abs( CosThetaD ) < 0.01 ? 0.01 : CosThetaD;

    const float3 Lp = L - SinThetaL * N;
    const float3 Vp = V - SinThetaV * N;
    const float CosPhi = dot(Lp, Vp) * rsqrt(dot(Lp, Lp) * dot(Vp, Vp) + 1e-4);
    const float CosHalfPhi = sqrt(saturate(0.5 + 0.5 * CosPhi));
	//const float Phi = acosFast( CosPhi );

    float n = 1.55;
	//float n_prime = sqrt( n*n - 1 + Pow2( CosThetaD ) ) / CosThetaD;
    float n_prime = 1.19 / CosThetaD + 0.36 * CosThetaD;

    float Shift = 0.035;
    float Alpha[] =
    {
        -Shift * 2,
		Shift,
		Shift * 4,
    };
    float B[] =
    {
        Area + Pow2(ClampedRoughness),
		Area + Pow2(ClampedRoughness) / 2,
		Area + Pow2(ClampedRoughness) * 2,
    };

    float3 S = 0;

	// R
    if (1)
    {
        const float sa = sin(Alpha[0]);
        const float ca = cos(Alpha[0]);
        float Shift = 2 * sa * (ca * CosHalfPhi * sqrt(1 - SinThetaV * SinThetaV) + sa * SinThetaV);

        float Mp = TFX_Hair_g(B[0] * sqrt(2.0) * CosHalfPhi, SinThetaL + SinThetaV - Shift);
        float Np = 0.25 * CosHalfPhi;
        float Fp = TFX_Hair_F(sqrt(saturate(0.5 + 0.5 * VoL)));
        S += Mp * Np * Fp * (GBuffer.Specular * 2) * lerp(1, Backlit, saturate(-VoL));
    }

	// TT
    if (1)
    {
        float Mp = TFX_Hair_g(B[1], SinThetaL + SinThetaV - Alpha[1]);

        float a = 1 / n_prime;
		//float h = CosHalfPhi * rsqrt( 1 + a*a - 2*a * sqrt( 0.5 - 0.5 * CosPhi ) );
		//float h = CosHalfPhi * ( ( 1 - Pow2( CosHalfPhi ) ) * a + 1 );
        float h = CosHalfPhi * (1 + a * (0.6 - 0.8 * CosPhi));
		//float h = 0.4;
		//float yi = asinFast(h);
		//float yt = asinFast(h / n_prime);
		
        float f = TFX_Hair_F(CosThetaD * sqrt(saturate(1 - h * h)));
        float Fp = Pow2(1 - f);
		//float3 Tp = pow( GBuffer.BaseColor, 0.5 * ( 1 + cos(2*yt) ) / CosThetaD );
		//float3 Tp = pow( GBuffer.BaseColor, 0.5 * cos(yt) / CosThetaD );
        float3 Tp = pow(GBuffer.BaseColor, 0.5 * sqrt(1 - Pow2(h * a)) / CosThetaD);

		//float t = asin( 1 / n_prime );
		//float d = ( sqrt(2) - t ) / ( 1 - t );
		//float s = -0.5 * PI * (1 - 1 / n_prime) * log( 2*d - 1 - 2 * sqrt( d * (d - 1) ) );
		//float s = 0.35;
		//float Np = exp( (Phi - PI) / s ) / ( s * Pow2( 1 + exp( (Phi - PI) / s ) ) );
		//float Np = 0.71 * exp( -1.65 * Pow2(Phi - PI) );
        float Np = exp(-3.65 * CosPhi - 3.98);

        S += Mp * Np * Fp * Tp * Backlit;
    }

	// TRT
    if (1)
    {
        float Mp = TFX_Hair_g(B[2], SinThetaL + SinThetaV - Alpha[2]);
		
		//float h = 0.75;
        float f = TFX_Hair_F(CosThetaD * 0.5);
        float Fp = Pow2(1 - f) * f;
		//float3 Tp = pow( GBuffer.BaseColor, 1.6 / CosThetaD );
        float3 Tp = pow(GBuffer.BaseColor, 0.8 / CosThetaD);

		//float s = 0.15;
		//float Np = 0.75 * exp( Phi / s ) / ( s * Pow2( 1 + exp( Phi / s ) ) );
        float Np = exp(17 * CosPhi - 16.78);

        S += Mp * Np * Fp * Tp;
    }

    if (1)
    {
		// Use soft Kajiya Kay diffuse attenuation
        float KajiyaDiffuse = 1 - abs(dot(N, L));

        float3 FakeNormal = normalize(V - N * dot(V, N));
		//N = normalize( DiffuseN + FakeNormal * 2 );
        N = FakeNormal;

		// Hack approximation for multiple scattering.
        float Wrap = 1;
        float NoL = saturate((dot(N, L) + Wrap) / Square(1 + Wrap));
        float DiffuseScatter = (1 / PI) * lerp(NoL, KajiyaDiffuse, 0.33) * GBuffer.Metallic;
        float Luma = Luminance(GBuffer.BaseColor);
        float3 ScatterTint = pow(GBuffer.BaseColor / Luma, 1 - Shadow);
        S += sqrt(GBuffer.BaseColor) * DiffuseScatter * ScatterTint;
    }

    S = -min(-S, 0.0);

    return S;
}

//modified from hairworks
float ComputeHairGlint(
	float glintSize, //strength
	float glintPower, //exponent
	float Root2Tip,
	float HairId
)
{

	// seed along hair length
    float lengthHash = glintSize * Root2Tip;
    float lengthSeed = floor(lengthHash);
    float lengthFrac = lengthHash - lengthSeed - 0.5f;
	
	// seed for neighboring sample
    float lengthSeedNeighbor = (lengthFrac < 0) ? lengthSeed - 1.0f : lengthSeed + 1.0f;
    lengthSeedNeighbor = max(0, lengthSeedNeighbor);

	// sample 4 noise values for bilinear interpolation
    float seedSample0 = HairId + lengthSeed;
    float seedSample1 = HairId + lengthSeedNeighbor;

    float noise0 = RandBBSfloat(seedSample0);
    float noise1 = RandBBSfloat(seedSample1);

	// interpolated noise sample
    float noise = lerp(noise0, noise1, abs(lengthFrac));

	// apply gamma like power function
    noise = pow(noise, glintPower);

	// scale noise by user param
    return noise;
}

#define e 2.71828183
#define EPSILON 1e-7f

float ApproximateDeepShadow(float3 FragmentWorldPos, float SelfshadowStrength)
{

    float4 shadowPos = mul(float4(FragmentWorldPos, 1.f), TressFXColorFillPass.DirectionalLightWorldToShadowMatrix);
    float2 ShadowUVs = shadowPos.xy / shadowPos.w;

    FPCFSamplerSettings Settings;
    Settings.ShadowDepthTexture = TressFXColorFillPass.ShadowDepthTex;
    Settings.ShadowDepthTextureSampler = ForwardLightData.ShadowmapSampler;
    Settings.ShadowBufferSize = float4(2048, 2048, .00049, .00049); //ShadowBufferSize;
    Settings.TransitionScale = 60.f; //SoftTransitionScale.z;
    Settings.SceneDepth = min(shadowPos.z, 0.99999f);
    Settings.bSubsurface = false;
    Settings.bTreatMaxDepthUnshadowed = false;
    Settings.DensityMulConstant = 0;
    Settings.ProjectionDepthBiasParameters = 0;
    float shadowMapDepth = ManualPCF(ShadowUVs, Settings);
    float shadowDistFalloff = 1.0f; //TODO?
    float shadowRange = max(0.0f, shadowDistFalloff * (shadowPos.z - shadowMapDepth));
    return ComputeHairShadowAttenuation(shadowRange, g_FiberSpacing, g_FiberRadius, SelfshadowStrength);
}

//JAKETODO rect lights, also, why the inout?
bool ComputeLightAttenuationNoShadow(FDeferredLightData LightData, float3 WorldPosition, float3 N, inout float3 ToLight, inout float3 L, inout float NoL, out float LightAttenuationNoShadow)
{
	float DistanceAttenuation = 1;
    float LightRadiusMask = 1;
    float SpotFalloff = 1;

	if(LightData.bRadialLight)
	{
		ToLight = LightData.Position.xyz - WorldPosition;

		float DistanceSqr = dot(ToLight, ToLight);
		L = ToLight * rsqrt(DistanceSqr);

		if(LightData.bInverseSquared)
		{
            const float SourceLength = LightData.SourceLength;
			BRANCH
			if(SourceLength > 0)
			{
				// Line segment irradiance
				float3 L01 = LightData.Direction * SourceLength;
				float3 L0 = ToLight - 0.5 * L01;
				float3 L1 = ToLight + 0.5 * L01;
				float LengthL0 = length(L0);
				float LengthL1 = length(L1);

				DistanceAttenuation = rcp((LengthL0 * LengthL1 + dot(L0, L1)) * 0.5 + 1);
				NoL = saturate(0.5 * (dot(N, L0) / LengthL0 + dot(N, L1) / LengthL1));
			}
			else
			{
				// Sphere irradiance (technically just 1/d^2 but this avoids inf)
				DistanceAttenuation = 1 / (DistanceSqr + 1);
			}

			// TODO optimize
			LightRadiusMask = Square(saturate(1 - Square(DistanceSqr * Square(LightData.InvRadius))));
		}
		else
		{
			DistanceAttenuation = 1;
            LightRadiusMask = RadialAttenuation(ToLight * LightData.InvRadius, LightData.FalloffExponent);
        }

		if(LightData.bSpotLight)
		{
			SpotFalloff = SpotAttenuation(L, -LightData.Direction, LightData.SpotAngles);
		}
	}

	if(LightRadiusMask <= 0 || SpotFalloff <= 0)
    {
        LightAttenuationNoShadow = 0;
        return false;
    }
    LightAttenuationNoShadow = (DistanceAttenuation * LightRadiusMask * SpotFalloff);
    return true;
}

float3 GetTressFXDynamicLighting(
	  float3 WorldPosition
	, float3 CameraVector
	, FGBufferData GbufferData
	, float AmbientOcclusion
	, uint ShadingModelID
	, FDeferredLightData LightData
	, float4 LightAttenuation
	, float Dither
	, uint2 SVPos
	, FRectTexture SourceTexture
	, float Root2Tip
	, float HairId
	, bool bDirectionalLight
)
{
	// Check lighting channels
#if USE_LIGHTING_CHANNELS
	if((GetPrimitiveData(PrimitiveId).LightingChannelMask & DeferredLightUniforms.LightingChannelMask) == 0)
		return 0;
#endif
    float DiffuseBlend = TFXDiffuseBlend;
	
	// Use 1 for diffuse blend for un-shadowed light, to darken hairs at back faces. 
     if (!LightData.ShadowedBits)
    {
        DiffuseBlend = 1;
    }
    
	float3 OutColor = 0;

    float3 SpecularColor = TFXSpecularColor.xyz;

	// Setup light
    float3 V = -CameraVector;
    float3 N = GbufferData.WorldNormal;
    float3 L = LightData.Direction; // Already normalized
    float3 ToLight = L;

    float NoL = saturate(dot(N, L));
    float VoL = dot(V, L);
	
    float LightAttenuationNoShadow;
	if(!ComputeLightAttenuationNoShadow(LightData, WorldPosition, N, ToLight, L, NoL, LightAttenuationNoShadow))
    {
        return 0;
    }    

	// Setup shadow
    //LightAttenuation = saturate((LightAttenuation - TFXShadowAttenuation) / (1 - TFXShadowAttenuation));
    LightAttenuation = Square(LightAttenuation);
    FShadowTerms ShadowTerms;
    ShadowTerms.SurfaceShadow = 1;

	if(LightData.ShadowedBits)
    {
		GetShadowTerms(GbufferData, LightData, WorldPosition, L, LightAttenuation, Dither, ShadowTerms);
		// greatly reduces shadow mapping artifacts
        ShadowTerms.SurfaceShadow *= saturate(dot(N, L) * 6 - 0.2);
    }
	else
	{
        ShadowTerms.SurfaceShadow = GbufferData.GBufferAO;
    }
    
	float ApproxDeepShadow = 1.0f;
    if (bDirectionalLight)
    {
        ApproxDeepShadow = ApproximateDeepShadow(WorldPosition, TFXSelfShadowStrength);
    }

    float ShadowAttenuation = saturate(ShadowTerms.TransmissionShadow);
    //SurfaceAttenuation = lerp(1, SurfaceAttenuation,1- Alpha);
    float AllShadow = LightAttenuationNoShadow * ShadowAttenuation; // * ApproxDeepShadow;
    
	// Add glint JAKETODO ?
    float GlintAmbient = 0;
    float GlintStrength = -1.f;
    if (GlintStrength > 0)
    {
		// 0 .. 1
        float GlintSize = 256;
        float GlintExponent = 2;
        float GlintComputed = ComputeHairGlint(GlintSize, GlintExponent, Root2Tip, HairId);
        float Luma = Luminance(LightData.Color.rgb);
        GlintAmbient = GlintStrength * GlintComputed * Luma;
        SpecularColor *= lerp(1.0, GlintComputed, GlintStrength);
    }

	float3 Lighting;
    if (0)
    {
        float3 SpecDiffuse = TressFX_ComputeDiffuseSpecFactors(V, LightData.Direction, TFXTangent, DiffuseBlend);
        Lighting = SpecDiffuse.x * LightData.Color * GbufferData.BaseColor; // diffuse
        Lighting += SpecDiffuse.y * LightData.Color; // 1st specular highlight
        Lighting += SpecDiffuse.z * LightData.Color; // 2nd specular highlight
        Lighting += GlintAmbient * GbufferData.BaseColor;
        if (1)
        {
            float3 FakeNormal = normalize(V - N * dot(V, N));
            N = FakeNormal;
            float Wrap = 1;
            float KajiyaDiffuse = SpecDiffuse.x;
            float DiffuseScatter = (1 / PI) * lerp(NoL, KajiyaDiffuse, 0.33) * GbufferData.Metallic;
            float Luma = Luminance(GbufferData.BaseColor);
            float3 ScatterTint = pow((GbufferData.BaseColor) / Luma, 1 - AllShadow);
            OutColor += sqrt(GbufferData.BaseColor) * DiffuseScatter * ScatterTint;
        }
    }
	else
	{
        Lighting = TressFXHairShading(GbufferData, L, V, N, ShadowTerms.TransmissionShadow, 1, 0, uint2(0, 0));
    }
	// IES lighting
    Lighting *= ComputeLightProfileMultiplier(WorldPosition, DeferredLightUniforms.Position, -DeferredLightUniforms.Direction, DeferredLightUniforms.Tangent);
	
	OutColor += Lighting * AllShadow;
    return saturate(OutColor);
}

float3 GetForwardDirectLightingTressFX(
	uint GridIndex
	, float3 WorldPosition
	, float3 CameraVector
	, FGBufferData GBufferData
	, float2 ScreenUV
	, uint PrimitiveId
	, uint EyeIndex
	, float Dither
	, float TFXAlpha
	, float3 TFXTangent
	, float Root2Tip
	, float HairId
	, float FragmentDepth
)
{

	float4 DynamicShadowFactors = 1;

#if MATERIALBLENDING_SOLID || MATERIALBLENDING_MASKED
		DynamicShadowFactors = GetForwardDynamicShadowFactors(ScreenUV);
	#endif

	float3 DirectLighting = 0;

	float SpecularScale = 1;
#if TRANSLUCENCY_ANY_VOLUMETRIC
	// No specular on volumetric translucency lighting modes
	SpecularScale = 0;
#endif

	uint LightingChannelMask = GetPrimitiveData(PrimitiveId).LightingChannelMask;

	const FDirectionalLightData DirectionalLightData = GetDirectionalLightData(EyeIndex);
	FRectTexture RectTexture = InitRectTexture(DeferredLightUniforms.SourceTexture);

	BRANCH
	if (DirectionalLightData.HasDirectionalLight)
	{
		FDeferredLightData LightData = (FDeferredLightData)0;
		LightData.Color = DirectionalLightData.DirectionalLightColor;
		LightData.FalloffExponent = 0;
		LightData.Direction = DirectionalLightData.DirectionalLightDirection;
		LightData.DistanceFadeMAD = DirectionalLightData.DirectionalLightDistanceFadeMAD;
		LightData.bRadialLight = false;
		LightData.SpecularScale = SpecularScale;

		LightData.ShadowedBits = (DirectionalLightData.DirectionalLightShadowMapChannelMask & 0xFF) != 0 ? 1 : 0;
		// Static shadowing uses ShadowMapChannel, dynamic shadows are packed into light attenuation using PreviewShadowMapChannel
		LightData.ShadowMapChannelMask = UnpackShadowMapChannelMask(DirectionalLightData.DirectionalLightShadowMapChannelMask);

		#if MATERIALBLENDING_SOLID || MATERIALBLENDING_MASKED
			float4 PreviewShadowMapChannelMask = UnpackShadowMapChannelMask(DirectionalLightData.DirectionalLightShadowMapChannelMask >> 4);
			float DynamicShadowing = dot(PreviewShadowMapChannelMask, DynamicShadowFactors);

			// In the forward shading path we can't separate per-object shadows from CSM, since we only spend one light attenuation channel per light
			// If CSM is enabled (distance fading to precomputed shadowing is active), treat all of our dynamic shadowing as whole scene shadows that will be faded out at the max CSM distance
			// If CSM is not enabled, allow our dynamic shadowing to coexist with precomputed shadowing
			float PerObjectShadowing = LightData.DistanceFadeMAD.y < 0.0f ? 1.0f : DynamicShadowing;
			float WholeSceneShadowing = LightData.DistanceFadeMAD.y < 0.0f ? DynamicShadowing : 1.0f;

			// LightAttenuation: Light function + per-object shadows in z, per-object SSS shadowing in w, 
			// Whole scene directional light shadows in x, whole scene directional light SSS shadows in y
			float4 LightAttenuation = float4(WholeSceneShadowing.xx, PerObjectShadowing.xx);
		#else
			LightData.ShadowMapChannelMask.x = 1;
			#if TRANSLUCENCY_LIGHTING_SURFACE_FORWARDSHADING
				GBufferData.PrecomputedShadowFactors.x = ComputeDirectionalLightStaticShadowing(WorldPosition).x;
			#else
				GBufferData.PrecomputedShadowFactors.x = 1;
			#endif
			float DynamicShadowFactor = ComputeDirectionalLightDynamicShadowing(WorldPosition, GBufferData.Depth);
			float4 LightAttenuation = float4(DynamicShadowFactor.x, DynamicShadowFactor.x, 1, 1);
		#endif

		// LightAttenuation: Light function + per-object shadows in z, per-object SSS shadowing in w, 
		// Whole scene directional light shadows in x, whole scene directional light SSS shadows in y
        #if MATERIAL_SHADINGMODEL_TRESSFX
			float3 NewLighting = GetTressFXDynamicLighting(WorldPosition, -CameraVector, GBufferData, 1, GBufferData.ShadingModelID, LightData, LightAttenuation, Dither, uint2(0, 0), RectTexture, Root2Tip, HairId, true);
		#else
			float3 NewLighting = GetDynamicLighting(WorldPosition, -CameraVector, GBufferData, 1, GBufferData.ShadingModelID, LightData, LightAttenuation, Dither, uint2(0, 0), RectTexture).xyz;
		#endif

		FLATTEN
		if ((DirectionalLightData.DirectionalLightShadowMapChannelMask >> 8) & LightingChannelMask)
		{
			DirectLighting += NewLighting;
		}
	}

	const FCulledLightsGridData CulledLightsGrid = GetCulledLightsGrid(GridIndex, EyeIndex);

	
	// Limit max to ForwardLightData.NumLocalLights.
	// This prevents GPU hangs when the PS tries to read from uninitialized NumCulledLightsGrid buffer
	const uint NumLocalLights = min(CulledLightsGrid.NumLocalLights, GetNumLocalLights(EyeIndex));

	LOOP
	for (uint LocalLightListIndex = 0; LocalLightListIndex < NumLocalLights; LocalLightListIndex++)
	{
		const FLocalLightData LocalLight = GetLocalLightData(CulledLightsGrid.DataStartIndex + LocalLightListIndex, EyeIndex);
		 
		FDeferredLightData LightData = (FDeferredLightData)0;
		LightData.Position = LocalLight.LightPositionAndInvRadius.xyz;
		LightData.InvRadius = LocalLight.LightPositionAndInvRadius.w;
		LightData.Color = LocalLight.LightColorAndFalloffExponent.xyz;
		LightData.FalloffExponent = LocalLight.LightColorAndFalloffExponent.w;
		LightData.Direction = LocalLight.LightDirectionAndShadowMask.xyz;
		LightData.SpotAngles = LocalLight.SpotAnglesAndSourceRadiusPacked.xy;
		LightData.SourceRadius = LocalLight.SpotAnglesAndSourceRadiusPacked.z;
		LightData.SourceLength = f16tof32(asuint(LocalLight.SpotAnglesAndSourceRadiusPacked.w));
        LightData.Tangent = LocalLight.LightTangentAndSoftSourceRadius.xyz;
        LightData.SoftSourceRadius = LocalLight.LightTangentAndSoftSourceRadius.w;
		LightData.bInverseSquared = LightData.FalloffExponent == 0;
		LightData.bRadialLight = true;
		LightData.bSpotLight = LightData.SpotAngles.x > -2.0f;
		LightData.SpecularScale = SpecularScale;

		uint PackedShadowMapChannelMask = asuint(LocalLight.LightDirectionAndShadowMask.w);
		LightData.ShadowedBits = (PackedShadowMapChannelMask & 0xFF) != 0 ? 1 : 0;
		// Static shadowing uses ShadowMapChannel, dynamic shadows are packed into light attenuation using PreviewShadowMapChannel
		LightData.ShadowMapChannelMask = UnpackShadowMapChannelMask(PackedShadowMapChannelMask);
		float4 PreviewShadowMapChannelMask = UnpackShadowMapChannelMask(PackedShadowMapChannelMask >> 4);
		float DynamicShadowing = dot(PreviewShadowMapChannelMask, DynamicShadowFactors);
		float4 LightAttenuation = float4(1, 1, DynamicShadowing.x, DynamicShadowing.x);
        #if MATERIAL_SHADINGMODEL_TRESSFX
			float3 NewLighting = GetTressFXDynamicLighting(WorldPosition, -CameraVector, GBufferData, 1, GBufferData.ShadingModelID, LightData, LightAttenuation, Dither, uint2(0, 0), RectTexture, Root2Tip, HairId, false);
		#else
			float3 NewLighting = GetDynamicLighting(WorldPosition, -CameraVector, GBufferData, 1, GBufferData.ShadingModelID, LightData, LightAttenuation, Dither, uint2(0, 0), RectTexture).xyz;
		#endif
		
		
		FLATTEN
		if ((PackedShadowMapChannelMask >> 8) & LightingChannelMask)
		{
			DirectLighting += NewLighting;
		}
	}

	// For debugging
	//DirectLighting = CulledLightsGrid.NumLocalLights / (float)ForwardLightData.MaxCulledLightsPerCell;
	return DirectLighting;
}
#if TFX_PPLL
	#include "TressFXPPLL.ush"
#endif
EARLYDEPTHSTENCIL
void main(
	PS_INPUT_HAIR_AA In OPTIONAL_IsFrontFace
#if TFX_SHORTCUT
	, out float4 OutColor : SV_Target0
#endif
)
{
	//final color
	float3 Color = 0; 

	//this static variable in instanced stero.ush needs to be set 
    ResolvedView = ResolveView();

    FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(In.FactoryInterpolants, In.Position);
    FPixelMaterialInputs PixelMaterialInputs;
	
#if HQ_TEXTURE_LIGHTMAP && USES_AO_MATERIAL_MASK && !MATERIAL_SHADINGMODEL_UNLIT
	{
		float2 LightmapUV0, LightmapUV1;
		uint LightmapDataIndex;
		GetLightMapCoordinates(Interpolants, LightmapUV0, LightmapUV1, LightmapDataIndex);
		// Must be computed before BaseColor, Normal, etc are evaluated
		MaterialParameters.AOMaterialMask = GetAOMaterialMask(LightmapUV0 * float2(1, 2), In.SvPosition.xy);
	}
#endif

	//this path will never work because we dont have BasePassInterpolants.PixelPositionExcludingWPO
	#if USE_WORLD_POSITION_EXCLUDING_SHADER_OFFSETS && 0
		{
			float4 ScreenPosition = SvPositionToResolvedScreenPosition(In.Position);
			float3 TranslatedWorldPosition = SvPositionToResolvedTranslatedWorld(In.Position);
			CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, In.Position, ScreenPosition, bIsFrontFace, TranslatedWorldPosition, BasePassInterpolants.PixelPositionExcludingWPO);
		}
	#else
		{
        float4 ScreenPosition = SvPositionToResolvedScreenPosition(In.Position);
        float3 TranslatedWorldPosition = SvPositionToResolvedTranslatedWorld(In.Position);
        CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, In.Position, ScreenPosition, bIsFrontFace, TranslatedWorldPosition, TranslatedWorldPosition);
    }
	#endif

    float2 viewport = ResolvedView.ViewSizeAndInvSize.xy;
    float2 NDC = MaterialParameters.ScreenPosition.xy / MaterialParameters.ScreenPosition.w;
    float TFXCoverage = ComputeCoverage(In.FactoryInterpolants.p0p1.xy, In.FactoryInterpolants.p0p1.zw, NDC, viewport, In.Position.z);
    half Opacity = GetMaterialOpacity(PixelMaterialInputs);
    float TFXAlpha = TFXCoverage * Opacity;
    float3 TFXTangent = In.FactoryInterpolants.Tangent.xyz;
	BRANCH
    if (TFXAlpha < SHORTCUT_MIN_ALPHA)
    {
		#if TFX_PPLL

		#elif TFX_SHORTCUT
			OutColor = float4(0, 0, 0, 0);
		#endif
        return;
    }

	#if TFX_PPLL
		int2 ScreenAddr = int2(In.Position.xy);
		const uint DepthAsUint = asuint(In.Position.w);
		const uint DepthToWrite = (TFXAlpha > .8f) ? DepthAsUint : 0;
		uint oldMinDepthAsUint;
		InterlockedMin(RWOpacityThresholdingUAV[ScreenAddr], DepthToWrite, oldMinDepthAsUint);
		if(DepthAsUint < oldMinDepthAsUint)
		{
			discard;
			return;
		}
	#endif

    half3 BaseColor = GetMaterialBaseColor(PixelMaterialInputs);
    half Metallic = GetMaterialMetallic(PixelMaterialInputs);
    half Specular = GetMaterialSpecular(PixelMaterialInputs);
    float MaterialAO = GetMaterialAmbientOcclusion(PixelMaterialInputs);
    float Roughness = GetMaterialRoughness(PixelMaterialInputs);
	// 0..1, SubsurfaceProfileId = int(x * 255)
    float SubsurfaceProfile = 0;

	// If we don't use this shading model the color should be black (don't generate shader code for unused data, don't do indirectlighting cache lighting with this color).
    float3 SubsurfaceColor = 0;
	#if MATERIAL_SHADINGMODEL_SUBSURFACE || MATERIAL_SHADINGMODEL_PREINTEGRATED_SKIN || MATERIAL_SHADINGMODEL_SUBSURFACE_PROFILE || MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE || MATERIAL_SHADINGMODEL_CLOTH || MATERIAL_SHADINGMODEL_EYE
	{
		float4 SubsurfaceData = GetMaterialSubsurfaceData(PixelMaterialInputs);

	#if MATERIAL_SHADINGMODEL_SUBSURFACE || MATERIAL_SHADINGMODEL_PREINTEGRATED_SKIN || MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE
		SubsurfaceColor = SubsurfaceData.rgb * View.DiffuseOverrideParameter.w + View.DiffuseOverrideParameter.xyz;
	#elif MATERIAL_SHADINGMODEL_CLOTH
		SubsurfaceColor = SubsurfaceData.rgb;
	#endif
		SubsurfaceProfile = SubsurfaceData.a;
	}
	#endif

    float3 VolumetricLightmapBrickTextureUVs;
		
	#if PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
		VolumetricLightmapBrickTextureUVs = ComputeVolumetricLightmapBrickTextureUVs(MaterialParameters.AbsoluteWorldPosition);
	#endif

    FGBufferData GBuffer = (FGBufferData) 0;
    GBuffer.GBufferAO = MaterialAO;
    GBuffer.PerObjectGBufferData = GetPrimitiveData(MaterialParameters.PrimitiveId).PerObjectGBufferData;
    GBuffer.Depth = MaterialParameters.ScreenPosition.w;
    GBuffer.PrecomputedShadowFactors = GetPrecomputedShadowMasks(In.FactoryInterpolants, MaterialParameters.PrimitiveId, MaterialParameters.AbsoluteWorldPosition, VolumetricLightmapBrickTextureUVs);

    const float GBufferDither = InterleavedGradientNoise(MaterialParameters.SvPosition.xy, View.StateFrameIndexMod8);
    SetGBufferForShadingModel(
		GBuffer,
		MaterialParameters,
		Opacity,
		BaseColor,
		Metallic,
		Specular,
		Roughness,
		SubsurfaceColor,
		SubsurfaceProfile,
		GBufferDither);

	// So that the following code can still use DiffuseColor and SpecularColor.
    GBuffer.SpecularColor = ComputeF0(Specular, BaseColor, Metallic);
    GBuffer.DiffuseColor = BaseColor - BaseColor * Metallic;
    float3 BentNormal = MaterialParameters.WorldNormal;
    float DiffOcclusion = MaterialAO;
    float SpecOcclusion = MaterialAO;
    GBuffer.GBufferAO = AOMultiBounce(Luminance(GBuffer.SpecularColor), SpecOcclusion).g;
    GBuffer.WorldNormal = MaterialParameters.WorldNormal;


	float3 DiffuseDir = BentNormal;
	float3 DiffuseColorForIndirect = GBuffer.DiffuseColor;
	{
        float3 N = GBuffer.WorldNormal;
		float3 V = MaterialParameters.CameraVector;
		float3 L = normalize( V - N * dot(V,N) );
		DiffuseDir = L;
        DiffuseColorForIndirect = 2 * PI * TressFXHairShading(GBuffer, L, V, N, 1, 0, 0.2, uint2(0, 0));
    }

	float3 DiffuseIndirectLighting;
	float3 SubsurfaceIndirectLighting;
	float3 DiffuseColor = 0;
	float IndirectIrradiance = 0;
	GetPrecomputedIndirectLightingAndSkyLight(MaterialParameters, In.FactoryInterpolants, DiffuseDir, VolumetricLightmapBrickTextureUVs, DiffuseIndirectLighting, SubsurfaceIndirectLighting, IndirectIrradiance);
	DiffuseColor += (DiffuseIndirectLighting * DiffuseColorForIndirect + SubsurfaceIndirectLighting * SubsurfaceColor) * AOMultiBounce(GBuffer.BaseColor, DiffOcclusion);
	Color += DiffuseColor;

	float2 ScreenUV = NDC * ResolvedView.ScreenPositionScaleBias.xy + ResolvedView.ScreenPositionScaleBias.wz;
		
	float IndirectOcclusion = 1.0f;
	float2 NearestResolvedDepthScreenUV = 0;
	NearestResolvedDepthScreenUV = CalculateNearestResolvedDepthScreenUV(ScreenUV, MaterialParameters.ScreenPosition.w);

	IndirectOcclusion = GetIndirectOcclusion(NearestResolvedDepthScreenUV, GBuffer);
	DiffuseIndirectLighting *= IndirectOcclusion;
	SubsurfaceIndirectLighting *= IndirectOcclusion;
	IndirectIrradiance *= IndirectOcclusion; 

    uint GridIndex = ComputeLightGridCellIndex((uint2) (In.Position.xy - ResolvedView.ViewRectMin.xy), In.Position.w, 0);
    const float Dither = InterleavedGradientNoise(MaterialParameters.SvPosition.xy, View.StateFrameIndexMod8);
    const uint EyeIndex = 0;
    Color += GetForwardDirectLightingTressFX(
		  GridIndex
		, MaterialParameters.AbsoluteWorldPosition
		, MaterialParameters.CameraVector
		, GBuffer
		, NearestResolvedDepthScreenUV
		, MaterialParameters.PrimitiveId
		, 0
		, Dither
		, TFXAlpha
		, TFXTangent
		, In.FactoryInterpolants.Root2Tip
		, In.FactoryInterpolants.HairId
		, In.Position.z
	);
	
	#if TFX_PPLL
		//color will be multipled be TFXAlpha during resolve pass
		BuildPPLL(float4(saturate(Color), TFXAlpha), ScreenAddr, In.Position.w);
	#elif TFX_SHORTCUT		
		OutColor = float4(Color * TFXAlpha, TFXAlpha);
	#endif
	return;
}
