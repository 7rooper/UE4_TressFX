// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	SSDCommon.ush: All the code commonly shared between uniform buffers.
=============================================================================*/

#pragma once

#include "SSDCommon.ush"


//------------------------------------------------------- ENUMS

/** Layouts of the signal buffer. */
	/** Buffer layout for the shadow penumbra given as input. */
	#define SIGNAL_BUFFER_LAYOUT_PENUMBRA_INPUT 0

	/** Internal buffer layout for the shadow penumbra. */
	#define SIGNAL_BUFFER_LAYOUT_PENUMBRA_INTERNAL 1

	/** Internal buffer layout used for history rejection for the shadow penumbra. */
	#define SIGNAL_BUFFER_LAYOUT_PENUMBRA_HISTORY_REJECTION 2

	/** Buffer layout taken as input by */ // TODO: unused, remove it.
	// #define SIGNAL_BUFFER_LAYOUT_PENUMBRA_OUTPUT 3

	/** Buffer layout for the reflection given by the ray generation shader. */
	#define SIGNAL_BUFFER_LAYOUT_REFLECTIONS_INPUT 3

	/** Buffer layout for the reflection output. */
	#define SIGNAL_BUFFER_LAYOUT_REFLECTIONS_HISTORY 4


/** Defines how the signal is being processed. Matches C++'s ESignalProcessing. */
	/** Scene color anti aliasing processing. */
	//#define SIGNAL_PROCESSING_COLORAA 0

	/** Depth of field stabilization processing. */
	//#define SIGNAL_PROCESSING_DOF 1

	/** Shadow penumbra denoising. */
	#define SIGNAL_PROCESSING_PENUMBRA 0

	/** Shadow penumbra denoising. */
	//#define SIGNAL_PROCESSING_DIFUSE_GI 3

	/** Reflection denoising. */
	#define SIGNAL_PROCESSING_REFLECTIONS 1


//------------------------------------------------------- STRUCTURE

/** Generic data structure to manipulate any kind of signal. */
struct FSSFSignalSample
{
	// Number of sample accumulated.
	float AccumulatedSampleCount;

	// Scene color and alpha.
	float4 SceneColor;

	// Shadow denoising specific.
	float LeavingRayCount;
	float PenumbraClosestHit;
	float UncertainRayCount;
};

FSSFSignalSample CreateSignalSampleFromScalarValue(float Scalar)
{
	FSSFSignalSample OutSample;
	OutSample.SceneColor = Scalar;
	OutSample.AccumulatedSampleCount = Scalar;
	OutSample.LeavingRayCount = Scalar;
	OutSample.PenumbraClosestHit = Scalar;
	OutSample.UncertainRayCount = Scalar;
	return OutSample;
}

FSSFSignalSample CreateSignalSample()
{
	return CreateSignalSampleFromScalarValue(0.0);
}


//------------------------------------------------------- INPUT/OUTPUT

/** Decode input signal sample. */
FSSFSignalSample DecodeInputSignal(const uint SignalBufferLayout, float4 Samples[2])
{
	FSSFSignalSample OutSample = CreateSignalSample();

	if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_PENUMBRA_INPUT)
	{
		OutSample.AccumulatedSampleCount = 1;
		OutSample.LeavingRayCount = OutSample.AccumulatedSampleCount * Samples[0].r;
		OutSample.PenumbraClosestHit = Samples[1].r;
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_PENUMBRA_INTERNAL)
	{
		if (DEBUG_STORE_NORMALIZED_COMPONENTS)
		{
			OutSample.LeavingRayCount = Samples[0].r * Samples[0].b;
			OutSample.UncertainRayCount = Samples[0].g * Samples[0].b;
			OutSample.AccumulatedSampleCount = Samples[0].b - OutSample.UncertainRayCount;
		}
		else
		{
			OutSample.LeavingRayCount = Samples[0].r;
			OutSample.AccumulatedSampleCount = Samples[0].g;
			OutSample.UncertainRayCount = Samples[0].b;
		}
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_PENUMBRA_HISTORY_REJECTION)
	{
		//if (Samples[0].r < 1)
		if (Samples[0].r >= 0)
		{
			OutSample.AccumulatedSampleCount = 1;
			OutSample.LeavingRayCount = OutSample.AccumulatedSampleCount * Samples[0].r; // *(255.0 / 254.0);
		}
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_REFLECTIONS_INPUT)
	{
		OutSample.AccumulatedSampleCount = Samples[0].a > 0 ? 1 : 0;
		OutSample.LeavingRayCount = OutSample.AccumulatedSampleCount * (1 - Samples[0].a);
		OutSample.SceneColor = Samples[0];
		OutSample.PenumbraClosestHit = Samples[1].r;
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_REFLECTIONS_HISTORY)
	{
		OutSample.AccumulatedSampleCount = Samples[1].r;
		OutSample.LeavingRayCount = OutSample.AccumulatedSampleCount * (1 - Samples[0].a);
		OutSample.SceneColor = OutSample.AccumulatedSampleCount * Samples[0];
	}

	return OutSample;
}

/** Encode output signal sample. */
void EncodeOutputSignal(const uint SignalBufferLayout, FSSFSignalSample Sample, out float4 OutSamples[2], out uint OutBufferCount)
{
	OutSamples[0] = OutSamples[1] = 0;
	OutBufferCount = 1;

	if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_PENUMBRA_INTERNAL)
	{
		if (DEBUG_STORE_NORMALIZED_COMPONENTS)
		{
			OutSamples[0] = float4(
				Sample.UncertainRayCount + Sample.AccumulatedSampleCount > 0
					? Sample.LeavingRayCount / (Sample.UncertainRayCount + Sample.AccumulatedSampleCount)
					: -1.0,
				Sample.UncertainRayCount + Sample.AccumulatedSampleCount > 0
					? Sample.UncertainRayCount / (Sample.UncertainRayCount + Sample.AccumulatedSampleCount)
					: -1.0,
				Sample.UncertainRayCount + Sample.AccumulatedSampleCount,
				0);
		}
		else
		{
			OutSamples[0] = float4(
				Sample.LeavingRayCount,
				Sample.AccumulatedSampleCount,
				Sample.UncertainRayCount,
				0);
		}
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_PENUMBRA_HISTORY_REJECTION)
	{
		//if (Sample.AccumulatedSampleCount == 0)
		//{
		//	OutSamples[0].r = 1.0;
		//}
		//else
		//{
		//	OutSamples[0].r = (254.0 / 255.0) * (Sample.LeavingRayCount / Sample.AccumulatedSampleCount);
		//}

		OutSamples[0].r = Sample.AccumulatedSampleCount == 0 ? -1 : Sample.LeavingRayCount / Sample.AccumulatedSampleCount;
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_REFLECTIONS_HISTORY)
	{
		OutSamples[0] = Sample.SceneColor * (Sample.AccumulatedSampleCount > 0 ? rcp(Sample.AccumulatedSampleCount) : 0);
		OutSamples[1].r = Sample.AccumulatedSampleCount;
		OutBufferCount = 2;
	}
}

/** Sample input signal. */
FSSFSignalSample SampleInputSignal(Texture2D SignalBuffer0, Texture2D SignalBuffer1, SamplerState Sampler, const uint SignalBufferLayout, float2 UV, float Level = 0)
{
	float4 Samples[2];
	Samples[0] = SignalBuffer0.SampleLevel(Sampler, UV, Level);
	Samples[1] = SignalBuffer1.SampleLevel(Sampler, UV, Level);
	return DecodeInputSignal(SignalBufferLayout, Samples);
}

/** Sample output signal. */
void OutputSignal(RWTexture2D<float4> OutputSignalBuffer0, RWTexture2D<float4> OutputSignalBuffer1, const uint SignalBufferLayout, const uint2 PixelPosition, FSSFSignalSample Sample)
{
	float4 Samples[2];
	uint BufferCount;
	EncodeOutputSignal(SignalBufferLayout, Sample, Samples, BufferCount);

	if (BufferCount >= 1)
		OutputSignalBuffer0[PixelPosition] = Samples[0];
	if (BufferCount >= 2)
		OutputSignalBuffer1[PixelPosition] = Samples[1];
}


//------------------------------------------------------- SIGNAL OPERATORS

FSSFSignalSample Mul(FSSFSignalSample Sample, float Scalar)
{
	FSSFSignalSample OutSample;
	OutSample.SceneColor             = Sample.SceneColor * Scalar;
	OutSample.AccumulatedSampleCount = Sample.AccumulatedSampleCount * Scalar;
	OutSample.LeavingRayCount        = Sample.LeavingRayCount * Scalar;
	OutSample.PenumbraClosestHit     = Sample.PenumbraClosestHit * Scalar;
	OutSample.UncertainRayCount      = Sample.UncertainRayCount * Scalar;
	return OutSample;
}

FSSFSignalSample Add(FSSFSignalSample SampleA, FSSFSignalSample SampleB)
{
	SampleA.SceneColor             += SampleB.SceneColor;
	SampleA.AccumulatedSampleCount += SampleB.AccumulatedSampleCount;
	SampleA.LeavingRayCount        += SampleB.LeavingRayCount;
	SampleA.PenumbraClosestHit     += SampleB.PenumbraClosestHit;
	SampleA.UncertainRayCount      += SampleB.UncertainRayCount;
	return SampleA;
}

FSSFSignalSample Minus(FSSFSignalSample Sample)
{
	Sample.SceneColor             = -Sample.SceneColor;
	Sample.AccumulatedSampleCount = -Sample.AccumulatedSampleCount;
	Sample.LeavingRayCount        = -Sample.LeavingRayCount;
	Sample.PenumbraClosestHit     = -Sample.PenumbraClosestHit;
	Sample.UncertainRayCount      = -Sample.UncertainRayCount;
	return Sample;
}

FSSFSignalSample Subtract(FSSFSignalSample SampleA, FSSFSignalSample SampleB)
{
	return Add(SampleA, Minus(SampleB));
}

FSSFSignalSample Abs(FSSFSignalSample Sample)
{
	Sample.SceneColor             = abs(Sample.SceneColor);
	Sample.AccumulatedSampleCount = abs(Sample.AccumulatedSampleCount);
	Sample.LeavingRayCount        = abs(Sample.LeavingRayCount);
	Sample.PenumbraClosestHit     = abs(Sample.PenumbraClosestHit);
	Sample.UncertainRayCount      = abs(Sample.UncertainRayCount);
	return Sample;
}

FSSFSignalSample Sqrt(FSSFSignalSample Sample)
{
	Sample.SceneColor             = sqrt(Sample.SceneColor);
	Sample.AccumulatedSampleCount = sqrt(Sample.AccumulatedSampleCount);
	Sample.LeavingRayCount        = sqrt(Sample.LeavingRayCount);
	Sample.PenumbraClosestHit     = sqrt(Sample.PenumbraClosestHit);
	Sample.UncertainRayCount      = sqrt(Sample.UncertainRayCount);
	return Sample;
}

FSSFSignalSample Power(FSSFSignalSample Sample, float Exponent)
{
	Sample.SceneColor.r           = pow(Sample.SceneColor.r, Exponent);
	Sample.SceneColor.g           = pow(Sample.SceneColor.g, Exponent);
	Sample.SceneColor.b           = pow(Sample.SceneColor.b, Exponent);
	Sample.SceneColor.a           = pow(Sample.SceneColor.a, Exponent);
	Sample.AccumulatedSampleCount = pow(Sample.AccumulatedSampleCount, Exponent);
	Sample.LeavingRayCount        = pow(Sample.LeavingRayCount, Exponent);
	Sample.PenumbraClosestHit     = pow(Sample.PenumbraClosestHit, Exponent);
	Sample.UncertainRayCount      = pow(Sample.UncertainRayCount, Exponent);
	return Sample;
}

FSSFSignalSample Suctract(FSSFSignalSample SampleA, FSSFSignalSample SampleB)
{
	return Add(SampleA, Minus(SampleB));
}

FSSFSignalSample Min(FSSFSignalSample SampleA, FSSFSignalSample SampleB)
{
	FSSFSignalSample OutSample;
	OutSample.SceneColor = min(SampleA.SceneColor, SampleB.SceneColor);
	OutSample.AccumulatedSampleCount = min(SampleA.AccumulatedSampleCount, SampleB.AccumulatedSampleCount);
	OutSample.LeavingRayCount = min(SampleA.LeavingRayCount, SampleB.LeavingRayCount);
	OutSample.PenumbraClosestHit = min(SampleA.PenumbraClosestHit, SampleB.PenumbraClosestHit);
	OutSample.UncertainRayCount = min(SampleA.UncertainRayCount, SampleB.UncertainRayCount);
	return OutSample;
}

FSSFSignalSample Max(FSSFSignalSample SampleA, FSSFSignalSample SampleB)
{
	FSSFSignalSample OutSample;
	OutSample.SceneColor = max(SampleA.SceneColor, SampleB.SceneColor);
	OutSample.AccumulatedSampleCount = max(SampleA.AccumulatedSampleCount, SampleB.AccumulatedSampleCount);
	OutSample.LeavingRayCount = max(SampleA.LeavingRayCount, SampleB.LeavingRayCount);
	OutSample.PenumbraClosestHit = max(SampleA.PenumbraClosestHit, SampleB.PenumbraClosestHit);
	OutSample.UncertainRayCount = max(SampleA.UncertainRayCount, SampleB.UncertainRayCount);
	return OutSample;
}

FSSFSignalSample Clamp(FSSFSignalSample Sample, FSSFSignalSample SampleMin, FSSFSignalSample SampleMax)
{
	FSSFSignalSample OutSample;
	OutSample.SceneColor = clamp(Sample.SceneColor, SampleMin.SceneColor, SampleMax.SceneColor);
	OutSample.AccumulatedSampleCount = clamp(Sample.AccumulatedSampleCount, SampleMin.AccumulatedSampleCount, SampleMax.AccumulatedSampleCount);
	OutSample.LeavingRayCount = clamp(Sample.LeavingRayCount, SampleMin.LeavingRayCount, SampleMax.LeavingRayCount);
	OutSample.PenumbraClosestHit = clamp(Sample.PenumbraClosestHit, SampleMin.PenumbraClosestHit, SampleMax.PenumbraClosestHit);
	OutSample.UncertainRayCount = clamp(Sample.UncertainRayCount, SampleMin.UncertainRayCount, SampleMax.UncertainRayCount);
	return OutSample;
}

FSSFSignalSample Lerp(FSSFSignalSample Sample0, FSSFSignalSample Sample1, float Interp)
{
	return Add(Sample0, Mul(Suctract(Sample1, Sample0), Interp));
}

/** Normalize the signal sample to one. */
FSSFSignalSample NormalizeToOneSample(FSSFSignalSample Sample)
{
	FSSFSignalSample OutSample = Mul(Sample, Sample.AccumulatedSampleCount > 0 ? rcp(Sample.AccumulatedSampleCount) : 0);
	OutSample.AccumulatedSampleCount = 1;
	return OutSample;
}
