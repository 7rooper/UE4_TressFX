// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
PostProcessTemporalAA.usf: Temporal AA
=============================================================================*/

#include "SSDCommon.ush"
#include "SSDSignalCore.ush"


//------------------------------------------------------- ENUM VALUES

/** Sets of sample available for the spatial kernel. */
	#define SAMPLE_SET_3X3 0
	#define SAMPLE_SET_5X5_WAVELET 1


//------------------------------------------------------- CONFIGS

#define TILE_PIXEL_SIZE 8

#define CONFIG_SIGNAL_PROCESSING DIM_SIGNAL_PROCESSING


#if CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_PENUMBRA
	#define CONFIG_SIGNAL_INPUT_LAYOUT  SIGNAL_BUFFER_LAYOUT_PENUMBRA_INTERNAL
	#define CONFIG_SIGNAL_OUTPUT_LAYOUT SIGNAL_BUFFER_LAYOUT_PENUMBRA_HISTORY_REJECTION

	#define CONFIG_SAMPLE_SET SAMPLE_SET_3X3


#elif CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_REFLECTIONS
	#define CONFIG_SIGNAL_INPUT_LAYOUT  SIGNAL_BUFFER_LAYOUT_REFLECTIONS_HISTORY
	#define CONFIG_SIGNAL_OUTPUT_LAYOUT SIGNAL_BUFFER_LAYOUT_REFLECTIONS_HISTORY

	#define CONFIG_SAMPLE_SET SAMPLE_SET_3X3

	#define CONFIG_WEIGHT_KERNEL_CENTER 1

#else
	#error Unknown signal processing.
#endif

#include "SSDSignalInterface.ush"


//------------------------------------------------------- CONFIG DISABLED DEFAULTS

/** Whether the output signal should be normalized. */
#ifndef CONFIG_NORMALIZE_OUTPUT
	#define CONFIG_NORMALIZE_OUTPUT 0
#endif

/** Ensures the center of the kernel have a correct weight. */
#ifndef CONFIG_WEIGHT_KERNEL_CENTER
	#define CONFIG_WEIGHT_KERNEL_CENTER 0
#endif


//------------------------------------------------------- CONSTANTS

static const float kWaveletFilterWeights5x5[] = { 3.0 / 8.0, 1.0 / 4.0, 1.0 / 16.0 };


//------------------------------------------------------- PARAMETERS

Texture2D SignalInput0;
Texture2D SignalInput1;

RWTexture2D<float4>	SignalOutput0;
RWTexture2D<float4>	SignalOutput1;


//------------------------------------------------------- FUNCTIONS


//------------------------------------------------------- ENTRY POINTS

[numthreads(TILE_PIXEL_SIZE, TILE_PIXEL_SIZE, 1)]
void MainCS(
	uint2 DispatchThreadId : SV_DispatchThreadID,
	uint2 GroupId : SV_GroupID,
	uint2 GroupThreadId : SV_GroupThreadID,
	uint GroupThreadIndex : SV_GroupIndex)
{
	// Find out scene buffer UV.
	float2 SceneBufferUV = (DispatchThreadId + 0.5 + View.ViewRectMin.xy) * View.BufferSizeAndInvSize.zw;
	if (true)
	{
		SceneBufferUV = clamp(SceneBufferUV, View.BufferBilinearUVMinMax.xy, View.BufferBilinearUVMinMax.zw);
	}
	float2 ViewportUV = BufferUVToViewportUV(SceneBufferUV);
	float2 ScreenPosition = ViewportUVToScreenPos(ViewportUV);


	// Read reference data.
	FSSFSignalSample Accumulator = SampleInputSignal(SignalInput0, SignalInput1, GlobalPointClampedSampler, CONFIG_SIGNAL_INPUT_LAYOUT, SceneBufferUV);
	FSSFSampleSceneInfos CurrentSceneMetadata = FetchCurrentSceneInfos(ScreenPosition, SceneBufferUV);

	float CurrentWorldBluringRadius = ComputePixelWorldRadius(CurrentSceneMetadata);

	float AccumulatorWeight = 1;
	float BilateralWeightAdjustement = 1;
	#if CONFIG_WEIGHT_KERNEL_CENTER
	{
		BilateralWeightAdjustement = rcp(ComputeBilateralWeight(100, CurrentSceneMetadata, CurrentSceneMetadata));
	}
	#endif

	#if CONFIG_SAMPLE_SET == SAMPLE_SET_3X3
		const int KernelRadius = 1;
	#elif CONFIG_SAMPLE_SET == SAMPLE_SET_5X5_WAVELET
		const int KernelRadius = 2;
	#else
		#error Unknown set of samples.
	#endif

	// Apply the kernel
	// TODO: per pixel stocastic important sampled one.
	UNROLL
	for (int x = -KernelRadius; x <= KernelRadius; x++)
	UNROLL
	for (int y = -KernelRadius; y <= KernelRadius; y++)
	{
		if (x == 0 && y == 0) continue;

		// Compue sample coordinates
		float2 NeighborBufferUV = SceneBufferUV + float2(x, y) * View.BufferSizeAndInvSize.zw;
		if (1)
		{
			if (1 && any(NeighborBufferUV != clamp(NeighborBufferUV, View.BufferBilinearUVMinMax.xy, View.BufferBilinearUVMinMax.zw)))
			{
				continue;
			}

			NeighborBufferUV = clamp(NeighborBufferUV, View.BufferBilinearUVMinMax.xy, View.BufferBilinearUVMinMax.zw);
		}
		float2 SampleViewportUV = BufferUVToViewportUV(NeighborBufferUV);
		float2 SampleScreenPosition = ViewportUVToScreenPos(SampleViewportUV);

		// Sample the neighborhood.
		FSSFSignalSample NeighborSample = SampleInputSignal(SignalInput0, SignalInput1, GlobalPointClampedSampler, CONFIG_SIGNAL_INPUT_LAYOUT, NeighborBufferUV);
		FSSFSampleSceneInfos NeighborSceneMetadata = FetchCurrentSceneInfos(SampleScreenPosition, NeighborBufferUV);

		float NeighborWorldBluringRadius = ComputePixelWorldRadius(NeighborSceneMetadata);

		// Compute the bilateral weight.
		float BilateralWeight = BilateralWeightAdjustement * ComputeBilateralWeight(
			WorldBluringRadiusToBilateralWorldDistance(min(CurrentWorldBluringRadius, NeighborWorldBluringRadius)),
			CurrentSceneMetadata,
			NeighborSceneMetadata);

		// Multiple importance sampling weights.
		float MISWeight = GetMultiImportanceSamplingWeight(CurrentSceneMetadata, NeighborSceneMetadata, NeighborSample);

		// Compute the weight of the sample in the kernel.
		#if CONFIG_SAMPLE_SET == SAMPLE_SET_3X3
			float KernelWeight = 1;

		#elif CONFIG_SAMPLE_SET == SAMPLE_SET_5X5_WAVELET
			float KernelWeight = 
				kWaveletFilterWeights[abs(x)] *
				kWaveletFilterWeights[abs(y)] *
				rcp(kWaveletFilterWeights[0] * kWaveletFilterWeights[0]);

		#else
			#error Unknown set of samples.
		#endif

		// Compute the final weight of that sample.
		float FinalWeight = BilateralWeight * MISWeight * KernelWeight;
		
		Accumulator = Add(Accumulator, Mul(NeighborSample, FinalWeight));
	}

	#if CONFIG_NORMALIZE_OUTPUT
	{
		Accumulator = NormalizeToOneSample(Accumulator);
	}
	#endif

	// TODO:  LeaveRayCount = (LeaveRayCount - 1) * 9 / (9 - 2) post processing to reject when for history rejection

	OutputSignal(SignalOutput0, SignalOutput1, CONFIG_SIGNAL_OUTPUT_LAYOUT, DispatchThreadId, Accumulator);
}
