// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

#ifndef DIM_DENOISER_OUTPUT
	#define DIM_DENOISER_OUTPUT 0
#endif

#include "../Common.ush"

float2 SobolIndexToUniformUnitSquare(uint2 SobolRand)
{
	return float2(SobolRand) * rcp(65536.0) + rcp(65536.0 * 2.0);
}

#define SUPPORT_CONTACT_SHADOWS		0
#define USE_SOURCE_TEXTURE			0 //Used in RectLight.ush  //#dxr_todo: enable textures

#include "../DeferredShadingCommon.ush"
#include "../DeferredLightingCommon.ush"
#include "../ReflectionEnvironmentShared.ush"
#include "../Montecarlo.ush"
#include "../PathTracing/Utilities/PathTracingRandomSequence.ush" // #dxr-todo: move to a common folder
#include "../HeightFogCommon.ush"
#include "RayTracingCommon.ush"
#include "RayTracingHitGroupCommon.ush"

uint SamplesPerPixel;
uint HeightFog;
uint ShouldDoDirectLighting;
uint ShouldDoReflectedShadows;
uint ShouldDoEmissiveAndIndirectLighting;
uint UpscaleFactor;

float ReflectionMinRayDistance;
float ReflectionMaxRayDistance;
float ReflectionMaxRoughness;

RaytracingAccelerationStructure TLAS;

RWTexture2D<float4> ColorOutput;
RWTexture2D<float> RayHitDistanceOutput;

#include "RayTracingLightingCommon.ush"

// #dxr-todo: move to RayTracingCommon.ush
float3 ReconstructWorldPositionFromDepth(float2 UV, float Depth)
{
	float2 ScreenPosition = (UV - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;
	float4 HomogeneousWorldPosition = mul(float4(ScreenPosition * Depth, Depth, 1), View.ScreenToWorld);
	float3 WorldPosition = HomogeneousWorldPosition.xyz / HomogeneousWorldPosition.w;

	return WorldPosition;
}

uint2 GetPixelCoord(uint2 DispatchThreadId)
{
	uint UpscaleFactorPow2 = UpscaleFactor * UpscaleFactor;

	// TODO: find a way to not interfer with TAA's jittering.
	uint SubPixelId = View.StateFrameIndex & (UpscaleFactorPow2 - 1);

	return DispatchThreadId * UpscaleFactor + uint2(SubPixelId & (UpscaleFactor - 1), SubPixelId / UpscaleFactor);
}


[shader("raygeneration")]
void RayTracingTranslucencyRGS()
{
	uint2 DispatchThreadId = DispatchRaysIndex().xy;

	uint2 PixelCoord = GetPixelCoord(DispatchThreadId);
	
	uint LinearIndex = PixelCoord.y * View.BufferSizeAndInvSize.x + PixelCoord.x; // TODO: PixelCoord or DispatchThreadId
	
	RandomSequence RandSequence;
	RandomSequence_Initialize(RandSequence, LinearIndex, View.FrameNumber);

	float2 InvBufferSize = View.BufferSizeAndInvSize.zw;
	float2 UV = (float2(PixelCoord) + 0.5) * InvBufferSize;
	FScreenSpaceData ScreenSpaceData = GetScreenSpaceData(UV);
	float Depth = ScreenSpaceData.GBuffer.Depth;
	float3 CameraOrigin = ReconstructWorldPositionFromDepth(UV, 0.0f);
	float3 WorldPosition = ReconstructWorldPositionFromDepth(UV, Depth);
	float3 CameraDirection = normalize(WorldPosition - CameraOrigin);
	//#dxr - todo: use also the shading normal (interpolate, or apply a more sophisticated approach)
	float3 WorldNormal = ScreenSpaceData.GBuffer.WorldNormal;
	float Roughness = ScreenSpaceData.GBuffer.Roughness;
	
	float3 BRDFThroughput = float3(1.0f, 1.0f, 1.0f);

	uint MaxBounces = 1; //#dxr-todo: only works with 1 bounce until hit shaders are supported
	uint LocalSamplesPerPixel = SamplesPerPixel;

	// Mask out depth values at or beyond far plane
	if (Depth >= SCENE_TEXTURES_DISABLED_SCENE_DEPTH_VALUE)
	{
		LocalSamplesPerPixel = 0;
	}

	float4 TranslucencyColor = 0.0;
	float HitDistance = 0.0f;

	ColorOutput[DispatchThreadId] = float4(TranslucencyColor);
	RayHitDistanceOutput[DispatchThreadId] = HitDistance;
}


[shader("miss")]
void RayTracingTranslucencyMainMS(inout FPackedMaterialClosestHitPayload PackedPayload)
{
	PackedPayload.Payload.HitT = -1;
}


[shader("closesthit")]
void RayTracingTranslucencyMainCHS(inout FPackedMaterialClosestHitPayload PackedPayload, in FDefaultAttributes Attributes)
{
	FMaterialClosestHitPayload Payload = (FMaterialClosestHitPayload)0;

	Payload.HitT = RayTCurrent();
	Payload.BaseColor = float3(0.2, 0.3, 0.4);

	FTriangleBaseAttributes Triangle = LoadTriangleBaseAttributes(PrimitiveIndex());
	float3 Edge0 = Triangle.LocalPositions[2] - Triangle.LocalPositions[0];
	float3 Edge1 = Triangle.LocalPositions[1] - Triangle.LocalPositions[0];
	float3x3 WorldToLocal = (float3x3)WorldToObject();
	float3x3 LocalToWorldNormal = transpose(WorldToLocal);
	Payload.WorldNormal = normalize(mul(LocalToWorldNormal, cross(Edge0, Edge1)));

	PackedPayload = PackRayTracingPayload(Payload, PackedPayload.RayCone);
}
