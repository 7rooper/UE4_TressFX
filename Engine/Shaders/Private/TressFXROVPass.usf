#include "Common.ush"

// Reroute SceneTexturesStruct uniform buffer references to the appropriate base pass uniform buffer
#if MATERIALBLENDING_TRANSLUCENT || MATERIALBLENDING_ADDITIVE || MATERIALBLENDING_MODULATE
	#define SceneTexturesStruct TranslucentBasePass.SceneTextures 
	#define EyeAdaptationStruct TranslucentBasePass.SceneTextures
#else
	#define EyeAdaptationStruct OpaqueBasePass
#endif 

#include "SHCommon.ush"
#include "/Engine/Generated/Material.ush"
#include "BasePassCommon.ush"
#include "/Engine/Generated/VertexFactory.ush"
#include "LightmapCommon.ush" 
#include "PlanarReflectionShared.ush"
#include "BRDF.ush"
#include "Random.ush"
#include "LightAccumulator.ush"
#include "DeferredShadingCommon.ush"
#include "VelocityCommon.ush"
#include "SphericalGaussian.ush"
#include "DBufferDecalShared.ush"
#include "TressFXCommon.ush"
#include "TressFXShortCutCommon.ush"
#include "TressFXRendering.ush"
#include "ReflectionEnvironmentShared.ush"
#include "ShadowFilteringCommon.ush"

#define PREV_FRAME_COLOR	1
#include "ScreenSpaceRayCast.ush"

#if NEEDS_BASEPASS_PIXEL_FOGGING || NEEDS_BASEPASS_PIXEL_VOLUMETRIC_FOGGING
	#include "HeightFogCommon.ush"
#endif

#include "ReflectionEnvironmentShared.ush"

#ifndef TRESSFX_ALLOW_PRECOMPUTED_LIGHTING 
	#define TRESSFX_ALLOW_PRECOMPUTED_LIGHTING 1
#endif

#ifndef TRESSFX_UNREAL_HAIR_ONLY 
	#define TRESSFX_UNREAL_HAIR_ONLY 1
#endif

#ifndef TRESSFX_DIRECTIONAL_LIGHT_ONLY 
	#define TRESSFX_DIRECTIONAL_LIGHT_ONLY 0
#endif

#ifndef OPTIONAL_IsFrontFace
#define OPTIONAL_IsFrontFace
#endif

struct PS_INPUT_HAIR_AA
{
    float4 Position : SV_POSITION;
    FVertexFactoryInterpolantsVSToPS FactoryInterpolants;

};

float NormalCurvatureToRoughness(float3 WorldNormal)
{
    float3 dNdx = ddx(WorldNormal);
    float3 dNdy = ddy(WorldNormal);
    float x = dot(dNdx, dNdx);
    float y = dot(dNdy, dNdy);
    float CurvatureApprox = pow(max(x, y), View.NormalCurvatureToRoughnessScaleBias.z);
	return saturate(CurvatureApprox * View.NormalCurvatureToRoughnessScaleBias.x + View.NormalCurvatureToRoughnessScaleBias.y);
}

#if TRANSLUCENT_SELF_SHADOWING
	#include "ShadowProjectionCommon.ush"	 
#endif

#include "ShadingModelsMaterial.ush"
#if MATERIAL_SHADINGMODEL_HAIR || SIMPLE_FORWARD_DIRECTIONAL_LIGHT
#include "ShadingModels.ush"
#endif

#ifndef COMPILER_GLSL
	#define COMPILER_GLSL 0
#endif

#define FORCE_FULLY_ROUGH (SIMPLE_FORWARD_SHADING || MATERIAL_FULLY_ROUGH)
#define EDITOR_ALPHA2COVERAGE (USE_EDITOR_COMPOSITING && SUPPORTS_PIXEL_COVERAGE)
#define POST_PROCESS_SUBSURFACE ((MATERIAL_SHADINGMODEL_SUBSURFACE_PROFILE || MATERIAL_SHADINGMODEL_EYE) && USES_GBUFFER)

#if TRANSLUCENCY_LIGHTING_SURFACE_LIGHTINGVOLUME || TRANSLUCENCY_LIGHTING_SURFACE_FORWARDSHADING || FORWARD_SHADING
#include "ForwardLightingCommon.ush" 
#endif

#if !FORWARD_SHADING

void GetVolumeLightingNonDirectional(float4 AmbientLightingVector, float3 DiffuseColor, inout float3 InterpolatedLighting, out float4 VolumeLighting)
{
	// Normal is not taken into account with non directional lighting, and only the ambient term of the SH coefficients are needed
	FOneBandSHVectorRGB TranslucentLighting;
	TranslucentLighting.R.V.x = AmbientLightingVector.r;
	TranslucentLighting.G.V.x = AmbientLightingVector.g;
	TranslucentLighting.B.V.x = AmbientLightingVector.b;

	FOneBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH1(1);
	VolumeLighting = float4(DotSH1(TranslucentLighting, DiffuseTransferSH), AmbientLightingVector.a);
	InterpolatedLighting = DiffuseColor * VolumeLighting.rgb;
}

void GetVolumeLightingDirectional(float4 AmbientLightingVector, float3 DirectionalLightingVector, float3 WorldNormal, float3 DiffuseColor, inout float3 InterpolatedLighting, out float4 VolumeLighting)
{
	float DirectionalLightingIntensity = GetMaterialTranslucencyDirectionalLightingIntensity();

	AmbientLightingVector.rgb /= DirectionalLightingIntensity;
	DirectionalLightingVector.rgb *= DirectionalLightingIntensity;

	// Reconstruct the SH coefficients based on what was encoded
	FTwoBandSHVectorRGB TranslucentLighting;
	TranslucentLighting.R.V.x = AmbientLightingVector.r;
	TranslucentLighting.G.V.x = AmbientLightingVector.g;
	TranslucentLighting.B.V.x = AmbientLightingVector.b;
	float3 NormalizedAmbientColor = AmbientLightingVector.rgb / ( Luminance( AmbientLightingVector.rgb ) + 0.00001f );

	// Scale the monocrome directional coefficients with the normalzed ambient color as an approximation to the uncompressed values
	TranslucentLighting.R.V.yzw = DirectionalLightingVector.rgb * NormalizedAmbientColor.r;
	TranslucentLighting.G.V.yzw = DirectionalLightingVector.rgb * NormalizedAmbientColor.g;
	TranslucentLighting.B.V.yzw = DirectionalLightingVector.rgb * NormalizedAmbientColor.b;
			
	// Compute diffuse lighting which takes the normal into account
	FTwoBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH(WorldNormal, 1);
	VolumeLighting = float4(max(half3(0,0,0), DotSH(TranslucentLighting, DiffuseTransferSH)), AmbientLightingVector.a);
	InterpolatedLighting += DiffuseColor * VolumeLighting.rgb;
}

#endif

#if SIMPLE_FORWARD_SHADING
	#define GetEffectiveSkySHDiffuse GetSkySHDiffuseSimple
#else
	#define GetEffectiveSkySHDiffuse GetSkySHDiffuse
#endif

/** Computes sky diffuse lighting, including precomputed shadowing. */
void GetSkyLighting(FMaterialPixelParameters MaterialParameters, float3 WorldNormal, float2 LightmapUV, float3 SkyOcclusionUV3D, out float3 OutDiffuseLighting, out float3 OutSubsurfaceLighting)
{
	OutDiffuseLighting = 0;
	OutSubsurfaceLighting = 0;

#if ENABLE_SKY_LIGHT

	float SkyVisibility = 1;
	float GeometryTerm = 1;
	float3 SkyLightingNormal = WorldNormal;
	
	#if HQ_TEXTURE_LIGHTMAP || CACHED_POINT_INDIRECT_LIGHTING || CACHED_VOLUME_INDIRECT_LIGHTING || PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
		BRANCH
		if (View.SkyLightParameters.x > 0)
		{
			float3 NormalizedBentNormal = SkyLightingNormal;

			#if PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
			
				float3 SkyBentNormal = GetVolumetricLightmapSkyBentNormal(SkyOcclusionUV3D);
				SkyVisibility = length(SkyBentNormal);
				NormalizedBentNormal = SkyBentNormal / max(SkyVisibility, .0001f);

			#elif HQ_TEXTURE_LIGHTMAP

				// Bent normal from precomputed texture
				float4 WorldSkyBentNormalAndOcclusion = GetSkyBentNormalAndOcclusion(LightmapUV * float2(1, 2), MaterialParameters.SvPosition.xy);
				// Renormalize as vector was quantized and compressed
				NormalizedBentNormal = normalize(WorldSkyBentNormalAndOcclusion.xyz);
				SkyVisibility = WorldSkyBentNormalAndOcclusion.w;

			#elif CACHED_POINT_INDIRECT_LIGHTING || CACHED_VOLUME_INDIRECT_LIGHTING

				// Bent normal from the indirect lighting cache - one value for the whole object
				if (View.IndirectLightingCacheShowFlag > 0.0f)
				{
					NormalizedBentNormal = IndirectLightingCache.PointSkyBentNormal.xyz;
					SkyVisibility = IndirectLightingCache.PointSkyBentNormal.w;
				}

			#endif

			#if (MATERIALBLENDING_TRANSLUCENT || MATERIALBLENDING_ADDITIVE) && (TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL || TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_NONDIRECTIONAL)
				// NonDirectional lighting can't depend on the normal
				SkyLightingNormal = NormalizedBentNormal;
			#else
				
				// Weight toward the material normal to increase directionality
				float BentNormalWeightFactor = 1 - (1 - SkyVisibility) * (1 - SkyVisibility);

				// We are lerping between the inputs of two lighting scenarios based on occlusion
				// In the mostly unoccluded case, evaluate sky lighting with the material normal, because it has higher detail
				// In the mostly occluded case, evaluate sky lighting with the bent normal, because it is a better representation of the incoming lighting
				// Then treat the lighting evaluated along the bent normal as an area light, so we must apply the lambert term
				SkyLightingNormal = lerp(NormalizedBentNormal, WorldNormal, BentNormalWeightFactor);

				float DotProductFactor = lerp(saturate(dot(NormalizedBentNormal, WorldNormal)), 1, BentNormalWeightFactor);
				// Account for darkening due to the geometry term
				GeometryTerm = DotProductFactor;
			#endif
		}
	#endif
			
	// Compute the preconvolved incoming lighting with the bent normal direction
	float3 DiffuseLookup = GetEffectiveSkySHDiffuse(SkyLightingNormal) * ResolvedView.SkyLightColor.rgb;

	// Apply AO to the sky diffuse
	OutDiffuseLighting += DiffuseLookup * (SkyVisibility * GeometryTerm);

	#if MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE
		float3 BackfaceDiffuseLookup = GetEffectiveSkySHDiffuse(-WorldNormal) * ResolvedView.SkyLightColor.rgb;
		OutSubsurfaceLighting += BackfaceDiffuseLookup * SkyVisibility;
	#endif

#endif
}

#if SUPPORTS_INDEPENDENT_SAMPLERS
	#define ILCSharedSampler1 View.SharedBilinearClampedSampler
	#define ILCSharedSampler2 View.SharedBilinearClampedSampler
#else
	#define ILCSharedSampler1 IndirectLightingCache.IndirectLightingCacheTextureSampler1
	#define ILCSharedSampler2 IndirectLightingCache.IndirectLightingCacheTextureSampler2
#endif

/** Calculates indirect lighting contribution on this object from precomputed data. */
void GetPrecomputedIndirectLightingAndSkyLight(
	FMaterialPixelParameters MaterialParameters, 
	FVertexFactoryInterpolantsVSToPS Interpolants,
	float3 DiffuseDir,
	float3 VolumetricLightmapBrickTextureUVs,
	out float3 OutDiffuseLighting,
	out float3 OutSubsurfaceLighting,
	out float OutIndirectIrradiance)
{
	OutIndirectIrradiance = 0;
	OutDiffuseLighting = 0;
	OutSubsurfaceLighting = 0;
	float2 SkyOcclusionUV = 0;

	#if PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING

	#if TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL || TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_NONDIRECTIONAL


			FOneBandSHVectorRGB IrradianceSH = GetVolumetricLightmapSH1(VolumetricLightmapBrickTextureUVs);
			FOneBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH1(1);
			OutDiffuseLighting = max(float3(0,0,0), DotSH1(IrradianceSH, DiffuseTransferSH)) / PI;

	#else

			FThreeBandSHVectorRGB IrradianceSH = GetVolumetricLightmapSH3(VolumetricLightmapBrickTextureUVs);
			// Diffuse convolution
			FThreeBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH3(DiffuseDir, 1);
			OutDiffuseLighting = max(float3(0,0,0), DotSH3(IrradianceSH, DiffuseTransferSH)) / PI;

	#endif


	// Method for movable components which want to use a volume texture of interpolated SH samples
	#elif CACHED_VOLUME_INDIRECT_LIGHTING
		if (View.IndirectLightingCacheShowFlag > 0.0f)
		{
			// Compute volume texture UVs from world position
			float3 VolumeUVs = MaterialParameters.AbsoluteWorldPosition * IndirectLightingCache.IndirectLightingCachePrimitiveScale + IndirectLightingCache.IndirectLightingCachePrimitiveAdd;
			// Clamp UV to be within the valid region
			// Pixels outside of the object's bounding box would read garbage otherwise
			VolumeUVs = clamp(VolumeUVs, IndirectLightingCache.IndirectLightingCacheMinUV, IndirectLightingCache.IndirectLightingCacheMaxUV);
			float4 Vector0 = Texture3DSample(IndirectLightingCache.IndirectLightingCacheTexture0, IndirectLightingCache.IndirectLightingCacheTextureSampler0, VolumeUVs);

			// For debugging
			#define AMBIENTONLY 0
			#if AMBIENTONLY

				OutDiffuseLighting = Vector0.rgb / SHAmbientFunction() / PI;

			#else

				float4 Vector1 = Texture3DSample(IndirectLightingCache.IndirectLightingCacheTexture1, ILCSharedSampler1, VolumeUVs);
				float4 Vector2 = Texture3DSample(IndirectLightingCache.IndirectLightingCacheTexture2, ILCSharedSampler2, VolumeUVs);

				// Construct the SH environment
				FTwoBandSHVectorRGB CachedSH;
				CachedSH.R.V = float4(Vector0.x, Vector1.x, Vector2.x, Vector0.w);
				CachedSH.G.V = float4(Vector0.y, Vector1.y, Vector2.y, Vector1.w);
				CachedSH.B.V = float4(Vector0.z, Vector1.z, Vector2.z, Vector2.w);

				// Diffuse convolution
				FTwoBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH(DiffuseDir, 1);
				OutDiffuseLighting = max(half3(0,0,0), DotSH(CachedSH, DiffuseTransferSH)) / PI;

			#endif
		}

	// Method for movable components which want to use a single interpolated SH sample
	#elif CACHED_POINT_INDIRECT_LIGHTING 
		if (View.IndirectLightingCacheShowFlag > 0.0f)
		{
		#if TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL

			FOneBandSHVectorRGB PointIndirectLighting;
			PointIndirectLighting.R.V = IndirectLightingCache.IndirectLightingSHCoefficients0[0].x;
			PointIndirectLighting.G.V = IndirectLightingCache.IndirectLightingSHCoefficients0[1].x;
			PointIndirectLighting.B.V = IndirectLightingCache.IndirectLightingSHCoefficients0[2].x;

			FOneBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH1(1);
			OutDiffuseLighting = DotSH1(PointIndirectLighting, DiffuseTransferSH);

		#else

			FThreeBandSHVectorRGB PointIndirectLighting;
			PointIndirectLighting.R.V0 = IndirectLightingCache.IndirectLightingSHCoefficients0[0];
			PointIndirectLighting.R.V1 = IndirectLightingCache.IndirectLightingSHCoefficients1[0];
			PointIndirectLighting.R.V2 = IndirectLightingCache.IndirectLightingSHCoefficients2[0];

			PointIndirectLighting.G.V0 = IndirectLightingCache.IndirectLightingSHCoefficients0[1];
			PointIndirectLighting.G.V1 = IndirectLightingCache.IndirectLightingSHCoefficients1[1];
			PointIndirectLighting.G.V2 = IndirectLightingCache.IndirectLightingSHCoefficients2[1];

			PointIndirectLighting.B.V0 = IndirectLightingCache.IndirectLightingSHCoefficients0[2];
			PointIndirectLighting.B.V1 = IndirectLightingCache.IndirectLightingSHCoefficients1[2];
			PointIndirectLighting.B.V2 = IndirectLightingCache.IndirectLightingSHCoefficients2[2];

			FThreeBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH3(DiffuseDir, 1);
			// Compute diffuse lighting which takes the normal into account
			OutDiffuseLighting = max(half3(0,0,0), DotSH3(PointIndirectLighting, DiffuseTransferSH));

			#if MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE
				FThreeBandSHVector SubsurfaceTransferSH = CalcDiffuseTransferSH3(-DiffuseDir, 1);
				OutSubsurfaceLighting += max(half3(0,0,0), DotSH3(PointIndirectLighting, SubsurfaceTransferSH));
			#endif
		
		#endif
		}

	// High quality texture lightmaps
	#elif HQ_TEXTURE_LIGHTMAP

		float2 LightmapUV0, LightmapUV1;
		uint LightmapDataIndex;
		GetLightMapCoordinates(Interpolants, LightmapUV0, LightmapUV1, LightmapDataIndex);
		SkyOcclusionUV = LightmapUV0;

		uint VTRequest = 0;
		GetLightMapColorHQ(LightmapUV0, LightmapUV1, LightmapDataIndex, DiffuseDir, MaterialParameters.SvPosition.xy, OutDiffuseLighting, OutSubsurfaceLighting, VTRequest);

	#if LIGHTMAP_VT_ENABLED
		uint2 PixelPos = (uint2)MaterialParameters.SvPosition.xy;
		if( ( (PixelPos.x | PixelPos.y) & 15 ) == 0 )
		{
			// TODO use append buffer
			VTFeedbackBuffer[ PixelPos / 16 ] = VTRequest;
		}
	#endif


	// Low quality texture lightmaps
	#elif LQ_TEXTURE_LIGHTMAP

		float2 LightmapUV0, LightmapUV1;
		uint LightmapDataIndex;
		GetLightMapCoordinates(Interpolants, LightmapUV0, LightmapUV1, LightmapDataIndex);
		OutDiffuseLighting = GetLightMapColorLQ(LightmapUV0, LightmapUV1, LightmapDataIndex, DiffuseDir).rgb;

	#endif

	// Apply indirect lighting scale while we have only accumulated lightmaps
	OutDiffuseLighting *= View.IndirectLightingColorScale;
	OutSubsurfaceLighting *= View.IndirectLightingColorScale;

	float3 SkyDiffuseLighting;
	float3 SkySubsurfaceLighting;
	GetSkyLighting(MaterialParameters, DiffuseDir, SkyOcclusionUV, VolumetricLightmapBrickTextureUVs, SkyDiffuseLighting, SkySubsurfaceLighting);

	OutSubsurfaceLighting += SkySubsurfaceLighting;

	// Sky lighting must contribute to IndirectIrradiance for ReflectionEnvironment lightmap mixing
	OutDiffuseLighting += SkyDiffuseLighting;

	#if HQ_TEXTURE_LIGHTMAP || LQ_TEXTURE_LIGHTMAP || CACHED_VOLUME_INDIRECT_LIGHTING || CACHED_POINT_INDIRECT_LIGHTING || PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
		OutIndirectIrradiance = Luminance(OutDiffuseLighting);
	#endif
}

#if SIMPLE_FORWARD_DIRECTIONAL_LIGHT

float3 GetSimpleForwardLightingDirectionalLight(FGBufferData GBuffer, float3 DiffuseColor, float3 SpecularColor, float Roughness, float3 WorldNormal, float3 CameraVector)
{
	float3 V = -CameraVector;
	float3 N = WorldNormal;
	float3 L = ResolvedView.DirectionalLightDirection;
	float NoL = saturate( dot( N, L ) );

	float3 LightColor = ResolvedView.DirectionalLightColor.rgb * PI;
	
	FShadowTerms Shadow = { 1, 1, 1 };
	FDirectLighting Lighting = EvaluateBxDF( GBuffer, N, V, L, NoL, Shadow );

	// Not computing specular, material was forced fully rough
	return LightColor * (Lighting.Diffuse + Lighting.Transmission);
}

#endif

void ApplyPixelDepthOffsetForBasePass(inout FMaterialPixelParameters MaterialParameters, FPixelMaterialInputs PixelMaterialInputs, inout FBasePassInterpolantsVSToPS BasePassInterpolants, out float OutDepth)
{
	float PixelDepthOffset = ApplyPixelDepthOffsetToMaterialParameters(MaterialParameters, PixelMaterialInputs, OutDepth);

#if WRITES_VELOCITY_TO_GBUFFER
	BasePassInterpolants.VelocityPrevScreenPosition.w += PixelDepthOffset;

	#if WRITES_VELOCITY_TO_GBUFFER_USE_POS_INTERPOLATOR
		BasePassInterpolants.VelocityScreenPosition.w += PixelDepthOffset;
	#endif
#endif
}

// [ Jimenez et al. 2016, "Practical Realtime Strategies for Accurate Indirect Occlusion" ]
float3 AOMultiBounce( float3 BaseColor, float AO )
{
	float3 a =  2.0404 * BaseColor - 0.3324;
	float3 b = -4.7951 * BaseColor + 0.6417;
	float3 c =  2.7552 * BaseColor + 0.6903;
	return max( AO, ( ( AO * a + b ) * AO + c ) * AO );
}

float DotSpecularSG( float Roughness, float3 N, float3 V, FSphericalGaussian LightSG )
{
	float a = Pow2( max( 0.02, Roughness ) );
	float a2 = a*a;
	
	float3 L = LightSG.Axis;
	float3 H = normalize(V + L);

	float NoV = saturate( abs( dot(N, V) ) + 1e-5 );

	FSphericalGaussian NDF;
	NDF.Axis = N;
	NDF.Sharpness = 2 / a2;
	NDF.Amplitude = rcp( PI * a2 );

#if 0
	{
		// Reflect NDF
		//float3 R = 2 * dot( V, N ) * N - V;
		float3 R = 2 * NoV * N - V;

		// Point lobe in off-specular peak direction
		//R = lerp( N, R, (1 - a) * ( sqrt(1 - a) + a ) );
		//R = normalize( R );

	#if 0
		// Warp
		FSphericalGaussian SpecularSG;
		SpecularSG.Axis = R;
		SpecularSG.Sharpness = 0.5 / ( a2 * max( NoV, 0.1 ) );
		SpecularSG.Amplitude = rcp( PI * a2 );
	#else
		FAnisoSphericalGaussian SpecularSG;
		SpecularSG.AxisZ = R;
		SpecularSG.AxisX = normalize( cross( N, SpecularSG.AxisZ ) );
		SpecularSG.AxisY = normalize( cross( R, SpecularSG.AxisX ) );
 
		// Second derivative of the sharpness with respect to how
		// far we are from basis Axis direction
		SpecularSG.SharpnessX = 0.25 / ( a2 * Pow2( max( NoV, 0.001 ) ) );
		SpecularSG.SharpnessY = 0.25 / a2;
		SpecularSG.Amplitude = rcp( PI * a2 );
	#endif
		return Dot( SpecularSG, LightSG );
	}
#elif 0
	{
		// Project LightSG into half vector space
	#if 0
		FSphericalGaussian WarpedLightSG;
		WarpedLightSG.Axis		= H;
		WarpedLightSG.Sharpness	= LightSG.Sharpness * 1.5 * NoV;
		WarpedLightSG.Amplitude	= LightSG.Amplitude;
	#else
		FAnisoSphericalGaussian WarpedLightSG;
		WarpedLightSG.AxisZ = H;
		WarpedLightSG.AxisX = normalize( cross( N, WarpedLightSG.AxisZ ) );
		WarpedLightSG.AxisY = normalize( cross( H, WarpedLightSG.AxisX ) );
 
		// Second derivative of the sharpness with respect to how
		// far we are from basis Axis direction
		WarpedLightSG.SharpnessX = LightSG.Sharpness * 2 * Pow2( NoV );
		WarpedLightSG.SharpnessY = LightSG.Sharpness * 2;
		WarpedLightSG.Amplitude	= LightSG.Amplitude;
	#endif

		return Dot( WarpedLightSG, NDF );
	}
#else
	{
		// We can do the half space ASG method cheaper by assuming H is in the YZ plane.
		float SharpnessX = LightSG.Sharpness * 2 * Pow2( NoV );
		float SharpnessY = LightSG.Sharpness * 2;

		float nu = NDF.Sharpness * 0.5;

		FSphericalGaussian ConvolvedNDF;
		ConvolvedNDF.Axis = NDF.Axis;
		ConvolvedNDF.Sharpness = 2 * (nu * SharpnessY) / (nu + SharpnessY);
		ConvolvedNDF.Amplitude = NDF.Amplitude * LightSG.Amplitude;
		ConvolvedNDF.Amplitude *= PI * rsqrt( (nu + SharpnessX) * (nu + SharpnessY) );

		//float3 AxisX = normalize( cross( N, V ) );
		//ConvolvedNDF.Amplitude *= exp( -(nu * SharpnessX) / (nu + SharpnessX) * Pow2( dot( H, AxisX ) ) );

		return Evaluate( ConvolvedNDF, H );
	}
#endif
}

void ApplyBentNormal( in FMaterialPixelParameters MaterialParameters, in float Roughness, inout float3 BentNormal, inout float DiffOcclusion, inout float SpecOcclusion )
{
#if NUM_MATERIAL_OUTPUTS_GETBENTNORMAL > 0
	#if MATERIAL_TANGENTSPACENORMAL
		BentNormal = normalize( TransformTangentVectorToWorld( MaterialParameters.TangentToWorld, GetBentNormal0(MaterialParameters) ) );
	#else
		BentNormal = GetBentNormal0(MaterialParameters);
	#endif

	FSphericalGaussian HemisphereSG = Hemisphere_ToSphericalGaussian( MaterialParameters.WorldNormal );
	FSphericalGaussian NormalSG = ClampedCosine_ToSphericalGaussian( MaterialParameters.WorldNormal );
	FSphericalGaussian VisibleSG = BentNormalAO_ToSphericalGaussian( BentNormal, DiffOcclusion );
	FSphericalGaussian DiffuseSG = Mul( NormalSG, VisibleSG );
	
	float VisibleCosAngle = sqrt( 1 - DiffOcclusion );

#if 1	// Mix full resolution normal with low res bent normal
	BentNormal = DiffuseSG.Axis;
	//DiffOcclusion = saturate( Integral( DiffuseSG ) / Dot( NormalSG, HemisphereSG ) );
	DiffOcclusion = saturate( Integral( DiffuseSG ) * 0.42276995 );
#endif

	float3 N = MaterialParameters.WorldNormal;
	float3 V = MaterialParameters.CameraVector;

	SpecOcclusion  = DotSpecularSG( Roughness, N, V, VisibleSG );
	SpecOcclusion /= DotSpecularSG( Roughness, N, V, HemisphereSG );

	SpecOcclusion = saturate( SpecOcclusion );
#endif
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////

RasterizerOrderedTexture2D<float4> GbufferA;
RasterizerOrderedTexture2D<float4> GbufferB;
RasterizerOrderedTexture2D<float4> GbufferE;
RasterizerOrderedTexture2D<float4> GbufferC;

RasterizerOrderedTexture2D<float4> SceneColor;

//EARLYDEPTHSTENCIL
void main(PS_INPUT_HAIR_AA input OPTIONAL_IsFrontFace)
{
    uint2 screenAddr = uint2(input.Position.xy);
    float ExistingDepth = SceneTexturesStruct.SceneDepthTexture[screenAddr].r;

    if (ExistingDepth >= input.Position.z)
    {
        return;
    }

    float4 viewport = float4(View.ViewRectMin.xy, View.ViewSizeAndInvSize.xy);
    float3 vNDC = ScreenPosToNDC(input.Position.xyz, viewport);
    float coverage = ComputeCoverage(input.FactoryInterpolants.p0p1.xy, input.FactoryInterpolants.p0p1.zw, vNDC.xy, viewport.zw);

    ResolvedView = ResolveView();

    FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(input.FactoryInterpolants, input.Position);
    FPixelMaterialInputs PixelMaterialInputs;
	
#if HQ_TEXTURE_LIGHTMAP && USES_AO_MATERIAL_MASK && !MATERIAL_SHADINGMODEL_UNLIT
	{
		float2 LightmapUV0, LightmapUV1;
		uint LightmapDataIndex;
		GetLightMapCoordinates(Interpolants, LightmapUV0, LightmapUV1, LightmapDataIndex);
		// Must be computed before BaseColor, Normal, etc are evaluated
		MaterialParameters.AOMaterialMask = GetAOMaterialMask(LightmapUV0 * float2(1, 2), In.SvPosition.xy);
	}
#endif

	//TODO this path will never work because we dont have BasePassInterpolants.PixelPositionExcludingWPO
	#if USE_WORLD_POSITION_EXCLUDING_SHADER_OFFSETS
		{
			float4 ScreenPosition = SvPositionToResolvedScreenPosition(input.Position);
			float3 TranslatedWorldPosition = SvPositionToResolvedTranslatedWorld(input.Position);
			CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, In.SvPosition, ScreenPosition, In.bIsFrontFace, TranslatedWorldPosition, BasePassInterpolants.PixelPositionExcludingWPO);
		}
	#else
		{
        float4 ScreenPosition = SvPositionToResolvedScreenPosition(input.Position);
        float3 TranslatedWorldPosition = SvPositionToResolvedTranslatedWorld(input.Position);
        CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, In.SvPosition, ScreenPosition, In.bIsFrontFace, TranslatedWorldPosition, TranslatedWorldPosition);
    }
	#endif

    half Opacity = GetMaterialOpacity(PixelMaterialInputs);
    float TFXAlpha = coverage * Opacity;

    half3 BaseColor = GetMaterialBaseColor(PixelMaterialInputs);
    half Metallic = GetMaterialMetallic(PixelMaterialInputs);
    half Specular = GetMaterialSpecular(PixelMaterialInputs);
    float MaterialAO = GetMaterialAmbientOcclusion(PixelMaterialInputs);
    float Roughness = GetMaterialRoughness(PixelMaterialInputs);
    float SubsurfaceProfile = 0;
    float3 SubsurfaceColor = 0;

    float3 VolumetricLightmapBrickTextureUVs;
		
#if PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
	VolumetricLightmapBrickTextureUVs = ComputeVolumetricLightmapBrickTextureUVs(MaterialParameters.AbsoluteWorldPosition);
#endif

    FGBufferData GBuffer = (FGBufferData) 0;
    GBuffer.GBufferAO = MaterialAO;
    GBuffer.PerObjectGBufferData = GetPrimitiveData(MaterialParameters.PrimitiveId).PerObjectGBufferData;
    GBuffer.Depth = MaterialParameters.ScreenPosition.w;
    GBuffer.PrecomputedShadowFactors = GetPrecomputedShadowMasks(input.FactoryInterpolants, MaterialParameters.PrimitiveId, MaterialParameters.AbsoluteWorldPosition, VolumetricLightmapBrickTextureUVs);

    const float GBufferDither = InterleavedGradientNoise(MaterialParameters.SvPosition.xy, View.StateFrameIndexMod8);
    SetGBufferForShadingModel(
		GBuffer,
		MaterialParameters,
		Opacity,
		BaseColor,
		Metallic,
		Specular,
		Roughness,
		SubsurfaceColor,
		SubsurfaceProfile,
		GBufferDither);

	// So that the following code can still use DiffuseColor and SpecularColor.
    GBuffer.SpecularColor = ComputeF0(Specular, BaseColor, Metallic);

    GBuffer.SpecularColor = lerp(0.08 * Specular.xxx, BaseColor, Metallic.xxx);
    GBuffer.DiffuseColor = BaseColor - BaseColor * Metallic;
    float3 BentNormal = MaterialParameters.WorldNormal;
    float DiffOcclusion = MaterialAO;
    float SpecOcclusion = MaterialAO;
    GBuffer.GBufferAO = AOMultiBounce(Luminance(GBuffer.SpecularColor), SpecOcclusion).g;

    half3 DiffuseColor = 0;
    half3 Color = 0;
    float IndirectIrradiance = 0;

	#if !MATERIAL_SHADINGMODEL_UNLIT

		float3 DiffuseDir = BentNormal;
		float3 DiffuseColorForIndirect = GBuffer.DiffuseColor;

		//#if MATERIAL_SHADINGMODEL_SUBSURFACE || MATERIAL_SHADINGMODEL_PREINTEGRATED_SKIN
		//	// Add subsurface energy to diffuse
		//	//@todo - better subsurface handling for these shading models with skylight and precomputed GI
		//	DiffuseColorForIndirect += SubsurfaceColor;
		//#endif

		//#if MATERIAL_SHADINGMODEL_CLOTH
		//	DiffuseColorForIndirect += SubsurfaceColor * saturate( GetMaterialCustomData0(MaterialParameters) );
		//#endif

		#if MATERIAL_SHADINGMODEL_HAIR
		{
			float3 N = MaterialParameters.WorldNormal;
			float3 V = MaterialParameters.CameraVector;
			float3 L = normalize( V - N * dot(V,N) );
			DiffuseDir = L;
			DiffuseColorForIndirect = 2*PI * HairShading( GBuffer, L, V, N, 1, 0, 0.2, uint2(0,0) );
		}
		#endif

		float3 DiffuseIndirectLighting;
		float3 SubsurfaceIndirectLighting;
		GetPrecomputedIndirectLightingAndSkyLight(MaterialParameters, input.FactoryInterpolants, DiffuseDir, VolumetricLightmapBrickTextureUVs, DiffuseIndirectLighting, SubsurfaceIndirectLighting, IndirectIrradiance);
		
		float IndirectOcclusion = 1.0f;
		float2 NearestResolvedDepthScreenUV = 0;

		//#if FORWARD_SHADING && (MATERIALBLENDING_SOLID || MATERIALBLENDING_MASKED)
		//	float2 NDC = MaterialParameters.ScreenPosition.xy / MaterialParameters.ScreenPosition.w;
		//	float2 ScreenUV = NDC * ResolvedView.ScreenPositionScaleBias.xy + ResolvedView.ScreenPositionScaleBias.wz;
		//	NearestResolvedDepthScreenUV = CalculateNearestResolvedDepthScreenUV(ScreenUV, MaterialParameters.ScreenPosition.w);

		//	IndirectOcclusion = GetIndirectOcclusion(NearestResolvedDepthScreenUV, GBuffer);
		//	DiffuseIndirectLighting *= IndirectOcclusion;
		//	SubsurfaceIndirectLighting *= IndirectOcclusion;
		//	IndirectIrradiance *= IndirectOcclusion;
		//#endif

		DiffuseColor += (DiffuseIndirectLighting * DiffuseColorForIndirect + SubsurfaceIndirectLighting * SubsurfaceColor) * AOMultiBounce( GBuffer.BaseColor, DiffOcclusion );

		#if FORWARD_SHADING || TRANSLUCENCY_LIGHTING_SURFACE_FORWARDSHADING || TRANSLUCENCY_LIGHTING_SURFACE_LIGHTINGVOLUME
			uint GridIndex = 0;

			#if INSTANCED_STEREO
				const uint EyeIndex = Interpolants.EyeIndex;
			#else
				const uint EyeIndex = 0;
			#endif

			#if FEATURE_LEVEL >= FEATURE_LEVEL_SM5
				GridIndex = ComputeLightGridCellIndex((uint2)(MaterialParameters.SvPosition.xy - ResolvedView.ViewRectMin.xy), MaterialParameters.SvPosition.w, EyeIndex);

				#if FORWARD_SHADING || TRANSLUCENCY_LIGHTING_SURFACE_FORWARDSHADING
					const float Dither = InterleavedGradientNoise(MaterialParameters.SvPosition.xy, View.StateFrameIndexMod8);
					Color += GetForwardDirectLighting(GridIndex, MaterialParameters.AbsoluteWorldPosition, MaterialParameters.CameraVector, GBuffer, NearestResolvedDepthScreenUV, MaterialParameters.PrimitiveId, EyeIndex, Dither);
				#endif
			#endif
        #endif

		#if SIMPLE_FORWARD_DIRECTIONAL_LIGHT

			float3 DirectionalLighting = GetSimpleForwardLightingDirectionalLight(
				GBuffer,
				DiffuseColorForIndirect,
				GBuffer.SpecularColor,
				GBuffer.Roughness,
				MaterialParameters.WorldNormal, 
				MaterialParameters.CameraVector);
			
			#if STATICLIGHTING_SIGNEDDISTANCEFIELD
				DirectionalLighting *= GBuffer.PrecomputedShadowFactors.x;
			#elif PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
				DirectionalLighting *= GetVolumetricLightmapDirectionalLightShadowing(VolumetricLightmapBrickTextureUVs);
			#elif CACHED_POINT_INDIRECT_LIGHTING
				DirectionalLighting *= IndirectLightingCache.DirectionalLightShadowing;
			#endif
			
			Color += DirectionalLighting;

		#endif
	#endif //!MATERIAL_SHADINGMODEL_UNLIT


	#if NEEDS_BASEPASS_PIXEL_FOGGING
		float4 HeightFogging = CalculateHeightFog(MaterialParameters.WorldPosition_CamRelative);
	#else
		float4 HeightFogging = float4(0,0,0,1);
	#endif

	float4 Fogging = HeightFogging;

#if NEEDS_BASEPASS_PIXEL_VOLUMETRIC_FOGGING
	if (FogStruct.ApplyVolumetricFog > 0) 
	{
		float3 VolumeUV = ComputeVolumeUV(MaterialParameters.AbsoluteWorldPosition, ResolvedView.WorldToClip);
		Fogging = CombineVolumetricFog(HeightFogging, VolumeUV);
	}
#endif

    half3 Emissive = GetMaterialEmissive(PixelMaterialInputs);

#if !POST_PROCESS_SUBSURFACE
 	// For non-skin, we just add diffuse and non-diffuse color together, otherwise we need to keep them separate
    Color += DiffuseColor;
#endif

    Color += Emissive;

    float4 FinalColor = half4(Color * Fogging.a + Fogging.rgb * Opacity, Opacity);
    GBuffer.IndirectIrradiance = IndirectIrradiance;

		// -0.5 .. 0.5, could be optimzed as lower quality noise would be sufficient
    float QuantizationBias = PseudoRandom(MaterialParameters.SvPosition.xy) - 0.5f;

    float4 OutGBufferA;
    float4 OutGBufferB;
    float4 OutGBufferC;
    float4 OutGBufferDummy;
    float4 OutGBufferE;
    EncodeGBuffer(GBuffer, OutGBufferA, OutGBufferB, OutGBufferC, OutGBufferDummy, OutGBufferE, OutGBufferDummy, QuantizationBias);

	//just add it over the top for now and see if this will even compile
	//TODO here, BLEND IT WITH EXISTING depending on depth!
    GbufferA[screenAddr] = OutGBufferA;
    GbufferB[screenAddr] = OutGBufferB;
    GbufferE[screenAddr]  = OutGBufferE;
    GbufferC[screenAddr] = OutGBufferC;
    SceneColor[screenAddr] = FinalColor;
}