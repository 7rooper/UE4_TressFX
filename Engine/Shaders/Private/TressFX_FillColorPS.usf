
#include "Common.ush"
#include "/Engine/Generated/Material.ush"
#include "/Engine/Generated/VertexFactory.ush"
#include "TressFXCommon.ush"
#include "TressFXShortCutCommon.ush"
#include "TressFXRendering.ush"
#include "DeferredShadingCommon.ush"
#include "LightmapCommon.ush"  
#include "ReflectionEnvironmentShared.ush"
#include "PlanarReflectionShared.ush"
#include "BRDF.ush"
#include "Random.ush"
#include "LightAccumulator.ush"
#include "ShadingModelsMaterial.ush"
#include "ShadingModels.ush"
#include "ForwardLightingCommon.ush"
#include "ShadowFilteringCommon.ush"

#ifndef TRESSFX_ALLOW_PRECOMPUTED_LIGHTING 
	#define TRESSFX_ALLOW_PRECOMPUTED_LIGHTING 1
#endif

#ifndef TRESSFX_UNREAL_HAIR_ONLY 
	#define TRESSFX_UNREAL_HAIR_ONLY 1
#endif

#ifndef TRESSFX_DIRECTIONAL_LIGHT_ONLY 
	#define TRESSFX_DIRECTIONAL_LIGHT_ONLY 0
#endif

#ifndef OPTIONAL_IsFrontFace
	#define OPTIONAL_IsFrontFace
#endif

struct PS_INPUT_HAIR_AA
{
    float4 Position : SV_POSITION;
    FVertexFactoryInterpolantsVSToPS FactoryInterpolants;

};

/** Adapted from the version in basepasspixelshader.usf. */
void GetSkyLighting(float3 WorldNormal, float2 LightmapUV, float3 SkyOcclusionUV3D, out float3 OutDiffuseLighting, out float3 OutSubsurfaceLighting)
{
    OutDiffuseLighting = 0;
    OutSubsurfaceLighting = 0;

#if TRESSFX_ALLOW_PRECOMPUTED_LIGHTING

    float SkyVisibility = 1;
    float GeometryTerm = 1;
    float3 SkyLightingNormal = WorldNormal;
	
#if HQ_TEXTURE_LIGHTMAP || CACHED_POINT_INDIRECT_LIGHTING || CACHED_VOLUME_INDIRECT_LIGHTING || PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
		BRANCH
		if (View.SkyLightParameters.x > 0)
		{
#if PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
			
				float3 SkyBentNormal = GetVolumetricLightmapSkyBentNormal(SkyOcclusionUV3D);
				SkyVisibility = length(SkyBentNormal);
				float3 NormalizedBentNormal = SkyBentNormal / max(SkyVisibility, .0001f);

#elif HQ_TEXTURE_LIGHTMAP

				// Bent normal from precomputed texture
				float4 WorldSkyBentNormalAndOcclusion = GetSkyBentNormalAndOcclusion(LightmapUV * float2(1, 2));
				// Renormalize as vector was quantized and compressed
				float3 NormalizedBentNormal = normalize(WorldSkyBentNormalAndOcclusion.xyz);
				SkyVisibility = WorldSkyBentNormalAndOcclusion.w;

#elif CACHED_POINT_INDIRECT_LIGHTING || CACHED_VOLUME_INDIRECT_LIGHTING

				// Bent normal from the indirect lighting cache - one value for the whole object
				float3 NormalizedBentNormal = PrecomputedLightingBuffer.PointSkyBentNormal.xyz;
				SkyVisibility = PrecomputedLightingBuffer.PointSkyBentNormal.w;

#endif

#if (MATERIALBLENDING_TRANSLUCENT || MATERIALBLENDING_ADDITIVE) && (TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL || TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_NONDIRECTIONAL)
				// NonDirectional lighting can't depend on the normal
				SkyLightingNormal = NormalizedBentNormal;
#else
				
				// Weight toward the material normal to increase directionality
				float BentNormalWeightFactor = 1 - (1 - SkyVisibility) * (1 - SkyVisibility);

				// We are lerping between the inputs of two lighting scenarios based on occlusion
				// In the mostly unoccluded case, evaluate sky lighting with the material normal, because it has higher detail
				// In the mostly occluded case, evaluate sky lighting with the bent normal, because it is a better representation of the incoming lighting
				// Then treat the lighting evaluated along the bent normal as an area light, so we must apply the lambert term
				SkyLightingNormal = lerp(NormalizedBentNormal, WorldNormal, BentNormalWeightFactor);

				float DotProductFactor = lerp(saturate(dot(NormalizedBentNormal, WorldNormal)), 1, BentNormalWeightFactor);
				// Account for darkening due to the geometry term
				GeometryTerm = DotProductFactor;
#endif
		}
#endif
			
	// Compute the preconvolved incoming lighting with the bent normal direction
    float3 DiffuseLookup = GetSkySHDiffuse(SkyLightingNormal) * ResolvedView.SkyLightColor.rgb;

	// Apply AO to the sky diffuse
    OutDiffuseLighting += DiffuseLookup * (SkyVisibility * GeometryTerm);
#endif
}

/** Calculates indirect lighting contribution on this object from precomputed data. */
/** Adapted from the version in basepasspixelshader.usf. */
void GetPrecomputedIndirectLightingAndSkyLight(
	FMaterialPixelParameters MaterialParameters,
	FVertexFactoryInterpolantsVSToPS Interpolants,
	float3 DiffuseDir,
	float3 VolumetricLightmapBrickTextureUVs,
	out float3 OutDiffuseLighting,
	out float3 OutSubsurfaceLighting,
	out float OutIndirectIrradiance)
{
    OutIndirectIrradiance = 0;
    OutDiffuseLighting = 0;
    OutSubsurfaceLighting = 0;
    float2 SkyOcclusionUV = 0;

#if PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING

#if TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL || TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_NONDIRECTIONAL


			FOneBandSHVectorRGB IrradianceSH = GetVolumetricLightmapSH1(VolumetricLightmapBrickTextureUVs);
			FOneBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH1(1);
			OutDiffuseLighting = max(float3(0,0,0), DotSH1(IrradianceSH, DiffuseTransferSH)) / PI;

#else

			FThreeBandSHVectorRGB IrradianceSH = GetVolumetricLightmapSH3(VolumetricLightmapBrickTextureUVs);
			// Diffuse convolution
			FThreeBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH3(DiffuseDir, 1);
			OutDiffuseLighting = max(float3(0,0,0), DotSH3(IrradianceSH, DiffuseTransferSH)) / PI;

#endif

		// Visualize volumetric lightmap texel positions
		//OutDiffuseLighting = frac(VolumetricLightmapBrickTextureUVs / View.VolumetricLightmapBrickTexelSize - .5f);

	// Method for movable components which want to use a volume texture of interpolated SH samples
#elif CACHED_VOLUME_INDIRECT_LIGHTING
	
		// Compute volume texture UVs from world position
		float3 VolumeUVs = MaterialParameters.AbsoluteWorldPosition * PrecomputedLightingBuffer.IndirectLightingCachePrimitiveScale + PrecomputedLightingBuffer.IndirectLightingCachePrimitiveAdd;
		// Clamp UV to be within the valid region
		// Pixels outside of the object's bounding box would read garbage otherwise
		VolumeUVs = clamp(VolumeUVs, PrecomputedLightingBuffer.IndirectLightingCacheMinUV, PrecomputedLightingBuffer.IndirectLightingCacheMaxUV);
		float4 Vector0 = Texture3DSample(PrecomputedLightingBuffer.IndirectLightingCacheTexture0, PrecomputedLightingBuffer.IndirectLightingCacheTextureSampler0, VolumeUVs);

		// For debugging
#define AMBIENTONLY 0
#if AMBIENTONLY
			OutDiffuseLighting = Vector0.rgb / SHAmbientFunction() / PI;
#else

			float4 Vector1 = Texture3DSample(PrecomputedLightingBuffer.IndirectLightingCacheTexture1, ILCSharedSampler1, VolumeUVs);
			float4 Vector2 = Texture3DSample(PrecomputedLightingBuffer.IndirectLightingCacheTexture2, ILCSharedSampler2, VolumeUVs);

			// Construct the SH environment
			FTwoBandSHVectorRGB CachedSH;
			CachedSH.R.V = float4(Vector0.x, Vector1.x, Vector2.x, Vector0.w);
			CachedSH.G.V = float4(Vector0.y, Vector1.y, Vector2.y, Vector1.w);
			CachedSH.B.V = float4(Vector0.z, Vector1.z, Vector2.z, Vector2.w);

			// Diffuse convolution
			FTwoBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH(DiffuseDir, 1);
			OutDiffuseLighting = max(half3(0,0,0), DotSH(CachedSH, DiffuseTransferSH)) / PI;
#endif

	// Method for movable components which want to use a single interpolated SH sample
#elif CACHED_POINT_INDIRECT_LIGHTING

		FThreeBandSHVectorRGB PointIndirectLighting;
		PointIndirectLighting.R.V0 = PrecomputedLightingBuffer.IndirectLightingSHCoefficients0[0];
		PointIndirectLighting.R.V1 = PrecomputedLightingBuffer.IndirectLightingSHCoefficients1[0];
		PointIndirectLighting.R.V2 = PrecomputedLightingBuffer.IndirectLightingSHCoefficients2[0];

		PointIndirectLighting.G.V0 = PrecomputedLightingBuffer.IndirectLightingSHCoefficients0[1];
		PointIndirectLighting.G.V1 = PrecomputedLightingBuffer.IndirectLightingSHCoefficients1[1];
		PointIndirectLighting.G.V2 = PrecomputedLightingBuffer.IndirectLightingSHCoefficients2[1];

		PointIndirectLighting.B.V0 = PrecomputedLightingBuffer.IndirectLightingSHCoefficients0[2];
		PointIndirectLighting.B.V1 = PrecomputedLightingBuffer.IndirectLightingSHCoefficients1[2];
		PointIndirectLighting.B.V2 = PrecomputedLightingBuffer.IndirectLightingSHCoefficients2[2];

		FThreeBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH3(DiffuseDir, 1);
		// Compute diffuse lighting which takes the normal into account
		OutDiffuseLighting = max(half3(0,0,0), DotSH3(PointIndirectLighting, DiffuseTransferSH));

	// High quality texture lightmaps
#elif HQ_TEXTURE_LIGHTMAP

		float2 LightmapUV0, LightmapUV1;
		GetLightMapCoordinates(Interpolants, LightmapUV0, LightmapUV1);
		SkyOcclusionUV = LightmapUV0;
		GetLightMapColorHQ(LightmapUV0, LightmapUV1, DiffuseDir, OutDiffuseLighting, OutSubsurfaceLighting);

	// Low quality texture lightmaps
#elif LQ_TEXTURE_LIGHTMAP
		float2 LightmapUV0, LightmapUV1;
		GetLightMapCoordinates(Interpolants, LightmapUV0, LightmapUV1);
		OutDiffuseLighting = GetLightMapColorLQ(LightmapUV0, LightmapUV1, DiffuseDir).rgb;
#endif

	// Apply indirect lighting scale while we have only accumulated lightmaps
    OutDiffuseLighting *= View.IndirectLightingColorScale;
    OutSubsurfaceLighting *= View.IndirectLightingColorScale;

    float3 SkyDiffuseLighting;
    float3 SkySubsurfaceLighting;
    GetSkyLighting(DiffuseDir, SkyOcclusionUV, VolumetricLightmapBrickTextureUVs, SkyDiffuseLighting, SkySubsurfaceLighting);

    OutSubsurfaceLighting += SkySubsurfaceLighting;

	// Sky lighting must contribute to IndirectIrradiance for ReflectionEnvironment lightmap mixing
    OutDiffuseLighting += SkyDiffuseLighting;

#if HQ_TEXTURE_LIGHTMAP || LQ_TEXTURE_LIGHTMAP || CACHED_VOLUME_INDIRECT_LIGHTING || CACHED_POINT_INDIRECT_LIGHTING || PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
		OutIndirectIrradiance = Luminance(OutDiffuseLighting);
#endif
}

// [ Jimenez et al. 2016, "Practical Realtime Strategies for Accurate Indirect Occlusion" ]
float3 AOMultiBounce(float3 BaseColor, float AO)
{
    float3 a = 2.0404 * BaseColor - 0.3324;
    float3 b = -4.7951 * BaseColor + 0.6417;
    float3 c = 2.7552 * BaseColor + 0.6903;
    return max(AO, ((AO * a + b) * AO + c) * AO);
}

float ComputeStaticShadowing(float3 WorldPosition)
{
    float ShadowFactor = 1;

    BRANCH
    if (ForwardLightData.DirectionalLightUseStaticShadowing > 0)
    {
		// This path is used for directional lights and spot lights, which only require a single projection
		// Transform the world position into shadowmap space
        float4 HomogeneousShadowPosition = mul(float4(WorldPosition, 1), ForwardLightData.DirectionalLightWorldToStaticShadow);
        float2 ShadowUVs = HomogeneousShadowPosition.xy / HomogeneousShadowPosition.w;

		// Treat as unshadowed if the voxel is outside of the shadow map
        if (all(ShadowUVs >= 0 && ShadowUVs <= 1))
        {
			#ifndef FILTER_STATIC_SHADOWING
				#define FILTER_STATIC_SHADOWING 1
			#endif
			#if FILTER_STATIC_SHADOWING
				FPCFSamplerSettings Settings;
				Settings.ShadowDepthTexture = ForwardLightData.DirectionalLightStaticShadowmap;
				Settings.ShadowDepthTextureSampler = ForwardLightData.StaticShadowmapSampler;
				Settings.ShadowBufferSize = ForwardLightData.DirectionalLightStaticShadowBufferSize;
				Settings.SceneDepth = HomogeneousShadowPosition.z;
				Settings.TransitionScale = 40;
				Settings.bSubsurface = false;
				Settings.DensityMulConstant = 0;
				Settings.ProjectionDepthBiasParameters = float2(0, 0);

				ShadowFactor = Manual1x1PCF(ShadowUVs, Settings);
			#else
				// Sample the shadowmap depth and determine if this voxel is shadowed
				float ShadowDepth = Texture2DSampleLevel(ForwardLightData.DirectionalLightStaticShadowmap, ForwardLightData.StaticShadowmapSampler, ShadowUVs, 0).x;
				ShadowFactor = HomogeneousShadowPosition.z < ShadowDepth;
			#endif
        }
    }
    return ShadowFactor;
}

#define BRIGHT_OUTSIDE_FRUSTUM 1

bool FrustumCheck(float3 vPositionSM)
{
#if BRIGHT_OUTSIDE_FRUSTUM
    if (max(vPositionSM.x, vPositionSM.y) > 1.)
    {
        return false;
    }
    if (min(vPositionSM.x, vPositionSM.y) < 0.)
    {
        return false;
    }
    if (vPositionSM.z > 1.)
        return false;
    if (vPositionSM.z < 0.)
        return false;
#endif
    return true;
}

float GetWSDepth_D3D(float depthNDC, float fNear, float fFar)
{
    return fNear * fFar / (fFar - depthNDC * (fFar - fNear));
}

float3 ComputeShadowUV(float3 WorldPosition, uint CascadeIndex)
{
    float4 HomogeneousShadowPosition = mul(float4(WorldPosition, 1), ForwardLightData.DirectionalLightWorldToShadowMatrix[CascadeIndex]);
    float3 ShadowUVs = HomogeneousShadowPosition.xyz / HomogeneousShadowPosition.w;
    return ShadowUVs;
}

//=================================================================
// Shadow map sampling with 28 tap poisson kernel (each Poisson tap 
// is a 2x2 PCF kernel). This gives 140 shades of gray.
//=================================================================
float ComputeShadowHair(float3 vPositionWS, HairShadeParams params, float CascadeIndex)
{
    const float2 vPoisson[11] =
    {
        float2(0, 0),
		float2((0.079928 - 0.5) * 2, (0.995178 - 0.5) * 2),
		float2((0.120334 - 0.5) * 2, (0.710807 - 0.5) * 2),
		float2((0.186102 - 0.5) * 2, (0.400647 - 0.5) * 2),
		float2((0.386639 - 0.5) * 2, (0.992065 - 0.5) * 2),
		float2((0.448134 - 0.5) * 2, (0.469771 - 0.5) * 2),
		float2((0.620014 - 0.5) * 2, (0.666311 - 0.5) * 2),
		float2((0.719260 - 0.5) * 2, (0.385296 - 0.5) * 2),
		float2((0.720695 - 0.5) * 2, (0.990722 - 0.5) * 2),
		float2((0.888516 - 0.5) * 2, (0.187658 - 0.5) * 2),
		float2((0.890286 - 0.5) * 2, (0.591052 - 0.5) * 2)
    };

    float fRadius = params.fRadius;
    float3 vPositionSM = ComputeShadowUV(vPositionWS, CascadeIndex);
    if (!FrustumCheck(vPositionSM))
    {
        return 1.0;
    }

    float2 vTexelSize = 1.0f / ForwardLightData.DirectionalLightShadowmapAtlasBufferSize.xy;

    float fNear = 1.f;
    float fFar = 1000000.f;
    float fDepthFragment = GetWSDepth_D3D(vPositionSM.z, fNear, fFar);

    float fShadow = 0;

    float fTotalWeight = 0;

    for (int iSample = 0; iSample < 11; ++iSample)
    {
        float fWeight = 1.0;
        float fDepthSM_NDC = Texture2DSampleLevel(ForwardLightData.DirectionalLightShadowmapAtlas, ForwardLightData.ShadowmapSampler, vPositionSM.xy + (vTexelSize * vPoisson[iSample] * fRadius.xx), 0).x;
        float fDepthSM = GetWSDepth_D3D(fDepthSM_NDC, fNear, fFar);
        float fDeltaDepth = max(0, fDepthFragment - fDepthSM);

		//JAKETODO:  ComputeShadowAttenuation keeps returning 1 every time, find out why
        fShadow += ComputeShadowAttenuation(fDeltaDepth, params) * fWeight;

        fTotalWeight += fWeight;
    }
    return fShadow / fTotalWeight;
}

// adapted from ComputeDirectionalLightDynamicShadowing in forwardshadowingcommon.ush
float ComputeDirectionalLightDynamicShadowing_TressFX(float3 WorldPosition, float SceneDepth, HairShadeParams params)
{
    float ShadowFactor = 1;
    if (ForwardLightData.NumDirectionalLightCascades > 0)
    {
        uint CascadeIndex = ForwardLightData.NumDirectionalLightCascades;

        for (uint TestCascadeIndex = 0; TestCascadeIndex < ForwardLightData.NumDirectionalLightCascades; TestCascadeIndex++)
        {
            if (SceneDepth < ForwardLightData.CascadeEndDepths[TestCascadeIndex])
            {
                CascadeIndex = TestCascadeIndex;
                break;
            }
        }

        if (CascadeIndex < ForwardLightData.NumDirectionalLightCascades)
        {
			// Transform the world position into shadowmap space
            float4 HomogeneousShadowPosition = mul(float4(WorldPosition, 1), ForwardLightData.DirectionalLightWorldToShadowMatrix[CascadeIndex]);
            float2 ShadowUVs = HomogeneousShadowPosition.xy / HomogeneousShadowPosition.w;
            float4 ShadowmapMinMax = ForwardLightData.DirectionalLightShadowmapMinMax[CascadeIndex];

			// Treat as unshadowed if the voxel is outside of the shadow map
            if (all(ShadowUVs >= ShadowmapMinMax.xy && ShadowUVs <= ShadowmapMinMax.zw))
            {
                ShadowFactor = ComputeShadowHair(WorldPosition, params, CascadeIndex);
            }
        }
    }
    return ShadowFactor;
}

float3 AccumulateHairLight(
	uint GridIndex,
	float3 AbsoluteWorldPosition,
	float3 CameraVector,
	float3 vStrandTangent,
	HairShadeParams params,
	float2 ScreenUV,
	uint EyeIndex,
	FGBufferData GBufferData,
	float Dither
)
{

    float4 DynamicShadowFactors = GetForwardDynamicShadowFactors(ScreenUV);
    float3 DirectLighting = 0;

	// Prevent 0 Roughness which causes NaNs in Vis_SmithJointApprox
    float SpecularScale = 1;
    float3 V = normalize(CameraVector);
    float3 T = normalize(vStrandTangent);
    float fLightScale = 1;

    const FDirectionalLightData DirectionalLightData = GetDirectionalLightData(EyeIndex);
	// adapted from GetForwardDirectLighting in Forwardlightingcommon.ush
    BRANCH
    if (DirectionalLightData.HasDirectionalLight)
    {
        FDeferredLightData LightData = (FDeferredLightData) 0;
        LightData.LightColorAndFalloffExponent = float4(DirectionalLightData.DirectionalLightColor, 0);
        LightData.LightDirection = DirectionalLightData.DirectionalLightDirection;
        LightData.SpecularScale = SpecularScale;
       
        float3 NewLighting = 0;
        float3 color = 0;
        
#if TRESSFX_UNREAL_HAIR_ONLY
        LightData.DistanceFadeMAD = DirectionalLightData.DirectionalLightDistanceFadeMAD;
        LightData.bRadialLight = false;
        LightData.ShadowedBits = (DirectionalLightData.DirectionalLightShadowMapChannelMask & 0xFF) != 0 ? 1 : 0;
		// Static shadowing uses ShadowMapChannel, dynamic shadows are packed into light attenuation using PreviewShadowMapChannel
        LightData.ShadowMapChannelMask = UnpackShadowMapChannelMask(DirectionalLightData.DirectionalLightShadowMapChannelMask);
        float4 PreviewShadowMapChannelMask = UnpackShadowMapChannelMask(DirectionalLightData.DirectionalLightShadowMapChannelMask >> 4);
        float DynamicShadowing = dot(PreviewShadowMapChannelMask, DynamicShadowFactors);
		// In the forward shading path we can't separate per-object shadows from CSM, since we only spend one light attenuation channel per light
		// If CSM is enabled (distance fading to precomputed shadowing is active), treat all of our dynamic shadowing as whole scene shadows that will be faded out at the max CSM distance
		// If CSM is not enabled, allow our dynamic shadowing to coexist with precomputed shadowing
        float PerObjectShadowing = LightData.DistanceFadeMAD.y < 0.0f ? 1.0f : DynamicShadowing;
        float WholeSceneShadowing = LightData.DistanceFadeMAD.y < 0.0f ? DynamicShadowing : 1.0f;
        float4 LightAttenuation = float4(WholeSceneShadowing.xx, PerObjectShadowing.xx);
        color = GetDynamicLighting(AbsoluteWorldPosition, -CameraVector, GBufferData, 1, GBufferData.ShadingModelID, LightData, LightAttenuation, Dither, uint2(0, 0)).xyz;
#else
		// spec vs diffuse through the light.
		float DynamicShadowTressFX = ComputeDirectionalLightDynamicShadowing_TressFX(AbsoluteWorldPosition, GBufferData.Depth, params);
        float lightEmitsDiffuse = 1;
        float lightEmitsSpecular = 1;
        float3 cLightColor = LightData.LightColorAndFalloffExponent.rgb;
        
        if (DynamicShadowTressFX > 0.00001)
        {
            float3 L = normalize(LightData.LightDirection);
            float3 reflection = TressFX_ComputeDiffuseSpecFactors(V, L, T);
            float3 cReflectedLight = reflection.x * cLightColor * lightEmitsDiffuse * params.cColor;
            cReflectedLight += reflection.y * cLightColor * lightEmitsSpecular;
            cReflectedLight += reflection.z * cLightColor * lightEmitsSpecular * params.cColor;
            cReflectedLight *= DynamicShadowTressFX * fLightScale;
            color = max(float3(0, 0, 0), cReflectedLight);
        }
#endif
        NewLighting += color;
        DirectLighting += NewLighting;
    }

#if !TRESSFX_DIRECTIONAL_LIGHT_ONLY
	// local lights eg point,rect etc...
    const FCulledLightsGridData CulledLightsGrid = GetCulledLightsGrid(GridIndex, EyeIndex);

	LOOP
	for (uint LocalLightListIndex = 0; LocalLightListIndex < CulledLightsGrid.NumLocalLights; LocalLightListIndex++)
	{
        const FLocalLightData LocalLight = GetLocalLightData(CulledLightsGrid.DataStartIndex + LocalLightListIndex, EyeIndex);

		FDeferredLightData LightData = (FDeferredLightData) 0;
		LightData.LightPositionAndInvRadius = LocalLight.LightPositionAndInvRadius;
		LightData.LightColorAndFalloffExponent = LocalLight.LightColorAndFalloffExponent;
		LightData.LightDirection = LocalLight.LightDirectionAndShadowMask.xyz;
        float SourceLength = f16tof32(asuint(LocalLight.SpotAnglesAndSourceRadiusPacked.w));
        LightData.SpotAnglesAndSourceRadius = float4(LocalLight.SpotAnglesAndSourceRadiusPacked.xyz, SourceLength);
        LightData.LightTangent = LocalLight.LightTangentAndSoftSourceRadius.xyz;
        LightData.SoftSourceRadius = LocalLight.LightTangentAndSoftSourceRadius.w;
		LightData.bInverseSquared = LightData.LightColorAndFalloffExponent.w == 0;
		LightData.bRadialLight = true;
		LightData.bSpotLight = LightData.SpotAnglesAndSourceRadius.x > -2.0f;
        LightData.SpecularScale = SpecularScale;

		uint PackedShadowMapChannelMask = asuint(LocalLight.LightDirectionAndShadowMask.w);
		LightData.ShadowedBits = (PackedShadowMapChannelMask & 0xFF) != 0 ? 1 : 0;
		//Static shadowing uses ShadowMapChannel, dynamic shadows are packed into light attenuation using PreviewShadowMapChannel
		LightData.ShadowMapChannelMask = UnpackShadowMapChannelMask(PackedShadowMapChannelMask);
		float4 PreviewShadowMapChannelMask = UnpackShadowMapChannelMask(PackedShadowMapChannelMask >> 4);
		float DynamicShadowing = dot(PreviewShadowMapChannelMask, DynamicShadowFactors);
		float4 LightAttenuation = float4(1, 1, DynamicShadowing.x, DynamicShadowing.x);
        float3 NewLighting = 0;
        float3 DynamicLighting = GetDynamicLighting(AbsoluteWorldPosition, -CameraVector, GBufferData, 1, GBufferData.ShadingModelID, LightData, LightAttenuation, Dither, uint2(0, 0)).xyz;
        NewLighting += DynamicLighting;

		FLATTEN
		if ((PackedShadowMapChannelMask >> 8) & Primitive.LightingChannelMask)
		{
			DirectLighting += NewLighting;
		}
	}
	#endif
    return DirectLighting;
}

EARLYDEPTHSTENCIL
float4 main(PS_INPUT_HAIR_AA input OPTIONAL_IsFrontFace) : SV_Target0
{
	float4 viewport = float4(View.ViewRectMin.xy, View.ViewSizeAndInvSize.xy);
	float3 vNDC = ScreenPosToNDC(input.Position.xyz, viewport);
	float coverage = ComputeCoverage(input.FactoryInterpolants.p0p1.xy, input.FactoryInterpolants.p0p1.zw, vNDC.xy, viewport.zw);

	//final color
	float3 Color = 0; 

	//this static variable in instanced stero.ush needs to be set 
    ResolvedView = ResolveView();

    FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(input.FactoryInterpolants, input.Position);
    FPixelMaterialInputs PixelMaterialInputs;
    PixelMaterialInputs = (FPixelMaterialInputs) 0;

		#if USE_WORLD_POSITION_EXCLUDING_SHADER_OFFSETS
		{
			float4 ScreenPosition = SvPositionToResolvedScreenPosition(input.Position);
			float3 TranslatedWorldPosition = SvPositionToResolvedTranslatedWorld(input.Position);
			CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, input.Position, ScreenPosition, bIsFrontFace, TranslatedWorldPosition, BasePassInterpolants.PixelPositionExcludingWPO);
		}
	#else
		{
			float4 ScreenPosition = SvPositionToResolvedScreenPosition(input.Position);
			float3 TranslatedWorldPosition = SvPositionToResolvedTranslatedWorld(input.Position);
			CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, input.Position, ScreenPosition, bIsFrontFace, TranslatedWorldPosition, TranslatedWorldPosition);
		}
	#endif

    half Opacity = GetMaterialOpacity(PixelMaterialInputs);
    float alpha = coverage * Opacity;
	
    if (alpha < SHORTCUT_MIN_ALPHA)
    {
        return float4(0, 0, 0, 0);
    }

    half3 BaseColor = GetMaterialBaseColor(PixelMaterialInputs);
    half Metallic = GetMaterialMetallic(PixelMaterialInputs);
    half Specular = GetMaterialSpecular(PixelMaterialInputs);
    float MaterialAO = GetMaterialAmbientOcclusion(PixelMaterialInputs);
    float Roughness = GetMaterialRoughness(PixelMaterialInputs);   
    float SubsurfaceProfile = 0;
    float3 SubsurfaceColor = 0;

    HairShadeParams params = (HairShadeParams) 0;
    params.cColor = BaseColor;
    params.fRadius = g_FiberRadius;
    params.fSpacing = g_FiberSpacing;
    params.fAlpha = g_HairShadowAlpha;

    float3 VolumetricLightmapBrickTextureUVs;
		
	#if PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
		VolumetricLightmapBrickTextureUVs = ComputeVolumetricLightmapBrickTextureUVs(MaterialParameters.AbsoluteWorldPosition);
	#endif

    FGBufferData GBuffer = (FGBufferData) 0;
    GBuffer.GBufferAO = MaterialAO;
    GBuffer.PerObjectGBufferData = Primitive.PerObjectGBufferData;
    GBuffer.Depth = MaterialParameters.ScreenPosition.w;
    GBuffer.PrecomputedShadowFactors = GetPrecomputedShadowMasks(input.FactoryInterpolants, MaterialParameters.AbsoluteWorldPosition, VolumetricLightmapBrickTextureUVs);

    SetGBufferForShadingModel(
		GBuffer,
		MaterialParameters,
		Opacity,
		BaseColor,
		Metallic,
		Specular,
		Roughness,
		SubsurfaceColor,
		SubsurfaceProfile
	);

    GBuffer.SpecularColor = lerp(0.08 * Specular.xxx, BaseColor, Metallic.xxx);
    GBuffer.DiffuseColor = BaseColor - BaseColor * Metallic;
    float3 BentNormal = MaterialParameters.WorldNormal;
    float DiffOcclusion = MaterialAO;
    float SpecOcclusion = MaterialAO;
    GBuffer.GBufferAO = AOMultiBounce(Luminance(GBuffer.SpecularColor), SpecOcclusion).g;
    GBuffer.WorldNormal = MaterialParameters.WorldNormal;

	#if TRESSFX_ALLOW_PRECOMPUTED_LIGHTING
		float3 DiffuseDir = BentNormal;
		float3 DiffuseColorForIndirect = GBuffer.DiffuseColor;
		{
			float3 N = MaterialParameters.WorldNormal;
			float3 V = MaterialParameters.CameraVector;
			float3 L = normalize( V - N * dot(V,N) );
			DiffuseDir = L;
			DiffuseColorForIndirect = 2*PI * HairShading( GBuffer, L, V, N, 1, 0, 0.2, uint2(0,0) );
		}
		float3 DiffuseIndirectLighting;
		float3 SubsurfaceIndirectLighting;
		half3 DiffuseColor = 0;
		float IndirectIrradiance = 0;
		GetPrecomputedIndirectLightingAndSkyLight(MaterialParameters, input.FactoryInterpolants, DiffuseDir, VolumetricLightmapBrickTextureUVs, DiffuseIndirectLighting, SubsurfaceIndirectLighting, IndirectIrradiance);
		DiffuseColor += (DiffuseIndirectLighting * DiffuseColorForIndirect + SubsurfaceIndirectLighting * SubsurfaceColor) * AOMultiBounce(GBuffer.BaseColor, DiffOcclusion);
		Color += DiffuseColor;
	#endif

    int2 vScreenAddress = int2(input.Position.xy);

    uint GridIndex = ComputeLightGridCellIndex((uint2) (input.Position.xy - ResolvedView.ViewRectMin.xy), input.Position.w, 0);
    const float Dither = InterleavedGradientNoise(MaterialParameters.SvPosition.xy, View.StateFrameIndexMod8);
    const uint EyeIndex = 0; //idgaf about instanced stereo
    Color += AccumulateHairLight(GridIndex, MaterialParameters.AbsoluteWorldPosition, MaterialParameters.CameraVector, input.FactoryInterpolants.Tangent, params, vScreenAddress, EyeIndex, GBuffer, Dither);
    return float4(Color * alpha, alpha);
}

#if SIMPLE_FORWARD_DIRECTIONAL_LIGHT

float3 GetSimpleForwardLightingDirectionalLight(FGBufferData GBuffer, float3 DiffuseColor, float3 SpecularColor, float Roughness, float3 WorldNormal, float3 CameraVector)
{
	float3 V = -CameraVector;
	float3 N = WorldNormal;
	float3 L = ResolvedView.DirectionalLightDirection;
	float NoL = saturate( dot( N, L ) );

	float3 LightColor = ResolvedView.DirectionalLightColor.rgb * PI;
	
	FShadowTerms Shadow = { 1, 1, 1 };
	FDirectLighting Lighting = EvaluateBxDF( GBuffer, N, V, L, NoL, Shadow );

	// Not computing specular, material was forced fully rough
	return LightColor * (Lighting.Diffuse + Lighting.Transmission);
}

#endif

uint GetSelectiveOutputMask()
{
	uint Mask = 0;
#if !WRITES_CUSTOMDATA_TO_GBUFFER
	Mask |= SKIP_CUSTOMDATA_MASK;
#endif
#if !GBUFFER_HAS_PRECSHADOWFACTOR
	Mask |= SKIP_PRECSHADOW_MASK;
#endif
#if (GBUFFER_HAS_PRECSHADOWFACTOR && WRITES_PRECSHADOWFACTOR_ZERO)
	Mask |= ZERO_PRECSHADOW_MASK;
#endif
#if !WRITES_VELOCITY_TO_GBUFFER
	Mask |= SKIP_VELOCITY_MASK;
#endif
	return Mask;
}


EARLYDEPTHSTENCIL
void FillColors_Deferred(
	PS_INPUT_HAIR_AA input OPTIONAL_IsFrontFace
		, out float4 FragmentColors : SV_TARGET0
		, out float4 OutGbufferA : SV_TARGET1
		, out float4 OutGBufferB : SV_TARGET2
		, out float4 OutGBufferE : SV_TARGET3
		, out float4 OutGBufferD : SV_TARGET4
		, out float4 OutGBufferC : SV_TARGET5
		, out float4 OutSceneColor : SV_TARGET6
	)
{
	
	//this static variable in instanced stero.ush needs to be set 
    ResolvedView = ResolveView();

    FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(input.FactoryInterpolants, input.Position);
    FPixelMaterialInputs PixelMaterialInputs;
    PixelMaterialInputs = (FPixelMaterialInputs) 0;

		#if USE_WORLD_POSITION_EXCLUDING_SHADER_OFFSETS
		{
			float4 ScreenPosition = SvPositionToResolvedScreenPosition(input.Position);
			float3 TranslatedWorldPosition = SvPositionToResolvedTranslatedWorld(input.Position);
			CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, input.Position, ScreenPosition, bIsFrontFace, TranslatedWorldPosition, BasePassInterpolants.PixelPositionExcludingWPO);
		}
	#else
		{
			float4 ScreenPosition = SvPositionToResolvedScreenPosition(input.Position);
			float3 TranslatedWorldPosition = SvPositionToResolvedTranslatedWorld(input.Position);
			CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, input.Position, ScreenPosition, bIsFrontFace, TranslatedWorldPosition, TranslatedWorldPosition);
		}
	#endif

    float4 viewport = float4(View.ViewRectMin.xy, View.ViewSizeAndInvSize.xy);
    float2 NDC = MaterialParameters.ScreenPosition.xy / MaterialParameters.ScreenPosition.w;
    float coverage = ComputeCoverage(input.FactoryInterpolants.p0p1.xy, input.FactoryInterpolants.p0p1.zw, NDC, viewport.zw);

    half Opacity = GetMaterialOpacity(PixelMaterialInputs);
    float alpha = coverage * Opacity;

	 if (alpha < SHORTCUT_MIN_ALPHA)
    {
        discard;
        return;
        //return float4(0, 0, 0, 0);
		//TODO, maybe write all zeros? or discard?
    }

	//instead of using this here, just plug the node into world normal in the material editor, makes things easier. less code to modify
	float4 StrandTangent = input.FactoryInterpolants.Tangent;

    half3 BaseColor = GetMaterialBaseColor(PixelMaterialInputs);
    half Metallic = GetMaterialMetallic(PixelMaterialInputs);
    half Specular = GetMaterialSpecular(PixelMaterialInputs);

    float MaterialAO = GetMaterialAmbientOcclusion(PixelMaterialInputs);
    float Roughness = GetMaterialRoughness(PixelMaterialInputs);   
    float SubsurfaceProfile = 0;
    float3 SubsurfaceColor = 0;

	float3 VolumetricLightmapBrickTextureUVs;
		
	#if PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
		VolumetricLightmapBrickTextureUVs = ComputeVolumetricLightmapBrickTextureUVs(MaterialParameters.AbsoluteWorldPosition);
	#endif

	FGBufferData GBuffer = (FGBufferData)0;

	GBuffer.GBufferAO = MaterialAO;
	GBuffer.PerObjectGBufferData = Primitive.PerObjectGBufferData;
	GBuffer.Depth = MaterialParameters.ScreenPosition.w;
    GBuffer.PrecomputedShadowFactors = GetPrecomputedShadowMasks(input.FactoryInterpolants, MaterialParameters.AbsoluteWorldPosition, VolumetricLightmapBrickTextureUVs);

	SetGBufferForShadingModel(
		GBuffer, 
		MaterialParameters, 
		Opacity, 
		BaseColor, 
		Metallic, 
		Specular, 
		Roughness, 
		SubsurfaceColor,
		SubsurfaceProfile
	);

	GBuffer.SelectiveOutputMask = GetSelectiveOutputMask();
	GBuffer.Velocity = 0; //velocity written during depths alpha pass...for now
	GBuffer.SpecularColor = lerp(0.08 * Specular.xxx, BaseColor, Metallic.xxx);
	GBuffer.DiffuseColor = BaseColor - BaseColor * Metallic;

	float3 BentNormal = MaterialParameters.WorldNormal;
	float DiffOcclusion = MaterialAO;
	float SpecOcclusion = MaterialAO;
	//ApplyBentNormal( MaterialParameters, GBuffer.Roughness, BentNormal, DiffOcclusion, SpecOcclusion );
	// FIXME: ALLOW_STATIC_LIGHTING == 0 expects this to be AO
	GBuffer.GBufferAO = AOMultiBounce( Luminance( GBuffer.SpecularColor ), SpecOcclusion ).g;

	half3 DiffuseColor = 0;
	half3 Color = 0;
	float IndirectIrradiance = 0;

	#if !MATERIAL_SHADINGMODEL_UNLIT

		float3 DiffuseDir = BentNormal;
		float3 DiffuseColorForIndirect = GBuffer.DiffuseColor;

		// #if MATERIAL_SHADINGMODEL_SUBSURFACE || MATERIAL_SHADINGMODEL_PREINTEGRATED_SKIN
		// 	// Add subsurface energy to diffuse
		// 	//@todo - better subsurface handling for these shading models with skylight and precomputed GI
		// 	DiffuseColorForIndirect += SubsurfaceColor;
		// #endif

		// #if MATERIAL_SHADINGMODEL_CLOTH
		// 	DiffuseColorForIndirect += SubsurfaceColor * saturate( GetMaterialCustomData0(MaterialParameters) );
		// #endif

		#if MATERIAL_SHADINGMODEL_HAIR
		{
			float3 N = MaterialParameters.WorldNormal;
			float3 V = MaterialParameters.CameraVector;
			float3 L = normalize( V - N * dot(V,N) );
			DiffuseDir = L;
			DiffuseColorForIndirect = 2*PI * HairShading( GBuffer, L, V, N, 1, 0, 0.2, uint2(0,0) );
		}
		#endif

		float3 DiffuseIndirectLighting;
		float3 SubsurfaceIndirectLighting;
		GetPrecomputedIndirectLightingAndSkyLight(MaterialParameters, input.FactoryInterpolants, DiffuseDir, VolumetricLightmapBrickTextureUVs, DiffuseIndirectLighting, SubsurfaceIndirectLighting, IndirectIrradiance);
		
		float IndirectOcclusion = 1.0f;
		float2 NearestResolvedDepthScreenUV = 0;

		// #if FORWARD_SHADING && (MATERIALBLENDING_SOLID || MATERIALBLENDING_MASKED)
		// 	float2 NDC = MaterialParameters.ScreenPosition.xy / MaterialParameters.ScreenPosition.w;
		// 	float2 ScreenUV = NDC * ResolvedView.ScreenPositionScaleBias.xy + ResolvedView.ScreenPositionScaleBias.wz;
		// 	NearestResolvedDepthScreenUV = CalculateNearestResolvedDepthScreenUV(ScreenUV, MaterialParameters.ScreenPosition.w);

		// 	IndirectOcclusion = GetIndirectOcclusion(NearestResolvedDepthScreenUV, GBuffer);
		// 	DiffuseIndirectLighting *= IndirectOcclusion;
		// 	SubsurfaceIndirectLighting *= IndirectOcclusion;
		// 	IndirectIrradiance *= IndirectOcclusion;
		// #endif

		DiffuseColor += (DiffuseIndirectLighting * DiffuseColorForIndirect + SubsurfaceIndirectLighting * SubsurfaceColor) * AOMultiBounce( GBuffer.BaseColor, DiffOcclusion );

		#if TRANSLUCENCY_PERVERTEX_FORWARD_SHADING

			//Color += BasePassInterpolants.VertexDiffuseLighting * GBuffer.DiffuseColor;

		#elif FORWARD_SHADING || TRANSLUCENCY_LIGHTING_SURFACE_FORWARDSHADING || TRANSLUCENCY_LIGHTING_SURFACE_LIGHTINGVOLUME
			uint GridIndex = 0;

			//#if INSTANCED_STEREO
			//	const uint EyeIndex = GetEyeIndex(Interpolants.PackedEyeIndex);
			//#else
				const uint EyeIndex = 0;
			//#endif

			#if FEATURE_LEVEL >= FEATURE_LEVEL_SM5
				GridIndex = ComputeLightGridCellIndex((uint2)(MaterialParameters.SvPosition.xy - ResolvedView.ViewRectMin.xy), MaterialParameters.SvPosition.w, EyeIndex);

				#if FORWARD_SHADING || TRANSLUCENCY_LIGHTING_SURFACE_FORWARDSHADING
					const float Dither = InterleavedGradientNoise(MaterialParameters.SvPosition.xy, View.StateFrameIndexMod8);
					Color += GetForwardDirectLighting(GridIndex, MaterialParameters.AbsoluteWorldPosition, MaterialParameters.CameraVector, GBuffer, NearestResolvedDepthScreenUV, EyeIndex, Dither);
				#endif
			#endif
            
            #if !MATERIAL_SHADINGMODEL_HAIR
			    Color += GetImageBasedReflectionLighting(MaterialParameters, GBuffer.Roughness, GBuffer.SpecularColor, IndirectIrradiance, GridIndex, EyeIndex) * IndirectOcclusion * AOMultiBounce( GBuffer.SpecularColor, SpecOcclusion );
		    #endif
        #endif

		// #if SIMPLE_FORWARD_DIRECTIONAL_LIGHT

		// 	float3 DirectionalLighting = GetSimpleForwardLightingDirectionalLight(
		// 		GBuffer,
		// 		DiffuseColorForIndirect,
		// 		GBuffer.SpecularColor,
		// 		GBuffer.Roughness,
		// 		MaterialParameters.WorldNormal, 
		// 		MaterialParameters.CameraVector);
			
		// 	#if STATICLIGHTING_SIGNEDDISTANCEFIELD
		// 		DirectionalLighting *= GBuffer.PrecomputedShadowFactors.x;
		// 	#elif PRECOMPUTED_IRRADIANCE_VOLUME_LIGHTING
		// 		DirectionalLighting *= GetVolumetricLightmapDirectionalLightShadowing(VolumetricLightmapBrickTextureUVs);
		// 	#elif CACHED_POINT_INDIRECT_LIGHTING
		// 		DirectionalLighting *= PrecomputedLightingBuffer.DirectionalLightShadowing;
		// 	#endif
			
		// 	Color += DirectionalLighting;

		// #endif
	#endif

	half3 Emissive = GetMaterialEmissive(PixelMaterialInputs);
	#if !POST_PROCESS_SUBSURFACE
 	// For non-skin, we just add diffuse and non-diffuse color together, otherwise we need to keep them separate
		Color += DiffuseColor;
	#endif
	Color += Emissive;

	GBuffer.IndirectIrradiance = IndirectIrradiance;

	// -0.5 .. 0.5, could be optimzed as lower quality noise would be sufficient
	float QuantizationBias = PseudoRandom( MaterialParameters.SvPosition.xy ) - 0.5f;
	float4 Dummy;
    EncodeGBuffer(GBuffer, OutGbufferA, OutGBufferB, OutGBufferC, OutGBufferD, OutGBufferE, Dummy, QuantizationBias);
    FragmentColors = float4(OutGBufferC.rgb * alpha, alpha);
	OutGBufferC.rgb = float3(0,0,0); // dont write the color until the next pass
    OutSceneColor = float4(Color.rgb, 0);
	
}