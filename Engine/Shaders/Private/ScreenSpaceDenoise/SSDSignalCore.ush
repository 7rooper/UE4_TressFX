// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	SSDCommon.ush: All the code commonly shared between uniform buffers.
=============================================================================*/

#pragma once

#include "SSDCommon.ush"


//------------------------------------------------------- ENUMS

/** Layouts of the signal buffer. */
	/** Buffer layout for the shadow penumbra given as input. */
	#define SIGNAL_BUFFER_LAYOUT_PENUMBRA_INPUT 0

	/** Internal buffer layout for the shadow penumbra. */
	#define SIGNAL_BUFFER_LAYOUT_PENUMBRA_INTERNAL 1

	/** Internal buffer layout used for history rejection for the shadow penumbra. */
	#define SIGNAL_BUFFER_LAYOUT_PENUMBRA_HISTORY_REJECTION 2

	/** Buffer layout taken as input by */
	#define SIGNAL_BUFFER_LAYOUT_PENUMBRA_OUTPUT 3


/** Defines how the signal is being processed. */
	/** Scene color anti aliasing processing. */
	#define SIGNAL_PROCESSING_COLORAA 0

	/** Depth of field stabilization processing. */
	#define SIGNAL_PROCESSING_DOF 1

	/** Shadow penumbra denoising. */
	#define SIGNAL_PROCESSING_PENUMBRA 2

	/** Shadow penumbra denoising. */
	#define SIGNAL_PROCESSING_DIFUSE_GI 3


//------------------------------------------------------- STRUCTURE

/** Generic data structure to manipulate any kind of signal. */
struct FSSFSignalSample
{
	// Number of sample accumulated.
	float AccumulatedSampleCount;

	// Scene color and alpha for anti aliasing.
	float4 SceneColor;

	// The circle of confusion for depth of field.
	float CocRadius;

	// Shadow denoising specific.
	float LeavingRayCount;
	float PenumbraClosestHit;
	float UncertainRayCount;
};

FSSFSignalSample CreateSignalSample()
{
	FSSFSignalSample OutSample;
	OutSample.AccumulatedSampleCount = 0;
	OutSample.SceneColor = 0;
	OutSample.CocRadius = 0;
	OutSample.LeavingRayCount = 0;
	OutSample.PenumbraClosestHit = 0;
	OutSample.UncertainRayCount = 0;
	return OutSample;
}


//------------------------------------------------------- INPUT/OUTPUT

/** Decode input signal sample. */
FSSFSignalSample DecodeInputSignal(const uint SignalBufferLayout, float4 Samples[2])
{
	FSSFSignalSample OutSample = CreateSignalSample();

	if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_PENUMBRA_INPUT)
	{
		OutSample.AccumulatedSampleCount = 1;
		OutSample.LeavingRayCount = OutSample.AccumulatedSampleCount * Samples[0].r;
		OutSample.PenumbraClosestHit = Samples[1].r;
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_PENUMBRA_INTERNAL)
	{
		if (DEBUG_STORE_NORMALIZED_COMPONENTS)
		{
			OutSample.LeavingRayCount = Samples[0].r * Samples[0].b;
			OutSample.UncertainRayCount = Samples[0].g * Samples[0].b;
			OutSample.AccumulatedSampleCount = Samples[0].b - OutSample.UncertainRayCount;
		}
		else
		{
			OutSample.LeavingRayCount = Samples[0].r;
			OutSample.AccumulatedSampleCount = Samples[0].g;
			OutSample.UncertainRayCount = Samples[0].b;
		}
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_PENUMBRA_HISTORY_REJECTION)
	{
		//if (Samples[0].r < 1)
		if (Samples[0].r >= 0)
		{
			OutSample.AccumulatedSampleCount = 1;
			OutSample.LeavingRayCount = OutSample.AccumulatedSampleCount * Samples[0].r; // *(255.0 / 254.0);
		}
	}

	return OutSample;
}

/** Encode output signal sample. */
void EncodeOutputSignal(const uint SignalBufferLayout, FSSFSignalSample Sample, out float4 OutSamples[2], out uint OutBufferCount)
{
	OutSamples[0] = OutSamples[1] = 0;
	OutBufferCount = 1;

	if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_PENUMBRA_INTERNAL)
	{
		if (DEBUG_STORE_NORMALIZED_COMPONENTS)
		{
			OutSamples[0] = float4(
				Sample.UncertainRayCount + Sample.AccumulatedSampleCount > 0
					? Sample.LeavingRayCount / (Sample.UncertainRayCount + Sample.AccumulatedSampleCount)
					: -1.0,
				Sample.UncertainRayCount + Sample.AccumulatedSampleCount > 0
					? Sample.UncertainRayCount / (Sample.UncertainRayCount + Sample.AccumulatedSampleCount)
					: -1.0,
				Sample.UncertainRayCount + Sample.AccumulatedSampleCount,
				0);
		}
		else
		{
			OutSamples[0] = float4(
				Sample.LeavingRayCount,
				Sample.AccumulatedSampleCount,
				Sample.UncertainRayCount,
				0);
		}
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_PENUMBRA_HISTORY_REJECTION)
	{
		//if (Sample.AccumulatedSampleCount == 0)
		//{
		//	OutSamples[0].r = 1.0;
		//}
		//else
		//{
		//	OutSamples[0].r = (254.0 / 255.0) * (Sample.LeavingRayCount / Sample.AccumulatedSampleCount);
		//}

		OutSamples[0].r = Sample.AccumulatedSampleCount == 0 ? -1 : Sample.LeavingRayCount / Sample.AccumulatedSampleCount;
	}
	else if (SignalBufferLayout == SIGNAL_BUFFER_LAYOUT_PENUMBRA_OUTPUT)
	{
		OutSamples[0] = float4(1, 1, 1, 1) * Sample.LeavingRayCount;
	}
}

/** Sample input signal. */
FSSFSignalSample SampleInputSignal(Texture2D SignalBuffer0, Texture2D SignalBuffer1, SamplerState Sampler, const uint SignalBufferLayout, float2 UV, float Level = 0)
{
	float4 Samples[2];
	Samples[0] = SignalBuffer0.SampleLevel(Sampler, UV, Level);
	Samples[1] = SignalBuffer1.SampleLevel(Sampler, UV, Level);
	return DecodeInputSignal(SignalBufferLayout, Samples);
}

/** Sample output signal. */
void OutputSignal(RWTexture2D<float4> OutputSignalBuffer0, RWTexture2D<float4> OutputSignalBuffer1, const uint SignalBufferLayout, const uint2 PixelPosition, FSSFSignalSample Sample)
{
	float4 Samples[2];
	uint BufferCount;
	EncodeOutputSignal(SignalBufferLayout, Sample, Samples, BufferCount);

	if (BufferCount >= 1)
		OutputSignalBuffer0[PixelPosition] = Samples[0];
	if (BufferCount >= 2)
		OutputSignalBuffer1[PixelPosition] = Samples[1];
}


//------------------------------------------------------- SIGNAL OPERATORS

FSSFSignalSample Mul(FSSFSignalSample Sample, float Scalar)
{
	FSSFSignalSample OutSample;
	OutSample.SceneColor             = Sample.SceneColor * Scalar;
	OutSample.CocRadius              = Sample.CocRadius * Scalar;
	OutSample.AccumulatedSampleCount = Sample.AccumulatedSampleCount * Scalar;
	OutSample.LeavingRayCount        = Sample.LeavingRayCount * Scalar;
	OutSample.PenumbraClosestHit     = Sample.PenumbraClosestHit * Scalar;
	OutSample.UncertainRayCount      = Sample.UncertainRayCount * Scalar;
	return OutSample;
}

FSSFSignalSample Add(FSSFSignalSample SampleA, FSSFSignalSample SampleB)
{
	SampleA.SceneColor             += SampleB.SceneColor;
	SampleA.CocRadius              += SampleB.CocRadius;
	SampleA.AccumulatedSampleCount += SampleB.AccumulatedSampleCount;
	SampleA.LeavingRayCount        += SampleB.LeavingRayCount;
	SampleA.PenumbraClosestHit     += SampleB.PenumbraClosestHit;
	SampleA.UncertainRayCount      += SampleB.UncertainRayCount;
	return SampleA;
}

FSSFSignalSample Minus(FSSFSignalSample Sample)
{
	Sample.SceneColor             = -Sample.SceneColor;
	Sample.CocRadius              = -Sample.CocRadius;
	Sample.AccumulatedSampleCount = -Sample.AccumulatedSampleCount;
	Sample.LeavingRayCount        = -Sample.LeavingRayCount;
	Sample.PenumbraClosestHit     = -Sample.PenumbraClosestHit;
	Sample.UncertainRayCount      = -Sample.UncertainRayCount;
	return Sample;
}

FSSFSignalSample Suctract(FSSFSignalSample SampleA, FSSFSignalSample SampleB)
{
	return Add(SampleA, Minus(SampleB));
}

FSSFSignalSample Min(FSSFSignalSample SampleA, FSSFSignalSample SampleB)
{
	FSSFSignalSample OutSample;
	OutSample.SceneColor = min(SampleA.SceneColor, SampleB.SceneColor);
	OutSample.CocRadius = min(SampleA.CocRadius, SampleB.CocRadius);
	OutSample.AccumulatedSampleCount = min(SampleA.AccumulatedSampleCount, SampleB.AccumulatedSampleCount);
	OutSample.LeavingRayCount = min(SampleA.LeavingRayCount, SampleB.LeavingRayCount);
	OutSample.PenumbraClosestHit = min(SampleA.PenumbraClosestHit, SampleB.PenumbraClosestHit);
	OutSample.UncertainRayCount = min(SampleA.UncertainRayCount, SampleB.UncertainRayCount);
	return OutSample;
}

FSSFSignalSample Max(FSSFSignalSample SampleA, FSSFSignalSample SampleB)
{
	FSSFSignalSample OutSample;
	OutSample.SceneColor = max(SampleA.SceneColor, SampleB.SceneColor);
	OutSample.CocRadius = max(SampleA.CocRadius, SampleB.CocRadius);
	OutSample.AccumulatedSampleCount = max(SampleA.AccumulatedSampleCount, SampleB.AccumulatedSampleCount);
	OutSample.LeavingRayCount = max(SampleA.LeavingRayCount, SampleB.LeavingRayCount);
	OutSample.PenumbraClosestHit = max(SampleA.PenumbraClosestHit, SampleB.PenumbraClosestHit);
	OutSample.UncertainRayCount = max(SampleA.UncertainRayCount, SampleB.UncertainRayCount);
	return OutSample;
}

FSSFSignalSample Clamp(FSSFSignalSample Sample, FSSFSignalSample SampleMin, FSSFSignalSample SampleMax)
{
	return Max(Min(Sample, SampleMax), SampleMin);
}

FSSFSignalSample Lerp(FSSFSignalSample Sample0, FSSFSignalSample Sample1, float Interp)
{
	return Add(Sample0, Mul(Suctract(Sample1, Sample0), Interp));
}

/** Normalize the signal sample to one. */
FSSFSignalSample NormalizeToOneSample(FSSFSignalSample Sample)
{
	float NormalizationFactor = -min(-rcp(Sample.AccumulatedSampleCount), 0);

	FSSFSignalSample OutSample = Mul(Sample, NormalizationFactor);
	return OutSample;
}
