// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
PathTracingSpecularReflection.usf: Lambertian BRDF sampling functions
===============================================================================================*/
#pragma once

//// Fixed version of GetTangentBasis that follows UE axis conventions
//float3x3 GetTangentBasis_NEW(float3 TangentZ)
//{
//	const float Sign = TangentZ.z >= 0 ? 1 : -1;
//	const float a = -rcp(Sign + TangentZ.z);
//	const float b = TangentZ.x * TangentZ.y * a;
//
//	float3 TangentY = { -1*(1 + Sign * a * Pow2(TangentZ.x)), -Sign * b, Sign * TangentZ.x };
//	float3 TangentX = { b,  Sign + a * Pow2(TangentZ.y), -TangentZ.y };
//
//	return float3x3(TangentX, TangentY, TangentZ);
//}

void SpecularReflection_SampleMaterial(
	float3 RayDirection,
	FMaterialClosestHitPayload Payload,
	out float3 OutDirection,
	out float3 OutThroughput,
	out float OutPdf)
{
	float3 N_World = GetWorldNormal(Payload);
	float3 DiffuseColor = GetDiffuseColor(Payload);

	//OutDirection = reflect(RayDirection, N_World); // To reflect in world coords directly
	float3 V_World = normalize(-RayDirection);
	float3 V_Local = WorldToTangent(V_World, N_World);

	float3 L_Local;
	L_Local.x = -V_Local.x;
	L_Local.y = -V_Local.y;
	L_Local.z = V_Local.z;
	OutDirection = TangentToWorld(L_Local, N_World);

	float NoL = max(L_Local.z, 0.0);
	OutThroughput = DiffuseColor * NoL;
	OutPdf = 1.0;
}

float SpecularReflection_Pdf()
{
	return 0.0;
}

void SpecularReflection_EvalMaterial(out float3 OutThroughput, out float OutPdf)
{
	OutThroughput = float3(0.0, 0.0, 0.0);
	OutPdf = SpecularReflection_Pdf();
}